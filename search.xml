<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Android] adb 기본 가이드</title>
    <url>/2020/08/16/adb_starter_guide/</url>
    <content><![CDATA[<p><img src="/images/cover/adb_starter_guide.jpg" alt><br>대부분의 디버깅 작업은 안드로이드 스튜디오 내부 디버거와 프로파일러를 이용하면 진행이 가능하기 때문에 adb 의 필요성을 크게 느끼지 못했다. 그런데 간혹 스튜디오 도구만으로는 해결이 어렵거나 애매한 케이스들을 맞이할 상황이 생겼고, 깊게 파보다 보니 adb 를 이용해 디버깅 할 수 있다는 사실을 알게 되었다.</p>
<p>사실 같은 작업을 수행한다면 커맨드 라인보다 GUI 를 선호해서 그런지 adb 와 그리 친숙하지 않았는데, 공부하다보니 제법 유용한 기능이 많아서 이번 기회에 간단히 정리를 했다.</p>
<h1 id="시작하기-전에"><a href="#시작하기-전에" class="headerlink" title="시작하기 전에"></a>시작하기 전에</h1><p>adb 를 이용하기 전에 2가지 작업이 선행되어야 한다.</p>
<p><strong>1. 환경변수 설정</strong></p>
<p>adb 명령을 편하게 사용하기 위해서는 환경변수 설정이 필수다. MAC/window 별 설정 방법은 이미 자세히 설명되어있는 글들이 많으므로 생략한다.</p>
<p><strong>2. USB 디버깅 허용</strong></p>
<p>개발자 옵션 - USB 디버깅 항목에 대해 on 을 해줘야 adb - 기기간 통신이 가능해진다.</p>
<h1 id="기본"><a href="#기본" class="headerlink" title="기본"></a>기본</h1><p>가장 많이 사용했던 명령어 및 상황을 정리해봤다.</p>
<h2 id="디바이스-조회"><a href="#디바이스-조회" class="headerlink" title="디바이스 조회"></a>디바이스 조회</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; adb devices [-l]</span><br></pre></td></tr></table></figure>

<p>위 명령은 adb 서버에 연결된 디바이스의 시리얼 넘버와 상태를 차례로 출력한다.</p>
<p>상태는 아래와 같은 케이스가 있다.</p>
<ul>
<li><strong>device</strong> : 정상적으로 연결되어 있다. 하지만 시스템이 부팅되는동안 adb 에 연결이 되기 때문에 시스템 부팅이 완료되었다고 보장하는 상태는 아니다.</li>
<li><strong>no device</strong> : 연결되어있는 디바이스가 없다.</li>
<li><strong>offline</strong> : 기기가 adb 에 연결되어 있지 않다. usb 선에 문제가 있는지 살펴보자.</li>
<li><strong>unauthorized</strong> : USB 디버깅이 허용되지 않은 기기이다.</li>
</ul>
<h3 id="특정-디바이스에-명령을-해야할-때"><a href="#특정-디바이스에-명령을-해야할-때" class="headerlink" title="특정 디바이스에 명령을 해야할 때"></a>특정 디바이스에 명령을 해야할 때</h3><p>연결되어있는 디바이스가 1개라면 별도 옵션 추가 없이 adb 명령어를 사용할 수 있다. 그러나 연결된 디바이스가 2개이상일 경우, 이전에 사용한 명령어를 입력하면 어느 기기를 기준으로 adb 명령이 수행되어야 하는 알 수 없기 때문에 아래와 같은 에러가 발생한다.</p>
<blockquote>
<p>“more than one device/emulator”</p>
</blockquote>
<p>옵션과 시리얼 넘버를 이용하여 해결이 가능하다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 연결된 디바이스 정보 확인</span><br><span class="line">&gt; adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">SM1234            device</span><br><span class="line">emulator-1234     device</span><br><span class="line"></span><br><span class="line">// -s 옵션, 특정 디바이스 를 지정한 후 명령어 수행</span><br><span class="line">&gt; adb -s SM1234 shell <span class="variable">$command</span></span><br><span class="line"></span><br><span class="line">// -d 옵션, 연결된 하드웨어 디바이스가 1개라면 자동 지정 후 명령어 수행</span><br><span class="line">&gt; adb -d shell <span class="variable">$command</span></span><br><span class="line"></span><br><span class="line">// -e 옵션, 연결된 에뮬레이터 디바이스가 1개라면 자동 지정 후 명령어 수행</span><br><span class="line">&gt; adb -e shell <span class="variable">$command</span></span><br></pre></td></tr></table></figure>

<h2 id="adb-초기화"><a href="#adb-초기화" class="headerlink" title="adb 초기화"></a>adb 초기화</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; adb <span class="built_in">kill</span>-server</span><br></pre></td></tr></table></figure>

<p>adb 서버 프로세를 kill 한다. adb 가 먹통일 때 주로 사용한다. 어떤 adb 명령어든 다시 입력하면 서버가 재시작한다.</p>
<h2 id="기기에-기기에서-파일-복사"><a href="#기기에-기기에서-파일-복사" class="headerlink" title="기기에/기기에서 파일 복사"></a>기기에/기기에서 파일 복사</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 디바이스에서 개발 머신으로 파일 복사</span><br><span class="line">&gt; adb pull <span class="variable">$devicePath</span> <span class="variable">$macihnePath</span></span><br><span class="line"></span><br><span class="line">// 개발 머신에서 디바이스로 파일 복사</span><br><span class="line">&gt; adb push <span class="variable">$machinePath</span> <span class="variable">$devicePath</span></span><br></pre></td></tr></table></figure>

<p>디바이스의 host 파일을 변경할 때 유용하게 활용했다.</p>
<h1 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h1><p>adb 는 shell 명령어로 직접 기기를 제어하거나 기기정보를 가져올 수 있다. dumpsys 명령은 연결된 기기의 시스템 서비스 정보를 가져올 수 있다. 가장 기본적인 명령어를 입력하면 너무 방대한 정보가 한꺼번에 출력되기 때문에 다양한 옵션과 grep 을 적절히 활용하여 필요한 정보만 꺼내보는 지혜가 필요하다. 직접 활용하고 있는 몇가지 케이스에 대해서만 다룰예정이다.</p>
<h2 id="Acitivty-stack-출력하기"><a href="#Acitivty-stack-출력하기" class="headerlink" title="Acitivty stack 출력하기"></a>Acitivty stack 출력하기</h2><p>Activity stack 이 깊고 복잡할수록 디버깅이 힘들어진다. adb 의 존재를 알기 전에는 스택의 구성을 알아내기 위해 하나하나 백버튼을 눌러봤던 기억이 있다. </p>
<p>activity stack 을 볼 수 있는 기본 명령은 다음과 같다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; adb shell dumpsys activity activities</span><br></pre></td></tr></table></figure>

<p>그런데 위 명령은 현재 디바이스에서 활성화되어있는 모든 앱에대한 Acitivty 정보를 가져오기 때문에 필요한 정보를 금방 파악하기 어렵다. </p>
<p>우리가 알고 싶은 것은 특정 앱에 대한 Activity stack 이므로 필터링이 필요하다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; adb shell dumpsys activity activities | grep -i <span class="variable">$packageName</span> | grep -i Hist</span><br></pre></td></tr></table></figure>

<p>명령어의 결과는 다음과 같다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* Hist <span class="comment">#1: ActivityRecord&#123;692b031 u0 com.android.settings/.SubSettings t630&#125;</span></span><br><span class="line">* Hist <span class="comment">#0: ActivityRecord&#123;8e296f3 u0 com.android.settings/.homepage.SettingsHomepageActivity t630&#125;</span></span><br></pre></td></tr></table></figure>

<p>Hist (History) 의 숫자가 낮을수록 stack 에 먼저 추가된 Activity 이다. Hist 숫자가 가장 큰 Activity 가 현재 화면상에 나타나는 Activity 이므로, 현재 화면의 Activity 이름을 찾을때도 유용하게 활용할 수 있다.</p>
<h2 id="Doze-앱-대기-모드-테스트"><a href="#Doze-앱-대기-모드-테스트" class="headerlink" title="Doze, 앱 대기 모드 테스트"></a>Doze, 앱 대기 모드 테스트</h2><p>간혹 Doze 모드, 앱 대기 모드로 인한 이슈를 확인해야할 상황이 생긴다. 문제는 각 조건을 충족하여 모드를 재현하는 것이 꽤나 수고스러운 일이라는 점이다. 이를 대비하여 adb 에서는 각 모드로 진입할 수 있는 명령어를 제공한다.</p>
<h3 id="Doze-모드-테스트"><a href="#Doze-모드-테스트" class="headerlink" title="Doze 모드 테스트"></a>Doze 모드 테스트</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; adb shell dumpsys deviceidle force-idle // Doze 모드 돌입</span><br><span class="line"></span><br><span class="line">// Doze 모드 테스트...</span><br><span class="line"></span><br><span class="line">&gt; adb shell dumpsys deviceidle unforce // Doze 모드 해제</span><br><span class="line">&gt; adb shell dumpsys battery reset // 배터리 상태 리셋</span><br></pre></td></tr></table></figure>

<h3 id="앱-대기-모드-테스트"><a href="#앱-대기-모드-테스트" class="headerlink" title="앱 대기 모드 테스트"></a>앱 대기 모드 테스트</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 앱 대기모드 활성화</span><br><span class="line">&gt; adb shell dumpsys battery unplug</span><br><span class="line">&gt; adb shell am <span class="built_in">set</span>-inactive <span class="variable">$packageName</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 앱 대기모드 해제</span><br><span class="line">&gt; adb shell am <span class="built_in">set</span>-inactive <span class="variable">$packageName</span> <span class="literal">false</span></span><br><span class="line">&gt; adb shell am get-inactive <span class="variable">$packageName</span></span><br></pre></td></tr></table></figure>

<h1 id="am-activity-manager"><a href="#am-activity-manager" class="headerlink" title="am (activity manager)"></a>am (activity manager)</h1><p>am 은 각종 컴포넌트 수행, 화면 속성 수정 등 다양한 시스템 작업을 수행하는 명령어이다.</p>
<h2 id="Activity-시작"><a href="#Activity-시작" class="headerlink" title="Activity 시작"></a>Activity 시작</h2><p>am start 명령은 지정된 intent 정보를 기반으로 activity 를 실행한다. 옵션을 이용하여 인텐트 구성에 필요한 정보를 추가할 수 있다. <a href="https://developer.android.com/studio/command-line/adb?hl=ko#IntentSpec" target="_blank" rel="noopener">IntentSpec</a></p>
<h3 id="앱-내-Activity-로드"><a href="#앱-내-Activity-로드" class="headerlink" title="앱 내 Activity 로드"></a>앱 내 Activity 로드</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; adb shell am start -n <span class="variable">$packageName</span>/<span class="variable">$activityName</span></span><br></pre></td></tr></table></figure>

<p><strong>-n</strong> 옵션은 패키지 정보를 기반으로 명시적 인텐트를 생성한다. 이때 activityName 은 클래스 이름이 아닌 manifest 에 등록된 <strong>android:name</strong> 값 이다. 또한 위 명령어로 실행할 수 있는 Activity 는 <strong>android:exported</strong> 옵션이 true 인 Activity 만 가능하다.<br>아마 보안상 대부분의 Activity 는 exported 가 false 일 것 이므로 유용한 상황은 많이 없다. Intent filter 가 걸려있는 Activity 는 exported 를 true 로 유지해야 하므로 실행이 가능하나 intent filter 특성상 추가로 데이터를 넘기지 않으면 원하는 동작을 확인하기는 어려울 것이다.</p>
<h3 id="커스텀-스킴-테스트"><a href="#커스텀-스킴-테스트" class="headerlink" title="커스텀 스킴 테스트"></a>커스텀 스킴 테스트</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; adb shell am start -a android.intent.action.VIEW <span class="variable">$customScheme</span>://<span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<p><strong>-a</strong> 옵션은 Intent 의 Action 을 지정한다. 커스텀 스킴을 지정한 인텐트 필터를 설정 후 테스트 할때 유용하다. </p>
<h1 id="그외"><a href="#그외" class="headerlink" title="그외.."></a>그외..</h1><p>자주 활용하는 명령어를 위주로 정리 해봤다. 이 외에도 adb 로 할 수 있는 일은 무궁무진하다. 다만 모든 명령어를 다 외우는 것은 큰 의미가 없고, 어떠한 제어가 가능한지 인지하고 있다가 필요할 때 찾아서 쓰고 정리하면 충분하다고 생각된다.</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>[Java] Generic 도장깨기</title>
    <url>/2020/07/31/generic_guide/</url>
    <content><![CDATA[<p><img src="/images/cover/generic_guide.jpg" alt><br>제네릭을 활용할 일이 많은데 겉핥기 식으로만 알고 있다는 생각이 들어 이번 기회에 관련 내용들을 정리했다.</p>
<h1 id="무엇인가"><a href="#무엇인가" class="headerlink" title="무엇인가?"></a>무엇인가?</h1><p>제네릭은 클래스, 인터페이스 및 메서드를 정의할 때 내부에서 사용될 type 을 parameter 로 전달할 수 있는 개념이다.</p>
<p>간단히 아래와 같이 표현이 가능하다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsClass</span> &lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericsInterface</span> &lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiGenericsClass</span> &lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123; &#125; <span class="comment">// 여러개도 가능하다!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">getResult</span><span class="params">(T parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something with parameter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예시에서 GenericsClass, GenericsInterface 처럼 type parameter 를 전달받는 클래스 / 인터페이스를 <strong>Parameterized Types</strong> 라고 칭하기도 한다.</p>
<h1 id="왜-사용하는가"><a href="#왜-사용하는가" class="headerlink" title="왜 사용하는가?"></a>왜 사용하는가?</h1><h2 id="사용-시-장점"><a href="#사용-시-장점" class="headerlink" title="사용 시 장점"></a>사용 시 장점</h2><ul>
<li>컴파일 타임에 타입 체크 가능</li>
<li>캐스팅 불필요</li>
<li>특정 타입에 종속되지 않은 유연한 로직</li>
</ul>
<h2 id="사용-시-단점"><a href="#사용-시-단점" class="headerlink" title="사용 시 단점"></a>사용 시 단점</h2><p>단점이 있다면 <strong>코드의 가독성이 떨어지게 된다.</strong> 사실 이건 제네릭만의 단점이라기보다 보통 유연하고 느슨한 코드일 수록 가독성이 떨어지게 되는데 일종의 트레이드 오프라고 볼 수 있다.</p>
<h1 id="Subtyping"><a href="#Subtyping" class="headerlink" title="Subtyping"></a>Subtyping</h1><p>자바는 is - a 관계일 경우 아래 코드가 문제없이 작동한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object newData = <span class="keyword">new</span> Object();</span><br><span class="line">Integer newNumber = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">newData = newNumber;</span><br></pre></td></tr></table></figure>

<p>제네릭 콜렉션에 값을 추가할 때도 마찬가지이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">object.add(<span class="number">1</span>);</span><br><span class="line">object.add(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>

<p>그러나 아래 코드는 에러가 발생한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">objects = numbers; <span class="comment">// compile time error</span></span><br></pre></td></tr></table></figure>

<p>List&lt;Integer&gt; 는 List&lt;Object&gt; 의 <strong>서브타입이 아니기 때문이다.</strong> 이를 Invariant (무공변성, 불변성) 하다고 이야기 한다. 이에 대해서는 Type Bound 파트에서 좀 더 자세히 다뤄보자.</p>
<p>Parameterized Type 이 기본적으로 불변성을 가지는 이유는 타입 안정성을 컴파일 타임에 보장하기 위해서이다. 만약 Parameterized Type 에 subtyping 이 허용된다고 가정해보자. 그렇게 되면 어떤 타입의 파라미터가 넘어올지 컴파일 타임에 미리 아는 것이 불가능하고, 예외 발생을 막기위해 지속적으로 타입 체크가 필요하다.  즉, 제네릭의 장점을 전혀 취할 수 없게 된다. 따라서 타입 안정성을 보장하기 위해서 Parameterized Type 은 기본적으로 Invariant 하다.</p>
<h1 id="Type-Bound-와-Variance"><a href="#Type-Bound-와-Variance" class="headerlink" title="Type Bound 와 Variance"></a>Type Bound 와 Variance</h1><p>Computer Science 에는 Variance 라는 개념이 있다.</p>
<blockquote>
<p>Variance refers to how subtyping between more complex types relates to subtyping between their components.</p>
</blockquote>
<p>쉽게 얘기하면 element 와 element 를 포함하고 있는 컴포넌트가 있을 때 element 간의 sub type 관계가 컴포넌트간의 sub type 관계에 영향을 주는 정도를 의미한다.</p>
<p>영향도에 따라 다음과 같이 나눌 수 있다. </p>
<ul>
<li>Invariant (무공변성) : T → T’ 일 때 &lt;T&gt;, &lt;T’&gt; 는 서로 별개의 타입이면 &lt;T&gt; 는 Invariant 하다.</li>
<li>Covariant (공변성) : T→ T’ 일 때 &lt;T&gt; → &lt;T’&gt; 가 성립하면 &lt;T&gt; 는 covariant 하다.</li>
<li>Contravariant (반공변성) : T → T’ 일 때 &lt;T&gt; ← &lt;T’&gt; 가 성립하면 &lt;T&gt; 는 contravariant 하다.</li>
</ul>
<p>T 는 element, &lt;T&gt; 는 element를 포함하는 컴포넌트를 의미하며 A → B 이면 <strong>A 는 B 의 서브 타입이다.</strong> 이때 서브 타입은 자바의 상속만이 아니라 더 넓은 개념인 <a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener">Subtyping</a> 을 의미한다.  </p>
<p>제네릭은 Type bound 를 적용하여 parameterized type 의 Variance 를 결정할 수 있다. 화살표 방향에 유의하며 하나씩 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 예시 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KoreanShortHair</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-Unbounded-type"><a href="#1-Unbounded-type" class="headerlink" title="1. Unbounded type"></a>1. Unbounded type</h2><blockquote>
<p>&lt;T&gt;, &lt;?&gt;</p>
</blockquote>
<ul>
<li>제네릭 타입 선언 후 아무런 키워드도 붙히지 않으면 unbounded type 이다.</li>
<li>Unbounded type 타입 파라미터로 선언된 Parameterized type 은 모든 타입 파라미터에 대해 <strong>Invariant</strong> 하다.</li>
<li>Cat → Animal 일때 &lt;Cat&gt; 와 &lt;? extends Animal&gt; 는 서로 아무런 연관관계를 가지지 않는 각각 별개의 타입이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// unbounded type parameter</span></span><br><span class="line">List&lt;Cat&gt; cats = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">animals = cats <span class="comment">// Fail, 서로 다른 타입으로 판단한다.</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Upper-bounded-type"><a href="#2-Upper-bounded-type" class="headerlink" title="2. Upper bounded type"></a>2. Upper bounded type</h2><blockquote>
<p>&lt;T <strong>extends</strong> Animal&gt;, &lt;? <strong>extends</strong> Animal&gt;</p>
</blockquote>
<ul>
<li>Upper bounded type 은 제네릭 타입 선언 후 extends 키워드를 이용하여 구현가능하다.</li>
<li>Upper bounded type 타입 파라미터로 선언된 Parameterized type 는 자기 자신 혹은 하위 클래스의 타입 파라미터에 대해 <strong>Covariant</strong> 하다. </li>
<li>예를 들어 Cat → Animal 이면 &lt;Cat&gt; → &lt;? extends Animal&gt; 이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// upper bounded parameterized type</span></span><br><span class="line">List&lt;Cat&gt; cats = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;KoreanShortHair&gt; koreanShortHairs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">animals = cats; <span class="comment">// Ok, cats 는 animals 의 서브타입이다.</span></span><br><span class="line">animals = koreanShortHairs; <span class="comment">// Ok, koreanShortHairs 는 animals 의 서브타입이다.</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Lower-bounded-type"><a href="#3-Lower-bounded-type" class="headerlink" title="3. Lower bounded type"></a>3. Lower bounded type</h2><blockquote>
<p>&lt;T <strong>super</strong> Cat&gt;, &lt;? <strong>super</strong> Cat&gt;</p>
</blockquote>
<ul>
<li>Lower bounded type 은 제네릭 타입 선언 후 super 키워드를 붙히고 원하는 타입을 적으면된다.</li>
<li>Lower bounded type 타입 파라미터로 선언된 Parameterized type 는 자기 자신 혹은 상위 클래스의 타입 파라미터에 대해 <strong>Contravariant</strong> 하다.</li>
<li>예를 들어 Cat → Animal 이면 &lt;Animal&gt; → &lt;? super Cat&gt; 이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;? <span class="keyword">super</span> Cat&gt; superCats = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// lower bounded parameterized type</span></span><br><span class="line">List&lt;KoreanShortHair&gt; koreanShortHairs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">cats = animals; <span class="comment">// Ok, animals 는 superCats 의 서브 타입이다.</span></span><br><span class="line">cats = koreanShortHairs; <span class="comment">// Fail, KoreanShortHair 는 Cat 의 상위클래스가 아니다.</span></span><br></pre></td></tr></table></figure>

<h2 id="Multi-bound"><a href="#Multi-bound" class="headerlink" title="Multi bound"></a>Multi bound</h2><p>Upper bounded type 에 한하여 N 개의 bound 적용이 가능하다. 이때 사용되는 연산자는 <strong>&amp;</strong> 이다. 특징은 다음과 같다.</p>
<ul>
<li>자바는 다중 상속이 허용되지 않는다. 따라서 부모 클래스가 2개 이상일 수 없으므로 Multi bound 에서 bound 할 수 있는 클래스 타입은 0 ~ 1개 이다.</li>
<li>위와 같은 맥락으로 인터페이스 타입은 bound 개수 제한이 없다.</li>
<li>클래스 타입과 인터페이스 타입을 같이 사용할 경우 클래스 타입이 제일 앞에 선언되어야 한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">B</span> &amp; <span class="title">C</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; <span class="title">int</span> <span class="title">compareNumbers</span>(<span class="title">T</span> <span class="title">t1</span>, <span class="title">T</span> <span class="title">t2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.compareTo(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test 클래스의 타입 파라미터 T 는 A 의 서브타입이고, B 와 C 를 구현해야한다. </p>
<p>compareNumbers 메소드의 타입 파라미터 T 는 Number 의 서브타입이고, Comparable 를 구현해야한다. </p>
<h2 id="어디에-활용할-수-있을까-PECS"><a href="#어디에-활용할-수-있을까-PECS" class="headerlink" title="어디에 활용할 수 있을까? (PECS)"></a>어디에 활용할 수 있을까? (PECS)</h2><p>Type bound 를 활용하면 기본 제네릭에서 한번 더 확장이 가능하므로 좀 더 유연한 코드가 될 수 있다. 하지만 어떤 케이스에서 활용해야할지 감이 잘 오지 않는다. 이를 위하여 PECS 라는 규칙이 나오게 되었다.</p>
<p>PECS 란 Producer - extends, Consumer - super 의 약자이다. 생산자는 extends 를 소비자는 super 키워드를 활용하라는 의미이다.</p>
<p>생산자, 소비자라는 표현이 직관적으로 와닿지 않으므로 다음과 같이 이해해도 좋다.</p>
<blockquote>
<p>Read - extends, Write - super</p>
</blockquote>
<p>왜 그런지 한번 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extends</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(List&lt;? extends Animal&gt; animals)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">        print(animal.toString()); <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(List&lt;? extends Animal&gt; animals)</span> </span>&#123; </span><br><span class="line">    animals.add(<span class="keyword">new</span> Animal()); <span class="comment">// compile time error</span></span><br><span class="line">    animals.add(<span class="keyword">new</span> Cat()); <span class="comment">// compile time error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(List&lt;? <span class="keyword">super</span> Cat&gt; cats)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (Cat cat : cats) &#123;</span><br><span class="line">        print(cat.toString()); <span class="comment">// compile time error</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(List&lt;? <span class="keyword">super</span> Cat&gt; cats)</span> </span>&#123; </span><br><span class="line">    cat.add(<span class="keyword">new</span> Animal()); <span class="comment">// compile time error</span></span><br><span class="line">    cat.add(<span class="keyword">new</span> KoreanShortHair()); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Read - extends</strong></p>
<ul>
<li>read 메소드를 살펴보면 animals 의 각 element 를 Animal 타입으로 읽는 것은 문제 되지 않는다. 왜냐하면 어떠한 List 가 들어오더라도 내부 element 는 최소한 Animal 을 상속받았을 것이 보장되기 때문이다.</li>
<li>한편 write 메소드를 살펴보면 add 를 시도할 경우 자신을 포함한 Animal 의 하위 타입을 전달했을 때 오류가 발생한다. 이유는 전달된 animals 의 element 는 animal 을 상속받은 것만 보장할뿐 구체적으로 어떤 타입인지는 알 수 없기 때문이다. 이를 허용할 경우 런타임에 타입 불일치로 오류가 발생할 수 있는 가능성이 생길 수 있다. (ex / List&lt;Cat&gt; 을 전달받았는데 Animal 객체를 추가하는 경우)</li>
</ul>
<p>따라서 상방으로 닫혀있는 extends 는 read 에 적합하다.</p>
<p><strong>Write - super</strong></p>
<ul>
<li>write 메소드를 먼저 살펴보면 cats 는 cat 의 <strong>하위타입에 한하여</strong> 어떠한 객체든 추가가 가능하다. cats 의 element 는 Cat 의 상위 타입인 것이 보장되기 때문이다.  ( ? → Cat → ? super Cat )</li>
<li>read 메소드를 살펴보면 이제 슬슬 감이 온다. cats 의 element 는 Cat 의 상위 타입이므로 항상 Cat 자신이라고 보장할 수 없기 때문에 Cat 이라는 타입으로 확정지어 사용할 수 없다.</li>
</ul>
<p>만약, read &amp; write 를 모두 하는 케이스의 경우 type bound 를 사용할 수 없다!</p>
<h1 id="Wildcard"><a href="#Wildcard" class="headerlink" title="Wildcard"></a>Wildcard</h1><p>Type bound 파트에서 먼저 언급이 되었는데, <strong>&lt;?&gt;</strong> 와 같이 물음표를 이용하여 제네릭 타입을 표현하는 것을 와일드 카드라고 부른다. 와일드 카드는 다음과 같은 특징이 있다.</p>
<ul>
<li><p>어떤 타입이든 가리지 않고 전달이 가능하다.</p>
</li>
<li><p>제네릭 클래스의 파라미터, 제네릭 메소드의 인자 자체로는 사용이 불가능하다.</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &lt;?&gt; </span>&#123; &#125; <span class="comment">// 불가능</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeTest</span><span class="params">(&lt;?&gt; parameter)</span> </span>&#123; &#125; <span class="comment">// 불가능</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Type bound 에 따라 불리는 명칭이 다르다.</p>
<ul>
<li>&lt;?&gt; : unbounded wildcard</li>
<li>&lt;? extends Animal&gt; : upper bounded wildcard</li>
<li>&lt;? super Animal&gt; : lower bounded wildcard</li>
</ul>
<p>upper bounded wildcard, lower bounded wildcard 에 대한 얘기는 Type bound 파트에서 이미 대부분 다뤘으므로 unbounded wildcard 에 대해서만 잠깐 정리해보자.</p>
<h2 id="lt-gt-unbounded-wildcard"><a href="#lt-gt-unbounded-wildcard" class="headerlink" title="&lt;?&gt; : unbounded wildcard"></a>&lt;?&gt; : unbounded wildcard</h2><p>unbounded wildcards 는 제네릭 계의 Object 클래스 이다.  따라서 실제 특징도 Object 와 비슷하다.</p>
<ul>
<li><p><strong>? 를 Object 로 바꿔서 사용하는 것이 가능하다.</strong></p>
<p>  → unbounded wildcard type 은 컴파일 과정에서 Object 타입으로 판단하기 때문에 코드상에서 Object 로 취급하여도 오류가 발생하지 않는다. (후술할 reifiable type 이기도 하다.)</p>
</li>
<li><p><strong>&lt;?&gt; 는 Covariant 하다.</strong></p>
<p>  → 모든 T에 대하여 T → ?, &lt;T&gt; → &lt;?&gt; 가 성립한다.  </p>
<p>  &lt;사진&gt;</p>
</li>
</ul>
<p>이러한 특징을 고려하여 활용할 수 있는 케이스는 크게 2가지가 있다.</p>
<h3 id="1-Object-클래스가-제공하는-기능을-사용하여-구현-해야할-때"><a href="#1-Object-클래스가-제공하는-기능을-사용하여-구현-해야할-때" class="headerlink" title="1. Object 클래스가 제공하는 기능을 사용하여 구현 해야할 때"></a>1. Object 클래스가 제공하는 기능을 사용하여 구현 해야할 때</h3><p>Object 타입 기반의 메소드가 있다고 가정하자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseString</span><span class="params">(List&lt;Object&gt; objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object object : objects) &#123;</span><br><span class="line">        print(object.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 메소드는 Object 타입 List 를 전달받으므로 범용성이 클 것 같지만 위에서 다룬 Variance 룰에 의하여 List&lt;Integer&gt;, List&lt;String&gt; 과 같은 Object 하위 타입 리스트를 전달할 수 없다. 이때 unbounded wildcard 를 이용하면 해결할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseString</span><span class="params">(List&lt;?&gt; objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object object : objects) &#123;</span><br><span class="line">        print(object.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-타입에-의존하지-않는-로직을-수행할-때"><a href="#2-타입에-의존하지-않는-로직을-수행할-때" class="headerlink" title="2. 타입에 의존하지 않는 로직을 수행할 때"></a>2. 타입에 의존하지 않는 로직을 수행할 때</h3><p>List 의 size(), clear() 와 같이 타입이 무엇이든 상관없이 수행이 가능한 메소드들이 있다. 이럴 때 unbounded wildcard 가 사용된 parameterized type 을 사용하면 유연한 코드 작성이 가능하다.</p>
<h1 id="Type-erasure"><a href="#Type-erasure" class="headerlink" title="Type erasure"></a>Type erasure</h1><p>자바 컴파일러는 컴파일 과정에서 제네릭에 대해 타입 소거(Type erasure)를 진행한다. 타입 소거란 타입정보를 컴파일 타임에만 유지하고, 런타임에는 삭제시켜 버리는 것인데 과거 제네릭이 없던 버전과의 하위 호환성을 위해서이다.</p>
<p>타입소거가 이루어진 클래스는 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 타입소거 전</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(T paramenter)</span> </span>&#123;</span><br><span class="line">        paramenter.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입소거 후</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(Object paramenter)</span> </span>&#123;</span><br><span class="line">        paramenter.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>컴파일러는 Unbound type 에 대하여 Object 로 바꿔버렸다. 따라서 런타임에는 해당 타입이 본래 어떤 타입이었는지 알 수 없다. 타입 소거에 대한 동작은 다음과 같다.</p>
<ul>
<li>Unbound type 의 경우 Object, bound type 의 경우 bound 값을 기준으로 타입을 바꾼다.</li>
<li>필요에 따라 캐스팅 및 bridge 메소드가 추가될 수 도 있다.</li>
</ul>
<h2 id="Non-Reifiable-Type"><a href="#Non-Reifiable-Type" class="headerlink" title="Non-Reifiable Type"></a>Non-Reifiable Type</h2><p>런타임에 타입 정보의 유무에 따라 Reifialbe type, Non - Reifialbe type 으로 구분한다.</p>
<ul>
<li>Refiable type : 런타임에 타입에 대한 정보를 가지고 있다. 대표적으로 primitive, non - generic, unbounded wildcards (&lt;?&gt;) 등 이 있다.</li>
<li>Non - Reifiable type : 런타임에 타입에 대한 정보가 없다. 대표적으로 type erasure 가 진행되는 대부분의 generic parameterized type 이 있다.</li>
</ul>
<p>제네릭이 가지는 한계점은 대부분 이 타입 소거라는 특징 때문에 발생할 만큼 기억해둬야할 원리다. 타입 소거로 인한 이슈를 피하기 위한 기법 <a href="https://www.baeldung.com/java-super-type-tokens" target="_blank" rel="noopener">super type token</a> 이 나오기도 했다.</p>
<h1 id="제네릭의-한계점"><a href="#제네릭의-한계점" class="headerlink" title="제네릭의 한계점"></a>제네릭의 한계점</h1><h2 id="원시값을-제네릭-타입으로-사용할-수-없다"><a href="#원시값을-제네릭-타입으로-사용할-수-없다" class="headerlink" title="원시값을 제네릭 타입으로 사용할 수 없다"></a>원시값을 제네릭 타입으로 사용할 수 없다</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// compile time error</span></span><br><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>

<p>원시값을 사용하기 위해서는 Wrapper class 를 사용해야한다. 허용되지 않는 이유가 타입소거 때문인줄 알았는데 컴파일러 구현 이슈 때문이라는 의견이 있었다. 이 부분은 좀 더 정확한 정보를 찾게 되면 다시 업데이트가 필요하다.</p>
<h2 id="제네릭-타입의-인스턴스를-생성할-수-없다"><a href="#제네릭-타입의-인스턴스를-생성할-수-없다" class="headerlink" title="제네릭 타입의 인스턴스를 생성할 수 없다"></a>제네릭 타입의 인스턴스를 생성할 수 없다</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E instnace = <span class="keyword">new</span> E(); <span class="comment">// compile time error</span></span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이유는 타입소거로 인하여 생성해야할 타입이 무엇인지 알 수 없기 때문이다. 꼭 생성이 필요할 경우 리플렉션을 이용하면 가능하다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">createInstance</span><span class="params">(Class&lt;E&gt; clazz)</span> </span>&#123;</span><br><span class="line">    E instnace = clazz.newInstance(); <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Parameterized-type-을-instanceOf-로-비교할-수-없다"><a href="#Parameterized-type-을-instanceOf-로-비교할-수-없다" class="headerlink" title="Parameterized type 을 instanceOf 로 비교할 수 없다"></a>Parameterized type 을 instanceOf 로 비교할 수 없다</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numberes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (numberes <span class="keyword">instanceof</span> ArrayList&lt;Integer&gt;) &#123; <span class="comment">// compile time error</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>타입소거의 특징으로 인해 위 코드는 컴파일 되지 않는다. 본래의 List 가 어떤 타입을 담고 있었는지 알 수 없으므로 위와 같은 코드가 무의미해지는 것이다. 예를들어 JVM 은 런타임에 ArrayList&lt;String&gt;, ArrayList&lt;Integer&gt; 를 구분하지 못한다. 하지만 방법이 아주 없는 것은 아니다. 제네릭 타입 중에 유일하게 타입소거가 되지않는 unbounded wildcard <strong>&lt;?&gt;</strong> 를 이용하면 된다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numberes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (numberes <span class="keyword">instanceof</span> ArrayList&lt;?&gt;) &#123; <span class="comment">// Ok</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Parameterized-type-array-를-만들-수-없다"><a href="#Parameterized-type-array-를-만들-수-없다" class="headerlink" title="Parameterized type array 를 만들 수 없다"></a>Parameterized type array 를 만들 수 없다</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] arrayOfTexts = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// compile time error</span></span><br></pre></td></tr></table></figure>

<p>위 코드는 컴파일되지 않는다. 만약 Array 를 만드는 것이 허용된다고 가정했을 때 어떤 문제가 있을지 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt;[] numbers = <span class="keyword">new</span> List&lt;Integer&gt;[<span class="number">10</span>]; </span><br><span class="line">Object[] objects = numbers;</span><br><span class="line"></span><br><span class="line">objects[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// OK</span></span><br><span class="line">objects[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// Exception 을 던져야하지만, 런타임에 인지할 수 없음.</span></span><br></pre></td></tr></table></figure>

<p>배열 초기화 과정부터 이상함을 느꼈을 수 있다. <strong>Array 는 Collection 과 다르게 기본적으로 Convariant 하다</strong>. 즉, A → B 이면 A[ ] → B[ ] 가 성립하기에 objects 를 numbers 로 초기화 하는 것이 가능하다!</p>
<p>그 후에 순차적으로 List&lt;Integer&gt;, List&lt;String&gt; 를 각 배열원소에 초기화하는데, Array 는 런타임에 일치하지 않는 타입이 들어오면 ArrayStoreException 이 발생하므로 List&lt;Integer&gt; 로 초기화 할 때 예외가 발생해야한다. 하지만 타입소거에 의해 각 List 는 런타임에 구별되지 않으므로 예외가 발생하지 않고 초기화가 진행될 것이다. 즉, 타입이 구별되지 않아 배열의 기본동작 규칙이 깨지게 되는 것이다.<br>이러한 이유로 인해 Parameterized type array 생성은 허용되지 않는다.</p>
<h2 id="type-parameter-의-구분으로-메소드를-overload-할-수-없다"><a href="#type-parameter-의-구분으로-메소드를-overload-할-수-없다" class="headerlink" title="type parameter 의 구분으로 메소드를 overload 할 수 없다"></a>type parameter 의 구분으로 메소드를 overload 할 수 없다</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;String&gt; texts)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자바로 처음 개발을 하면 제법 많이 겪어봤을 케이스이다. 위 코드에서 execute 메소드는 오버로딩 될 수 없다. 타입 소거 과정이 끝나면 모두 List 타입으로 변경되어 똑같은 메소드 시그니쳐를 가지게 되기 때문이다.</p>
<h1 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h1><p>제네릭이 선언된 대부분의 클래스들이 특정 알파벳만 사용되기 때문에 이것이 문법적으로 강제되는 부분이라고 착각할 수 있지만 실제로는 어떠한 이름을 지어도 상관이 없다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &lt;<span class="title">SUPERGENERIC</span>&gt; </span>&#123; &#125; <span class="comment">// 이렇게 지어도 잘돌아간다.</span></span><br></pre></td></tr></table></figure>

<p>다만 표준으로 사용을 권장하는 알파벳들이 있을 뿐이다. 협업의 관점에서 중요한 포인트 이므로 특별한 이유가 없다면 표준을 따르는 것이 좋다. <a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" target="_blank" rel="noopener">가이드</a></p>
<ul>
<li>안드로이드의 Adapater 클래스의 시그니쳐를 보면 제네릭의 의미를 강조하기 위해 표준 표기가 아닌 이름을 사용하기도 했다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>&lt;<span class="title">VH</span> <span class="keyword">extends</span> <span class="title">ViewHolder</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/generics/</a><br><a href="https://dzone.com/articles/5-things-you-should-know-about-java-generics" target="_blank" rel="noopener">https://dzone.com/articles/5-things-you-should-know-about-java-generics</a></p>
<p><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></p>
<p><a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Subtyping</a></p>
<p><a href="https://jojoldu.tistory.com/25" target="_blank" rel="noopener">https://jojoldu.tistory.com/25</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>IoC, DI, DIP 개념 잡기</title>
    <url>/2020/07/03/about_ioc_dip_di/</url>
    <content><![CDATA[<p>IoC, DIP, DI 는 항상 혼동되는 개념이다. 각 개념을 서로 같다고 표현하는 글들도 제법 있고, 각 개념의 정의를 살펴보니 직관적으로 이해가 되지 않았다. 요즘 특히 DI 에 대한 내용이 많이 언급되고 있다고 느끼는데 정작 주장하는 문맥이 조금씩 다르다보니 스스로 답답함을 느꼈다. 제대로된 논의를 하기 위해서는 올바른 개념 정리가 필요하다고 생각되어 각 개념에 대한 정보를 모으고 정리했다. </p>
<h1 id="무엇이-다를까"><a href="#무엇이-다를까" class="headerlink" title="무엇이 다를까?"></a>무엇이 다를까?</h1><blockquote>
<p>To be sure, using DI or IoC with DIP tends to be more expressive, powerful and domain-aligned, but they are about different dimensions, or forces, in an overall problem. DI is about wiring, IoC is about direction, and DIP is about shape.</p>
</blockquote>
<p>결론부터 얘기하면 IoC, DIP, DI 는 모두 다른 개념이다. 각자 목적과 요구하는 바가 다르다. 하지만 서로를 배척하는 개념은 아니다. 오히려 함께 했을 때 강한 시너지가 생긴다.</p>
<h1 id="Inversion-of-Control-IoC-제어의-역전"><a href="#Inversion-of-Control-IoC-제어의-역전" class="headerlink" title="Inversion of Control (IoC, 제어의 역전)"></a>Inversion of Control (IoC, 제어의 역전)</h1><blockquote>
<p>don’t call me, I’ll call you. - <a href="https://en.wiktionary.org/wiki/Hollywood_principle" target="_blank" rel="noopener">Hollywood principle</a></p>
</blockquote>
<p>개인적으로 IoC 를 가장 직관적으로 잘 설명한 문장이라고 생각한다.</p>
<p>좀 더 개발 친화적인 용어로 풀어서 설명하면 다음과 같이 표현할 수 있다. </p>
<blockquote>
<p>IoC 란 코드의 흐름을 제어하는 주체가 바뀌는 것이다.</p>
</blockquote>
<p>코드의 흐름을 제어한다는 것은 여러 행위를 포함한다. 오브젝트를 생성하는 것, 오브젝트의 생명주기를 관리하는 것, 메소드를 수행하는 것 등. 그리고 일반적인 프로그램은 이러한 행위를 하나부터 열까지 모두 스스로 수행한다. (우리가 처음 만들었던 프로그램을 잘 생각해보자.) IoC 를 적용한다는 것은 이러한 흐름 제어를 또다른 제 3자가 수행한다는 것을 의미한다.</p>
<p>안드로이드에서도 IoC 가 적용된 케이스를 볼 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>우리가 Activity 코드를 작성할 때 생명주기 메소드가 호출되었을 때의 동작만 정의하고, <strong>언제 생명주기 메소드를 호출 할지는 신경쓰지 않는다</strong>. 즉, Activity 의 메인 흐름 제어권은 나의 코드가 아니라 안드로이드 플랫폼에서 쥐고 있다.</p>
<p>누가 물어봤을 때 명확한 답변을 못했던 ‘프레임 워크와 라이브러리의 차이는 무엇인가?’ 에 대해 IoC 관점으로 설명이 가능하다. 라이브러리는 내 코드가 라이브러리를 이용한다. 즉, 제어권이 내 코드에 있다. 반면 프레임 워크는 프레임 워크가 나의 코드를 실행한다. 즉, 제어권은 프레임워크에게 있다.</p>
<blockquote>
<p>Software frameworks, callbacks, schedulers, event loops, dependency injection, and the template method are examples of design patterns that follow the inversion of control principle</p>
</blockquote>
<p>IoC 를 따르는 개념이 생각보다 많았다.</p>
<h1 id="Dependency-Inversion-principle-DIP-의존관계-역전-법칙"><a href="#Dependency-Inversion-principle-DIP-의존관계-역전-법칙" class="headerlink" title="Dependency Inversion principle (DIP, 의존관계 역전 법칙)"></a>Dependency Inversion principle (DIP, 의존관계 역전 법칙)</h1><blockquote>
<p>a.  High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g. interfaces).<br>b. Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p>
</blockquote>
<p>SOLID 원칙 중 하나이다. 의존관계에 대해 다루고 있는데 한번에 바로 이해될 수 있는 설명이 아니었다. 관련된 내용을 찾아보다가 좀 더 직관적으로 표현된 문장을 발견했다.</p>
<blockquote>
<p>DIP is about the level of the abstraction in the messages sent from your code to the thing it is calling</p>
</blockquote>
<p>DIP 가 주장하는 바의 핵심은 추상화에 의존하라는 것이다. </p>
<p>추상화가 아닌 구체클래스에 의존한 경우를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> TextFileParser textFileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TextFile 이 아닌 csv 파일을 파싱해야할 경우 필연적으로 코드의 변경이 발생</span></span><br><span class="line">        <span class="keyword">this</span>.textFileParser = <span class="keyword">new</span> TextFileParser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parseFile</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> textFileParser.parse(serializedFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 TextFileParser 에 변경이 발생했을 때 이를 의존하는 FileLoader 역시 변경이 발생하게 된다. 또한 FileLoader 는 TextFile 외에 다른 File 을 파싱하기 위해서는 아예 Parser 클래스를 변경해야한다. 변경에 유연하지 않은 구조이다.</p>
<p>추상화에 의존할 경우를 살펴보자</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileParser</span> </span>&#123;</span><br><span class="line">    <span class="function">File <span class="title">parse</span><span class="params">(String serializedFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFileParser</span> <span class="keyword">implements</span> <span class="title">FileParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parse</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">        <span class="keyword">return</span> File();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileParser fileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLoader</span><span class="params">(FileParser fileParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileParser = fileParser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parseFile</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileParser.parse(serializedFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileLoader 는 FileParser 인터페이스에 의존하기에 FileParser 의 구현체인 TextFileParser 변경이 발생하더라도 영향을 받지 않는다. 또한 FileParser 인터페이스를 구현한 구현체라면 무엇이든 FileLoader 에서 이용이 가능하다. 즉, 다형성을 활용하여 변경에 유연한 구조가 된다. </p>
<h1 id="Dependency-Injection-DI-의존성-주입"><a href="#Dependency-Injection-DI-의존성-주입" class="headerlink" title="Dependency Injection (DI, 의존성 주입)"></a>Dependency Injection (DI, 의존성 주입)</h1><blockquote>
<p>DI is about how one object acquires a dependency</p>
</blockquote>
<p>DI 는 필요로 하는 오브젝트를 스스로 생성하는 것이 아닌 외부로 부터 주입받는 기법을 의미한다. 마틴 파울러의 글에 따르면 3가지 타입으로 정의할 수 있다.</p>
<h2 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h2><p>생성자를 통해 주입하는 방식이다. 인스턴스가 생성되었을 때 의존성이 존재하는 것이 보장되기 때문에 의존성의 존재여부가 보장되고 의존성을 immutable 하게 정의할 수 있다. <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-setter-injection" target="_blank" rel="noopener">스프링</a>에서도 해당 방식을 권장하는 것으로 알고 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileParser fileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIilLoader</span><span class="params">(FileParser fileParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileParser = fileParser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection"></a>Setter Injection</h2><p>Setter 메소드를 이용하여 주입하는 방식이다. 해당 방식은 Construcor Injection 보다 좀 더 주의를 요한다. 주입 받는 의존성의 기본값을 정의할 수 있지 않다면 null 값이 존재할 수 있는 이슈가 있기 때문이다. 의존성이 다시 주입되어야할 경우 유용하게 사용된다고 하나 나는 아직 그러한 상황을 겪지 못했고 모두 Construcor Injection 으로 해결할 수 있었다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileParser fileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFIilLoader</span><span class="params">(FileParser fileParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileParser = fileParser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interface-Injection"><a href="#Interface-Injection" class="headerlink" title="Interface Injection"></a>Interface Injection</h2><p>Interface 로 주입받는 메소드를 정의한다. 이 방식은 이번에 조사하면서 처음 알게 되었고 실제로 사용해본 적이 없어 자세히 적기는 조심스럽다. 예시를 봐도 이점이 명확하게 보이지 않아 좀 더 공부를 하고 내용을 채워보려 한다.</p>
<h1 id="각-개념-간의-관계"><a href="#각-개념-간의-관계" class="headerlink" title="각 개념 간의 관계"></a>각 개념 간의 관계</h1><h2 id="IoC-와-DI"><a href="#IoC-와-DI" class="headerlink" title="IoC 와 DI"></a>IoC 와 DI</h2><p>종종 IoC 와 Dependency Injection 은 서로 interchangeably 한 것, 더 나아가 아예 같은 것처럼 표현하는 글이 보이곤 하는데 이는 잘못된 해석이라고 생각한다. Dependency Injection 은 IoC 개념이 적용된 결과물 중 하나일 뿐이다. 의존성을 주입한다는 것을 IoC 적인 행위로 바라볼 수 는 있지만 IoC 가 곧 의존성 주입이라고 보기 는 어렵기 때문이다.</p>
<h2 id="DIP-와-DI"><a href="#DIP-와-DI" class="headerlink" title="DIP 와 DI"></a>DIP 와 DI</h2><p>단어가 비슷해보이는 DIP 와 DI 역시 같은 개념으로 오해하기 쉽다. 하지만 마찬가지로 DI 는 DIP 를 구현하는 기법중 하나일 뿐 서로 같은 개념이 아니다. 위 DIP 예제 코드에서도 DI 가 이용되었다.</p>
<p>DIP 에 대한 이해가 부족했을 때, 아래와 같은 코드도 DIP 를 만족하는 것이라고 생각했었다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileParser</span> </span>&#123;</span><br><span class="line">    <span class="function">File <span class="title">parse</span><span class="params">(String serializedFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFileParser</span> <span class="keyword">implements</span> <span class="title">FileParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parse</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">        <span class="keyword">return</span> File();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileParser fileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileParser = <span class="keyword">new</span> TextFileParser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parseFile</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileParser.parse(serializedFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만 해당 코드에서는 FileParser 를 다른 구현체로 바꿀 수 없다. 사실상 타입만 인터페이스로 했을 뿐 다형성의 이점을 전혀 살리지 못하는 코드이며 DIP 를 만족한다고 보기 어렵다.</p>
<p>또 다른 예시를 살펴보자. 이 코드도 조금 아쉬운 점이 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextFileParser textFileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLoader</span><span class="params">(TextFileParser textFileParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.textFileParser = textFileParser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parseFile</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> textFileParser.parse(serializedFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 코드는 TextFileParser 를 주입 받으므로 DI 가 이루어졌다고 볼 수 있다. 따라서 TextFileParser 의 생성자에 변경이 생기더라도 FileLoader 에 전파되지 않는 것은 긍정적인 부분이다. 하지만 DIP 는 지켜지지 않았다. 구체 클래스에 의존하고 있으므로 다른 FileParser 로 교체하는 것은 불가능하며 TextFileParser 의 변경에 FileLoader 가 영향을 받게 된다.</p>
<p>위 예시들이 시사하는 바는 <strong>DIP 와 DI 는 서로 조합되었을 때 시너지를 발휘한다는 것</strong>이다. 그래서 보통 한쪽 개념의 예시를 들 때 다른 쪽 개념이 같이 적용되어 있기 때문에 두 개념을 같다고 이해 할 법도 하다.</p>
<h1 id="개념의-본질을-이해-착각하지-말기"><a href="#개념의-본질을-이해-착각하지-말기" class="headerlink" title="개념의 본질을 이해, 착각하지 말기"></a>개념의 본질을 이해, 착각하지 말기</h1><p>이러한 개념들을 정리하고 나면 내가 좀 더 개발을 잘하게 되었다는 착각에 종종 빠지곤 한다. 개념은 개념일 뿐이다. 커뮤니케이션 과정에서 리소스를 줄여주고 코드 그것이 곧 개발력과는 연결되지 않는 다고 본다. 중요한 것은 각 개념 속에서 추구하는 본질이 무엇인지 깨닫는 것이다. </p>
<p>한편으로는 이러한 개념들에 대해 정확히 정리하고 이해하는 과정은 꼭 필요하다. 내가 당장 이러한 것들을 지키지 못하더라도 어떤것이 충족되지 않는지 인식하고, 고쳐나갈 수 있는 기준을 세울 수 있기 때문이다. 무엇을 모르는지 모르는 것과 무엇을 모르는지 아는 것의 차이는 매우 크다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://justhackem.wordpress.com/2016/05/14/inversion-of-control/" target="_blank" rel="noopener">https://justhackem.wordpress.com/2016/05/14/inversion-of-control/</a><br><a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">https://www.martinfowler.com/articles/injection.html</a></p>
<p><a href="https://martinfowler.com/articles/dipInTheWild.html" target="_blank" rel="noopener">https://martinfowler.com/articles/dipInTheWild.html</a><br><a href="https://dzone.com/articles/ioc-vs-di" target="_blank" rel="noopener">https://dzone.com/articles/ioc-vs-di</a></p>
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans</a><br><a href="https://www.codeproject.com/Articles/592372/Dependency-Injection-DI-vs-Inversion-of-Control-IO" target="_blank" rel="noopener">https://www.codeproject.com/Articles/592372/Dependency-Injection-DI-vs-Inversion-of-Control-IO</a></p>
<p><a href="https://medium.com/@ivorobioff/dependency-injection-vs-service-locator-2bb8484c2e20" target="_blank" rel="noopener">https://medium.com/@ivorobioff/dependency-injection-vs-service-locator-2bb8484c2e20</a></p>
]]></content>
  </entry>
  <entry>
    <title>[안드로이드] ViewModel 에 대한 고찰 : public 메소드</title>
    <url>/2020/06/07/viewmodel_public_method/</url>
    <content><![CDATA[<p>MVVM 기반으로 프로젝트를 진행할 때 팀 내에서 가장 많은 논의가 오고 갔던 부분은 역시 ViewModel 이었다. 이번 글은 그 중 ViewModel 의 public 메소드에 대하여  적어보려 한다.</p>
<h1 id="종류-및-구현-방식"><a href="#종류-및-구현-방식" class="headerlink" title="종류 및 구현 방식"></a>종류 및 구현 방식</h1><p>ViewModel 은 보통 세 종류의 public 메소드를 제공한다.</p>
<ol>
<li>View 가 원하는 명령을 수행하기 위한 트리거형 메소드</li>
<li>LiveData 등의 이벤트 옵저버 Getter</li>
<li>특정 값 Getter (되도록 지양!)</li>
</ol>
<p>2개는 Getter 이므로 크게 논의할만한 부분이 없고, 첫 번째인 트리거형 메소드에 대해 다룰 것이다.</p>
<h1 id="초기-구현-방식과-문제점"><a href="#초기-구현-방식과-문제점" class="headerlink" title="초기 구현 방식과 문제점"></a>초기 구현 방식과 문제점</h1><p>초기 MVVM 패턴을 적용하여 화면을 만들 때 다음과 같이 구현하였다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">				...        </span><br><span class="line">        mUserCategoryViewModel.loadUserCategory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeClickListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDeleteAllButton.setOnClickListener(view -&gt; mUserCategoryViewModel.deleteAllCategory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadUserCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// Call API</span></span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAllCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Delete all</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h2><p>위 구현은 ViewModel 이 비즈니스 로직을 수행할 수 있는 메소드를 public 하게 제공하고 있고, 이를 View 가 직접 호출하고 있는 형태이다. 이는 곧 다음과 같은 문제점에 직면하게 된다.</p>
<ul>
<li><p>View 가 비즈니스 로직 진행 과정을 알고 있어야 함을 의미한다.</p>
<p>  → 예를 들어 위 예제 코드에서 전체 삭제 버튼을 눌렀을 때, 전체 삭제 외에 추가적인 과정이 수행되야 하는 스펙이 추가 되는 것을 가정 해보자. 이는 곧 View 에서 신규 스펙과 관련된 viewModel 의 메소드를 추가로 호출해줘야 함을 의미한다. 즉, ViewModel 레벨의 변경사항이 View 에 영향을 끼친다. (기존의 deleteAllCategory 메소드에 신규 스펙의 내용을 구현하는 것은 SRP 규칙에 위배된다.)</p>
</li>
<li><p>해당 화면의 컨텍스트를 모르는 개발자는 전체적인 흐름을 파악하기 위해 View, ViewModel 모두를 확인해야만 한다.</p>
</li>
</ul>
<h1 id="개선안"><a href="#개선안" class="headerlink" title="개선안"></a>개선안</h1><p>코드를 먼저 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">				...        </span><br><span class="line">        mUserCategoryViewModel.onEnterView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeClickListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDeleteAllButton.setOnClickListener(view -&gt; mUserCategoryViewModel.deleteAllCategory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnterView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				loadUserCategory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickDeleteAllButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				deleteAllCategory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUserCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// Call API</span></span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteAllCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Delete all</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>초기 구현 대비 바뀐 것은 2가지이다.</p>
<p><strong>1. ViewModel 은 내부 비즈니스 로직을 직접 수행할 수 있는 메소드를 public 하게 제공하지 않는다.</strong></p>
<p>기존 메소드의 접근제한자를 private 로 변경하였다. 이제 View 는 더이상 비즈니스 로직을 수행하는 메소드를 직접 호출할 수 없다. </p>
<p><strong>2. ViewModel 의 public 메소드는 View 레벨의 특정한 이벤트를 지칭하는 네이밍을 가진다.</strong></p>
<p>View 가 ViewModel 에게 명령할 트리거 메소드는 여전히 필요하기에 새로운 트리거 메소드를 생성하였다. 해당 메소드는 View 의 특정 이벤트가 발생 했음을 나타내는 네이밍을 가진다. 또한 기존의 비즈니스 로직 메소드를 내부에서 수행한다. 이러한 변경사항은 다음과 같은 이점을 가진다.</p>
<ul>
<li>View 는 더이상 내부 비즈니스 로직의 수행 과정을 알 필요가 없다. 단지 View 이벤트가 발생했다고 ViewModel 에 전달 해주면 된다.</li>
<li>ViewModel 의 비즈니스 로직에 추가 스펙이 들어오더라도 View 에 전파되지 않는다.</li>
<li>해당 화면의 컨텍스트를 모르는 개발자가 코드를 보더라도 비즈니스 로직이 한곳에 모여있으므로 파악이 용이하다.<br>ex) 전체 삭제 버튼이 눌렸을 때 수행 되는 일이 궁금하다면 onClickDeleteAllButton 메소드의 구현 내용만 확인하면 된다!</li>
</ul>
<p>위 변경사항을 통해 ViewModel 을 한단계 더 캡슐화하는 효과를 얻게 되었다.</p>
<h1 id="효과"><a href="#효과" class="headerlink" title="효과"></a>효과</h1><p>유저로 부터 리포트되는 이슈의 상당수는 ‘XXX 를 클릭했을 때 안돼요.’ 와 같이 특정 View 이벤트와 관련된 내용이 많다. 개선된 내용을 적용하고 난 후에는 해당 화면에 속한 ViewModel 의 트리거 메소드만 확인하면 바로 관련된 비즈니스 로직을 파악할 수 있기 때문에 개발 능률이 향상되는 효과를 얻었다.</p>
<p>더 변경하기 쉽고, 이해하기 쉬운 코드를 위한 여정은 계속된다.  🤟</p>
]]></content>
  </entry>
  <entry>
    <title>[안드로이드] Repository 패턴에 대한 고찰</title>
    <url>/2020/05/24/android_repository_pattern/</url>
    <content><![CDATA[<p><a href="https://developer.android.com/jetpack/docs/guide?hl=ko#overview" target="_blank" rel="noopener">공식 문서</a>에서도 가이드 하는 것 처럼 이제 Android 아키텍처를 구성할 때 Repository 패턴은 기본적으로 사용 되고있다. 오늘은 Repository 패턴에 대한 간단한 정리와 사용하면서 내가 놓치고 있었던 점에 대하여 정리 해보려한다.</p>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul>
<li>Repository 패턴의 궁극적인 목적은 결국 관심사의 분리다.</li>
<li>DataSource 외에 data 에 대한 분리도 필요하다.</li>
</ul>
<h1 id="Repository-패턴을-사용하는-이유"><a href="#Repository-패턴을-사용하는-이유" class="headerlink" title="Repository 패턴을 사용하는 이유"></a>Repository 패턴을 사용하는 이유</h1><blockquote>
<p>Repositories are classes or components that encapsulate the logic required to access data sources.</p>
</blockquote>
<p>Repository 는 DataSource 를 캡슐화 한다. 이점은 다음과 같다.</p>
<ul>
<li>하나의 도메인을 표현하는데 필요한 DataSource 가 몇 개든 client 쪽에서는 이를 알 필요가 없다.<ul>
<li>따라서 DataSource 를 새롭게 추가하는 것도 부담이 없다.</li>
</ul>
</li>
<li>DataSource 의 변경이 발생하더라도 repository 외부 layer 로 전파되지 않는다.</li>
<li>client 는 repository 인터페이스에 의존하기 때문에 테스트 하기 용이하다.</li>
</ul>
<p>결국 repository 는 presentation layer 와 data layer 의 coupling 을 느슨하게 만들어준다.</p>
<h1 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h1><p>Andorid 진영에서는 아래 구조를 크게 벗어나지 않는다.</p>
<p>View → Presenter / ViewModel → <strong>Repository</strong> → DataSource (API, Local DB)</p>
<p><strong>ViewModel</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInformationViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickUserInfoButton</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        mUserRepository.getUser(userId)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(</span><br><span class="line">                        user -&gt; &#123;</span><br><span class="line">                            <span class="comment">///</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        error -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Repository</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Single&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userApi.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="놓치고-있었던-점"><a href="#놓치고-있었던-점" class="headerlink" title="놓치고 있었던 점"></a>놓치고 있었던 점</h1><p>Repository 패턴 자체는 적용이 어렵지 않다. 하지만 많은 사람들이 놓치고 있는 부분이 있는데, 위 예시에서도 찾을 수 있다.</p>
<p>바로 <strong>Repository 가 DataSource 의 데이터를 그대로 전달</strong>해준다는 점이다.</p>
<p>위 예시를 다시한번 살펴보자. UserRepository 는 UserApi 로 부터 전달받은 User 를 별다른 처리없이 그대로 리턴하고 이를 presentation layer 에서 사용하고 있다.</p>
<p>이것은 다음과 같은 문제점을 가지고 있다.</p>
<ul>
<li>back 단의 구현 이슈가 presentation layer 에 영향을 끼칠 수 있다.</li>
<li>User 는 서버 (혹은 로컬 DB) 의 데이터베이스 테이블을 표현하는 역할을 수행하는 객체일 뿐이다.</li>
</ul>
<h2 id="Data-스펙이-바뀌면-presentation-layer-전반에-영향-끼치게-된다"><a href="#Data-스펙이-바뀌면-presentation-layer-전반에-영향-끼치게-된다" class="headerlink" title="Data 스펙이 바뀌면 presentation layer 전반에 영향 끼치게 된다."></a>Data 스펙이 바뀌면 presentation layer 전반에 영향 끼치게 된다.</h2><p>필드 삭제, 필드 이름 변경 등 서버가 데이터 구조를 변경하게 되면 이를 바로 참조하고 있는 다른 layer 에서도 필연적으로 변경이 발생하게 된다. </p>
<p>예를 들어 클라쪽에서는 User 정보를 표기해야 하는데 서버에서 각기 다른 데이터의 요청을 N 번 거쳐야 한다고 생각해보자. 그럼 N 개의 데이터에 대한 변경 사항은 모두 온전히 클라에 영향을 줄 것이다. 더 중요한 점은 이렇게 복잡한 데이터 모델을 혼재하여 사용하게 되면 다른 개발자가 컨텍스트를 이해하기 매우 어려워지기 시작한다.</p>
<h2 id="서버-혹은-로컬-DB-의-데이터베이스-테이블을-표현하는-역할을-수행하는-객체일-뿐이다"><a href="#서버-혹은-로컬-DB-의-데이터베이스-테이블을-표현하는-역할을-수행하는-객체일-뿐이다" class="headerlink" title="서버 (혹은 로컬 DB) 의 데이터베이스 테이블을 표현하는 역할을 수행하는 객체일 뿐이다."></a>서버 (혹은 로컬 DB) 의 데이터베이스 테이블을 표현하는 역할을 수행하는 객체일 뿐이다.</h2><p>같은 도메인에 대하여 클라와 서버의 용어가 통일이 되는 것이 가장 이상적이겠지만 현실세계에서는 서로 다른 용어를 사용하는 경우가 허다하다. 그럴 경우 보통은 클라이언트 코드 베이스에서 라도 서로 통일이 이루어져야 한다. 그런데 서버 데이터 구조를 그대로 가져와 사용할 경우, 팀내 도메인 용어와 실제 코드 베이스의 용어가 달라지게 되고 커뮤니케이션 리소스가 급증하게 되는 상황이 발생한다.</p>
<p>또한 도메인의 비즈니스 로직 처리에 필요한 메소드를 생성할 시점이 왔을 때, (서버 테이블을 반영한) 객체에 추가하게 되면 해당 객체는 테이블도 표현하고, 도메인 로직도 처리하는 <a href="https://en.wikipedia.org/wiki/God_object" target="_blank" rel="noopener">God object</a> 가 될 확률이 높다.</p>
<h3 id="한번쯤-만들어-봤을-법한-클래스"><a href="#한번쯤-만들어-봤을-법한-클래스" class="headerlink" title="한번쯤 만들어 봤을 법한 클래스.."></a>한번쯤 만들어 봤을 법한 클래스..</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"id"</span>)               </span><br><span class="line">    <span class="keyword">private</span> String id;                </span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"nickname"</span>)               </span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"grade"</span>)               </span><br><span class="line">    <span class="keyword">private</span> String grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Grade.MANAGER == Grade.find(grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Repository 패턴을 사용하는 목적은 data layer 와의 coupling 을 느슨하게 하는 것인데, 다시 강한 결합이 되어버린 꼴이 되었다.</p>
<h2 id="Mapper-를-활용하자"><a href="#Mapper-를-활용하자" class="headerlink" title="Mapper 를 활용하자"></a>Mapper 를 활용하자</h2><p>이러한 문제점을 해결하기 위하여 Mapper 를 사용할 수 있다. Mapper 란 말 그대로 테이블 객체 ↔ 도메인 모델 객체간의 mapping 을 시켜주는 유틸성 클래스를 의미한다. repository 내에서 mapper 를 활용하여 테이블 객체가 아닌 도메인 모델로 전달을 해주면 presentation layer 는 data layer 로 부터 진정한 자유를 찾을 수 있게 된다.<br><strong>Repository</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Single&lt;UserDomain&gt; <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userApi.getUser(userId).map(UserMapper::fromTable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Mapper</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDomain <span class="title">fromTable</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDomain(user.id, user.name, user.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 모든 모델에 대하여 보일러 플레이트 코드 처럼 Mapper 클래스를 만드는 것이 싫다면 <a href="https://github.com/modelmapper/modelmapper" target="_blank" rel="noopener">라이브러리</a> 를 활용해보는 것도 좋은 대안이다.</p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>다양한 아키텍처, 패턴을 공부하다 보면 결국 변경하기 쉬운 구조를 만들기 위한 여러 시도들이라고 생각된다. 단순히 패턴의 단면만을 보고 큰 고민없이 사용하는 것이 아니라 그속에 담겨있는 핵심을 잘 이해하고 사용하는 것이 중요하다는 것을 다시금 깨닫게 된다.</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref :"></a>Ref :</h2><ul>
<li><p><a href="https://academy.realm.io/kr/posts/clean-architecture-in-android" target="_blank" rel="noopener">https://academy.realm.io/kr/posts/clean-architecture-in-android</a></p>
</li>
<li><p><a href="https://proandroiddev.com/the-real-repository-pattern-in-android-efba8662b754" target="_blank" rel="noopener">https://proandroiddev.com/the-real-repository-pattern-in-android-efba8662b754</a></p>
</li>
<li><p><a href="https://medium.com/corebuild-software/android-repository-pattern-using-rx-room-bac6c65d7385" target="_blank" rel="noopener">https://medium.com/corebuild-software/android-repository-pattern-using-rx-room-bac6c65d7385</a></p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design</a></p>
</li>
<li><p><a href="https://medium.com/@soleilstudio/object-mapping-in-android-f56935917c61" target="_blank" rel="noopener">https://medium.com/@soleilstudio/object-mapping-in-android-f56935917c61</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>DesignPattern</tag>
      </tags>
  </entry>
  <entry>
    <title>NextStep 리뷰어 활동을 마무리 하며</title>
    <url>/2020/04/25/nextstep_reviewer_review/</url>
    <content><![CDATA[<p>작년 하반기에 Nextstep 의 <a href="https://vagabond95.me/2019/11/23/nextstep-class-review/">클린코드 교육과정을 참여</a>하며 배웠던 내용을 바탕으로 많은 성장을 할 수 있었다. 좋은 수업이라며 주위에 열심히 홍보를 하던 찰나, 과정을 직접 운영하고 계시는 박재성님으로부터 코드 리뷰어 활동을 제안 받게 되었다. </p>
<p>코드 리뷰어로 활동할 수 있는 실력이 안될 것 같아 고민이 되었지만, 재성님의 격려와 좋은 경험을 쌓을 수 있는 기회라고 생각이 되어 제안을 수락하였다. </p>
<p>리뷰어 활동은 약 한달간 진행되었고 그 과정속에서 깨달은 것이 많아 개인적인 정리 및 기록 차원에서 글을 남긴다.</p>
<h1 id="코드-리뷰를-진행하며"><a href="#코드-리뷰를-진행하며" class="headerlink" title="코드 리뷰를 진행하며"></a>코드 리뷰를 진행하며</h1><p>처음 리뷰를 진행할 때는 생각 이상으로 많은 시간과 에너지가 소모되었다. 회사 업무를 마치고 또 코드를 봐야하는 압박감도 있었고, 각자 다른 스타일의 코드를 꼼꼼히 확인 하고 적절한 피드백이 무엇일지 고민하고 공부해야했기 때문이다. 또한 리뷰를 마쳐야 리뷰이가 다음 단계를 진행하기 수월하기 때문에 코드가 올라오는데로 최대한 빠르게 피드백을 줄 수 있도록 신경을 써야했다. 따라서 초반에는 시간적 여유가 별로 없다보니 특별한 체계없이 정해진 리뷰의 양을 채워나갔던 것 같다.<br>점점 시간이 흐를 수록 나름의 체계가 생기고 속도가 붙어 초반보단 여유가 생겼다. 이때 나 스스로의 리뷰 방식/관점에 대해 점검해보며 아래과 같은 기준을 세우고 리뷰를 진행했다. </p>
<h2 id="1-모호한-지식은-모호한-답변을-남긴다"><a href="#1-모호한-지식은-모호한-답변을-남긴다" class="headerlink" title="1. 모호한 지식은 모호한 답변을 남긴다."></a>1. 모호한 지식은 모호한 답변을 남긴다.</h2><p>특정 내용에 대하여 피드백을 할 때마다 굉장히 모호하게 답변을 남기고 있는 것을 깨달았다. 해당 내용에 대한 정확한 지식이 없다는 신호라고 느꼈다. 이런 수준에서는 좋은 피드백을 줄 수 없을 것 같아 잠시 리뷰를 중단했다. 이후 책과 검색을 통해 좀 더 깊게 공부하고 부족해 보이는 부분을 채워나갔다. 내가 어떤 주제에 대하여 막연히만 알고 있었는지 깨닫는 좋은 순간이었다. 어느정도 정리 및 공부가 끝났다고 생각되면 다시 리뷰를 진행했고 이후에도 비슷한 주제가 나올 경우 위와 같은 과정을 반복하였다.</p>
<h2 id="2-모든-코드에는-근거가-있어야한다"><a href="#2-모든-코드에는-근거가-있어야한다" class="headerlink" title="2. 모든 코드에는 근거가 있어야한다."></a>2. 모든 코드에는 근거가 있어야한다.</h2><p>리뷰를 진행하다보면 특정 상황에서 관습적으로 굳어진듯한 구현을 발견할때가 있다. 이러한 코드를 발견하면 피드백을 남길 때 집요하게😈어떤 구현 의도를 가지고 작성했는지 물어보곤 했다.<br>관습적인 구현은 대게 큰 고민 없이 이루어지는 경우가 많다. 하지만 모든 코드는 명확한 근거가 있어야한다고 생각한다. 만약 스스로 세운 근거가 틀리더라도 큰 상관이 없다. 나중에 잘못된 방향임을 깨닫더라도 어떤 부분을 놓쳤는지 비교가 가능하기 때문이다. 특히 나같은 경우 스스로 세운 근거가 틀렸음을 깨달았을 때 더 많이 성장하는 것을 경험했기 때문에 이 부분을 특히 집중했다. </p>
<h2 id="3-나의-피드백보다-더-좋은-방향은-항상-있을-수-있다"><a href="#3-나의-피드백보다-더-좋은-방향은-항상-있을-수-있다" class="headerlink" title="3. 나의 피드백보다 더 좋은 방향은 항상 있을 수 있다."></a>3. 나의 피드백보다 더 좋은 방향은 항상 있을 수 있다.</h2><p>미션의 요구사항이 간단할 때는 리뷰이의 구현 방향이 대부분 비슷하게 수렴하고 이에 대한 베스트 케이스도 어느정도 정해져있다. 그래서 피드백으로 가이드를 남기는 것도 비교적 수월하다. 그러나 점점 미션의 요구사항이 복잡하고 어려워질 수록 다양한 접근 방식이 나타나기 시작한다. 이때 나 또한 결국 가지고 있는 지식과 경험 내에서 답변할 수 밖에 없는 한계점이 있기 때문에 항상 내가 남긴 피드백보다 더 좋은 방향이 있을 수 있다는 마음가짐으로 리뷰에 임했다.<br>실제로 다양한 방식으로 풀 수 있는 부분에 대하여 피드백을 남기면 리뷰이에게 종종 문의가 들어왔다. 이때 나는 피드백을 남긴 의도를 최대한 자세히 남겼다. 그리고 리뷰이의 의도 역시 물어본 후 각각 비교하여 장/단점을 생각해보고, 목표를 이루기 위해서 무엇을 취할 수 있을지/버려야할 지 논의했다. 이러한 과정 또한 나의 생각을 정리하고 공부하는 계기가 되어 오히려 내가 스스로 많이 배울 수 있는 좋은 거름이 되었다. 👏</p>
<p><img src="/images/next_step_reviewer.png" alt><br>(기억에 남았던 논의 과정, 지금 다시 보니 답변 내용 중 아쉬운 부분이 보인다. 😭)</p>
<h1 id="코드리뷰도-결국은"><a href="#코드리뷰도-결국은" class="headerlink" title="코드리뷰도 결국은.."></a>코드리뷰도 결국은..</h1><p>코드 리뷰도 결국은 <strong>사람과의 커뮤니케이션</strong>이다. 또한 사람은 각기 다른 커뮤니케이션 스타일을 가지고 있다. 그래서 소프트 스킬이 어렵다고 생각한다. 논의를 주고 받다보면 각 리뷰이분의 스타일을 대략적으로 파악하고, 이에 맞게 커뮤니케이션 방식을 조금씩 바꿔가며 진행해보려 노력했다.<br>소프트 스킬을 연습할 수 있는 기회는 흔치 않다고 생각되어 이부분에 대해 적지 않게 신경썼던 기억이 난다.</p>
<h1 id="가장-많이-드렸던-피드백들"><a href="#가장-많이-드렸던-피드백들" class="headerlink" title="가장 많이 드렸던 피드백들"></a>가장 많이 드렸던 피드백들</h1><p>리뷰를 하다보면 공통으로 피드백을 많이 남기는 내용이 있었다. 정리를 해보니 다음과 같다.</p>
<h2 id="이-객체가-알아야할-정보가-맞을까요"><a href="#이-객체가-알아야할-정보가-맞을까요" class="headerlink" title="이 객체가 알아야할 정보가 맞을까요?"></a>이 객체가 알아야할 정보가 맞을까요?</h2><p> → 클래스가 존재해야할 이유는 하나이다. <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="noopener">SRP</a>를 잘 지켰는지  확인했다.</p>
<h2 id="이-코드는-다른-객체에서-스스로-수행할-수-있지-않을까요"><a href="#이-코드는-다른-객체에서-스스로-수행할-수-있지-않을까요" class="headerlink" title="이 코드는 다른 객체에서 스스로 수행할 수 있지 않을까요?"></a>이 코드는 다른 객체에서 스스로 수행할 수 있지 않을까요?</h2><p>→ 객체 상태를 꺼내와서 연산을 수행하지 말고 상태를 알고 있는 객체에 명령할 것, 객체의 응집도 측면에서 확인했다.</p>
<h2 id="이-메소드의-네이밍을-좀-더-구체적으로-지어볼-수-있을까요-좀-더-구현-내용을-숨겨볼-수-있을까요"><a href="#이-메소드의-네이밍을-좀-더-구체적으로-지어볼-수-있을까요-좀-더-구현-내용을-숨겨볼-수-있을까요" class="headerlink" title="이 메소드의 네이밍을 좀 더 구체적으로 지어볼 수 있을까요? / 좀 더 구현 내용을 숨겨볼 수 있을까요?"></a>이 메소드의 네이밍을 좀 더 구체적으로 지어볼 수 있을까요? / 좀 더 구현 내용을 숨겨볼 수 있을까요?</h2><p>→ 아마 리뷰이분들 입장에서는 가장 짜증나는(?) 피드백이지 않았을까.ㅎㅎ 어떤 메소드는 이름을 자세히 짓고, 어떤 메소드는 좀 더 추상적으로 지으라니..🤬🤬</p>
<p>나는 <strong>SRP</strong> 와 <strong>캡슐화</strong>의 관점에서 피드백을 진행했다.</p>
<h3 id="1-좀-더-구체적으로-지어볼-수-있을까요"><a href="#1-좀-더-구체적으로-지어볼-수-있을까요" class="headerlink" title="(1) 좀 더 구체적으로 지어볼 수 있을까요?"></a>(1) 좀 더 구체적으로 지어볼 수 있을까요?</h3><blockquote>
<p>메소드는 하나의 일만을 수행해야 한다. 그리고 수행하는 일을 드러낼 수 있다.</p>
</blockquote>
<p>위 규칙을 지킨다면 이름이 모호한 메소드는 수행하는 일이 명확히 드러나도록 표현할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user.get() <span class="comment">// (X) 수행하는 일이 명확히 나타나지 않는다. </span></span><br><span class="line">user.getName() <span class="comment">// (O) 무슨일을 수행하는지 알 수 있다.</span></span><br></pre></td></tr></table></figure>

<h3 id="2-좀-더-구현-내용을-숨겨볼-수-있을까요"><a href="#2-좀-더-구현-내용을-숨겨볼-수-있을까요" class="headerlink" title="(2) 좀 더 구현 내용을 숨겨볼 수 있을까요?"></a>(2) 좀 더 구현 내용을 숨겨볼 수 있을까요?</h3><blockquote>
<p>캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.</p>
</blockquote>
<p><a href="http://www.yes24.com/Product/Goods/74219491" target="_blank" rel="noopener">오브젝트</a>에서는 변경할 수 있는 모든 것을 캡슐화하라고 이야기 한다.<br>(관련 내용에 대하여 과거에 <a href="https://vagabond95.me/2019/10/20/object-book-4/">정리했던 글</a>이 있다.)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">winnerNumber.getRankWithAnotherNumber(number) <span class="comment">// (X) 전달되는 파라미터에 대한 정보가 드러난다.</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 메소드의 네이밍은 전달되는 인자에 대한 정보가 메소드에 그대로 드러나 있다. 파라미터가 드러나면 어느정도 가독성은 확보할 수 있을지도 모른다. 그러나 파라미터에 대한 <strong>변경</strong>은 꽤나 빈번하게 발생하는 일이며, 그때마다 해당 메소드의 이름은 변경되어야 할 것이다. 즉, 변경에 취약하다.</p>
<p>그렇다면 어디까지 추상화해야 할까? 메소드에서 변경되지 않는 것이 딱 하나 있다. 바로 메소드가 수행하는 일이다. 따라서 메소드가 수행하는 일만 드러내는 것이 변경에 좀 더 유연한 네이밍이라고 생각되어 피드백을 남겼었다. (1) 번 내용과도 같이 생각해볼만한 부분이다. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">winnerNumber.getRank(number) <span class="comment">// (O) 수행하는 일만을 명시한다.</span></span><br></pre></td></tr></table></figure>

<p>요 내용은 개인적으로 고민이 있는 부분이라 다른 의견도 들어보고 싶다. 🤔</p>
<h1 id="동시에-성장하는-경험"><a href="#동시에-성장하는-경험" class="headerlink" title="동시에 성장하는 경험"></a>동시에 성장하는 경험</h1><p>내가 알고 있는 지식을 누군가에게 설명해줄 때 가장 공부가 많이 되는 경험을 해본적이 있을 것이다. 코드 리뷰를 진행하면서 비슷한 경험을 했다. 내가 피드백을 제시하기 위해선 근거가 있어야하고 이를 위해서는 탄탄한 지식과 좋은 레퍼런스가 있어야 하기에 엄청나게 공부를 할 수 밖에 없다. 특히 날카로운 질문이 들어올 때, 질문의 주제가 내가 막연하게 알고 있는 내용일 경우 바로 바닥이 나타났기에 더욱 열심히 찾아보고 공부했다. 그래서 과정이 점점 진행될 수록 리뷰이와 내가 동시에 성장을 하는 것을 경험을 했다.</p>
<h1 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h1><p>엄청난 열정으로 구현을 진행하고 논의를 나눈 리뷰이분들, 자신의 리뷰과정을 공유하여 다양한 관점으로 볼 수 있게 해준 리뷰어분들, 중간중간 어려움이 있을 때마다 아낌없는 조언을 주신 재성님에게 다시 한번 감사드린다. 🙏<br>NextStep 에서는 클린코드 과정외에도 다양한 주제의 강의가 진행되고 있으니 관심이 있다면 <a href="https://edu.nextstep.camp/" target="_blank" rel="noopener">클릭</a>!</p>
]]></content>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] TextView 에서 ellipsize 가 적용되지 않는 이슈 with autoLink & movementMethod</title>
    <url>/2020/04/12/android_not_working_ellipsize_with_autolink_or_movementmethod/</url>
    <content><![CDATA[<p><img src="/images/cover/ellipsis_not_working_cover.jpeg" alt></p>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul>
<li>TextView 에서 autoLink 혹은 movemnetMethod 옵션을 사용할 경우 ellipsize 가 제대로 동작하지 않는다.</li>
<li>autoLink &amp; movementMethod 혹은 ellipsize 를 커스텀하게 구현해줄 필요가 있다.</li>
<li>API 27 기준의 TextView 로 조사를 진행하였다.</li>
</ul>
<h1 id="간단해-보이는-요구-사항-삽질의-시작"><a href="#간단해-보이는-요구-사항-삽질의-시작" class="headerlink" title="간단해 보이는 요구 사항, 삽질의 시작"></a>간단해 보이는 요구 사항, 삽질의 시작</h1><p>텍스트 박스의 요구사항은 다음과 같았다.</p>
<ol>
<li>내용은 최대 N 라인 까지만 노출 가능하다. 이후 내용은 말줄임 표시로 대체</li>
<li>내용 중 web url 이 있을 경우 클릭 및 스타일링이 되어야하고 클릭 시, 인앱 브라우저로 이동해야한다.</li>
</ol>
<p>1번 사항은 <a href="https://developer.android.com/reference/android/widget/TextView#attr_android:maxLines" target="_blank" rel="noopener">maxLine</a> 과 <a href="https://developer.android.com/reference/android/widget/TextView#attr_android:ellipsize" target="_blank" rel="noopener">ellipsize</a> 를 이용하면 된다.</p>
<p>2번 사항은 <a href="https://developer.android.com/reference/android/widget/TextView#attr_android:autoLink" target="_blank" rel="noopener">autoLink</a>, <a href="https://developer.android.com/reference/android/widget/TextView#attr_android:textColorLink" target="_blank" rel="noopener">textColorLink</a>, 커스텀한 MovemetMethod 를 이용하면 된다.</p>
<p>커스텀한 MoveMentmethod 가 필요한 이유는 TextView 에서 기본으로 사용되는 <a href="https://developer.android.com/reference/android/text/method/LinkMovementMethod" target="_blank" rel="noopener">LinkMovementMethod</a> 의 경우 특정한 link 텍스트 클릭 시, 이를 감지할 수 있는 콜백을 제공하지 않고 내부에서 ACTION_VIEW intent 로 처리하기 때문이다.<br>직접 구현하기가 부담스럽다면 이런 <a href="https://github.com/saket/Better-Link-Movement-Method" target="_blank" rel="noopener">라이브러리</a> 를 이용해도 좋다.</p>
<p>어쨌든 안드로이드에서 기본적으로 제공하고 있는 속성을 활용하면 금방 완료가 가능할 것으로 보고 구현을 시작했다.<br>그런데… 아무리 빌드를 돌려봐도 ellipsis 가 표현되지 않는다.</p>
<p>구글이 그럴리 없다며 내가 잘못한 부분이 없나 몇 시간째 삽질을 하다가, 결국 하나하나 옵션을 제거하면서 결과를 비교해봤고 다음과 같은 결론을 얻었다.</p>
<ul>
<li>autoLink 혹은 setAutoMask() 를 이용하여 autoMask 플래그를 set 해줬을 경우 ellipsize 가 제대로 동작하지 않는다.</li>
<li>movementMethod 를 set 해줬을 경우 ellipsize 가 제대로 동작하지 않는다.</li>
<li></li>
</ul>
<p>전혀 연관이 없을 것 같은 각 속성이 왜 충돌하는 것일까?</p>
<h1 id="setText-와-autoLink-movementMethod"><a href="#setText-와-autoLink-movementMethod" class="headerlink" title="setText() 와 autoLink / movementMethod"></a>setText() 와 autoLink / movementMethod</h1><p>TextView 에 내용을 전달하기 위해서는 반드시 setText() 를 거쳐야한다. setText() 메소드 내부에서 autoLink 값과 movementMethod 가 영향을 주고 있는 부분은 없을까하여  setText() 내부 구현을 조사해봤다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TextView.class</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == BufferType.SPANNABLE || mMovement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                text = mSpannableFactory.newSpannable(text);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    mText = text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAutoLinkMask != <span class="number">0</span>) &#123;</span><br><span class="line">                Spannable s2;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (type == BufferType.EDITABLE || text <span class="keyword">instanceof</span> Spannable) &#123;</span><br><span class="line">                    s2 = (Spannable) text;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s2 = mSpannableFactory.newSpannable(text);</span><br><span class="line">                &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    mText = s2;</span><br></pre></td></tr></table></figure>
<p>각 코드는 모두 text 를 Spannable 로 포장 해주고 있다. 이 부분을 잘 기억해 두자.</p>
<p>autolink 는 Link 에 해당하는 내용을 스타일링 해주고, movementMethod 는 link 를 클릭 했을 때 특별한 상호작용이 이루어져야 하므로 plain text 가 아닌 spannable 로 포장 해주는 것은 어느정도 납득이 간다. 그럼 이러한 특징이 ellipsize 에 어떤 영향을 줄까?</p>
<h1 id="ellipsize-적용-과정"><a href="#ellipsize-적용-과정" class="headerlink" title="ellipsize 적용 과정"></a>ellipsize 적용 과정</h1><p>TextView 에서 Ellipsize 과 관련된 몇가지 내용을 조사해봤다.</p>
<ol>
<li>TextView 의 설정이 같더라도 디스플레이 환경에 따라 실제 보이는 결과는 다를 수 있다. 그리고 실제 화면 상에 보이고 있는 TextView 에 대한 정보는 <a href="[https://developer.android.com/reference/android/text/Layout](https://developer.android.com/reference/android/text/Layout)">Layout</a> 에서 가져올 수 있다. (LinearLayout 과 같은 ViewGroup Layout 이 아니다!)</li>
</ol>
<p>따라서 ellisize 가 적용된 결과도 layout 을 통하여 가져와야 한다.</p>
<ol start="2">
<li>TextVeiw 내부에서 Layout 을 생성하는 과정에서 ellipsize 가 적용되며, 이때 mMaximumVisibleLineCount 값을 기준값으로 사용한다.</li>
</ol>
<p>여기까지만 봤을 때는 아직 특별한 연관성을 찾기 어렵다. Layout 을 생성하는 과정을 좀 더 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TextView.class</span></span><br><span class="line">    <span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spannable) &#123;</span><br><span class="line">                result = <span class="keyword">new</span> DynamicLayout(mText, mTransformed, mTextPaint, wantWidth,</span><br><span class="line">                        alignment, mTextDir, mSpacingMult, mSpacingAdd, mIncludePad,</span><br><span class="line">                        mBreakStrategy, mHyphenationFrequency, mJustificationMode,</span><br><span class="line">                        getKeyListener() == <span class="keyword">null</span> ? effectiveEllipsize : <span class="keyword">null</span>, ellipsisWidth);</span><br></pre></td></tr></table></figure>

<p>이전 단락에서 autoLink 혹은 movementMethod 를 사용했을 경우 mText 는 spannable 로 포장된다고 한 것을 떠올려 보자. 그런데 mText 가 spannable 일 경우 Layout 은 DynamicLayout 으로 생성된다. DynamincLayout 은 내부적으로 StaticLayout 을 이용하여 Text 를 렌더링하는데, <strong>이때 StaticLayout 에 mMaximumVisibleLineCount 값을 따로 설정 해주지 않는 특징이 있다</strong>. mMaximumVisibleLineCount 는 디폴트 값인 Integer.MAX_VALUE 으로 초기화 된다. 따라서 보여줄 수 있는 line 의 수가 의미상 무한대에 가까우므로 ellipsis 는 표현되지 않는다. </p>
<h1 id="원인-정리"><a href="#원인-정리" class="headerlink" title="원인 정리"></a>원인 정리</h1><p>내용이 길었는데 원인을 정리하면 다음과 같다.</p>
<ol>
<li>ellipsize 는 mMaximumVisibleLineCount 값을 기준으로 노출여부가 결정된다. 이 값은 보통 maxLines 값으로 초기화 된다.</li>
<li>autoLink or movementMethod 는 text 를 spannable 로 포장한다.</li>
<li>text 가 spannable 하면 mMaximumVisibleLineCount 이 MAX_VALUE 인 Layout 을 생성한다. 따라서 ellipsize 가 노출되지 않는다.</li>
</ol>
<h1 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h1><p>결국 위 상황을 해결하기 위해서는 2가지 옵션이 있다.</p>
<ol>
<li>ellipsize 를 커스텀하게 구현한다.</li>
<li>autoLink / movementMethod 를 커스텀하게 구현한다.</li>
</ol>
<p>간단해보이는 View 라도 막상 구현하다보면 생각치도 못한 엣지 케이스, 예외들이 너무 많이 발생하는 것을 경험했고 나는 이것을 유지보수 할 자신이 없었다. 그래서 최대한 기존에 구현된 내용을 이용하고자 했다.</p>
<p>각각 ellipsize 는 실제로 영향을 받는 부분이 많았고 구현이 너무 깊숙히 숨겨져있어 외부에서 컨트롤 할 수 있는 타이밍이 없을 것 같아 보류하였고<br>autoLink / movementMethod 는 구현 내용을 살펴보니 TextView 외부에서도 처리가 가능할 것 같았다.<br>따라서 autoLink / movementMethod 를 기존 구현을 최대한 참고하여 구현해보기로 하였다.</p>
<h2 id="autoLink-적용하기"><a href="#autoLink-적용하기" class="headerlink" title="autoLink 적용하기"></a>autoLink 적용하기</h2><p>TextView 내부에서 autoLink 가 적용되는 과정은 크게 2가지로 나눌 수 있다.</p>
<ol>
<li>Linkify 를 이용하여 text 에 link 스타일링</li>
<li>조건이 충족되면 디폴트 movementMethod 를 set</li>
</ol>
<p>1 번 과정은 똑같이 Linkify 를 이용하여 적용하면된다.<br>2번 과정은 오히려 막아야 하므로 조건을 충족시키지 않도록 해야한다. setLinksClickable() 를 이용하여 조건 값을 설정할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mTextView.setLinksClickable(<span class="keyword">false</span>); <span class="comment">// 디폴트 movementMethod 를 사용하지 않겠다.</span></span><br><span class="line"></span><br><span class="line">mTextView.setText(<span class="string">"Hello https://google.com !"</span>);</span><br><span class="line">Linkify.addLinks(mTextView, Linkify.WEB_URLS);</span><br></pre></td></tr></table></figure>

<h2 id="movementMethod-적용하기"><a href="#movementMethod-적용하기" class="headerlink" title="movementMethod 적용하기"></a>movementMethod 적용하기</h2><p>MovementMethod 인터페이스의 역할은 link 텍스트 클릭 이벤트를 감지하여 미리 정의된 동작을 수행하는 것이다.</p>
<p>디폴트로 사용되는 LinkMovementMethod 의 내부 구현을 살펴보면, 텍스트 터치 시 텍스트에 Clickable 한 span 이 있는지 감지하여 onClick 콜백을 호출해준다. ClickableSpan 은 곧 link 텍스트라고 봐도 좋다.</p>
<p>나는 link 텍스트를 감지하는 부분에 대한 구현만 그대로 가져와, 감지 했을 시 내가 넣어둔 콜백이 수행되는 커스텀 TouchListener 를 생성하여 사용하였다.<br>(LinkMovementMethod - onTouchEvent  내부 구현을 보면 어렵지 않게 힌트를 얻을 수 있을 것이다.)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mTextView.setOnTouchListener(mCustomUrlTouchHandler);</span><br></pre></td></tr></table></figure>

<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>약간의 우회를 통하여 결과적으로는 ellipsize 도 적용되고, autoLink / movementMethod 도 이용할 수 있는 구현을 완성하였다. 하지만 말 그대로 우회일뿐 언제 이슈 케이스가 발견될지 모르기에 아직은 걱정되는 부분이 많다.<br>해당 이슈가 리포트된지 꽤 오랜 시간이 지났음에도 해결되지 않아 많은 사람들이 고통을 겪고 있는 듯 하다. 일해라 구글! 😡</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>TextView</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] MVVM 과 LiveData 조합 시 겪을 수 있는 이슈와 해결책</title>
    <url>/2020/03/13/live_data_with_event_issue/</url>
    <content><![CDATA[<p><img src="/images/cover/live_data_with_event_cover.jpg" alt><br>이번 포스트에서는 MVVM 아키텍처에서 LiveData 를 사용하면서 겪었던 어려움과 여러 해결방법에 대해 적어보려한다. MVVM 에 대한 좋은 글은 이미 많이 있으므로 해당 포스트에서는 생략하고 넘어간다! </p>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul>
<li>LiveData 는 이벤트 전달에 적합하지 않다. 약간의 변형이 필요하다.</li>
</ul>
<h1 id="데이터와-이벤트-흐름"><a href="#데이터와-이벤트-흐름" class="headerlink" title="데이터와 이벤트 흐름"></a>데이터와 이벤트 흐름</h1><p>MVVM 구조내에서 개발을 할 때, ViewModel → View 의 흐름을 다음과 같이 2가지로 나누어 다루고 있다. 일반적인 정의는 아닐 수 있으나, 해당 글에서 전개될 내용의 핵심이므로 잘 이해하고 가는 것이 중요하다.</p>
<h2 id="데이터"><a href="#데이터" class="headerlink" title="데이터"></a>데이터</h2><p>데이터는 보통 모델로부터 가공되거나 유저의 액션에 의해 얻어진 특정한 값으로 이루어진다. ObservableField 나 LiveData 형태로 래핑되어 제공되며 <strong>데이터 바인딩</strong>을 이용하여 View (XML) 에게 변경 사항이 전달된다. 대표적으로 다음과 같은 케이스가 있다.</p>
<ul>
<li>model 로 부터 가공된 list</li>
<li>visibility</li>
<li>도메인과 관련된 flag 값</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/recyclerView"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:visibility</span>=<span class="string">"@&#123;viewModel.temporaryArticles.size() &gt; 0 ? View.VISIBLE : View.GONE&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">bind:bindData</span>=<span class="string">"@&#123;viewModel.temporaryArticles&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><p>이벤트는 databinding 을 통해 수행할 수 없는 작업 즉, Activity/Fragment 레벨에서만 처리할 수 작업들로 구성된다. 이 부분은 자유도가 높지만 보통 RxJava/LiveData 를 이용하여 제공하며 Activity/Fragment 에서 이를 소비한다.  대표적으로 다음과 같은 케이스가 있다.</p>
<ul>
<li>Activity action - startActivity(), finish()</li>
<li>Dialog</li>
<li>Permission</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mViewModel.finishEvent.observe(<span class="keyword">this</span>, aVoid -&gt; finish())</span><br></pre></td></tr></table></figure>

<h1 id="LiveData-의-한계와-대안점"><a href="#LiveData-의-한계와-대안점" class="headerlink" title="LiveData 의 한계와 대안점"></a>LiveData 의 한계와 대안점</h1><p>앞서 언급했듯이 이벤트를 전달하는 것은 구현 자유도가 높은 편이다. </p>
<p>RxJava 를 이용해도 되고, LiveData 혹은 Custom 하게 Obeserver 패턴 구현체를 써도 상관 없다.  하지만 RxJava 나 Custom Observer 를 구현하면 라이프사이클을 계속 신경써줄수 밖에 없기 때문에 보통은 LiveData 를 선택한다. </p>
<p>그래도 애매할 때는 여러 레퍼런스를 참고해보며 힌트를 얻어보자. 구글에서 운영하고 있는 공식 repo 인 <a href="https://github.com/google/iosched" target="_blank" rel="noopener">Goolge IO app</a> 과 <a href="https://github.com/android/architecture-samples" target="_blank" rel="noopener">Architecture Sample</a> 를 살펴보자.</p>
<h2 id="변형된-형태의-LiveData"><a href="#변형된-형태의-LiveData" class="headerlink" title="변형된 형태의 LiveData"></a>변형된 형태의 LiveData</h2><p>각 repo 는 LiveData 를 이용하여 아래와 같이 이벤트 흐름을 처리하고 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Google IO repo</span></span><br><span class="line"><span class="keyword">private</span> val _navigateToSignInDialogAction = MutableLiveData&lt;Event&lt;Unit&gt;&gt;()</span><br><span class="line">val navigateToSignInDialogAction: LiveData&lt;Event&lt;Unit&gt;&gt;</span><br><span class="line">    get() = _navigateToSignInDialogAction</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> val _navigateToSignOutDialogAction = MutableLiveData&lt;Event&lt;Unit&gt;&gt;()</span><br><span class="line">val navigateToSignOutDialogAction: LiveData&lt;Event&lt;Unit&gt;&gt;</span><br><span class="line">    get() = _navigateToSignOutDialogAction</span><br><span class="line"></span><br><span class="line"><span class="comment">// Artictecture sample repo</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SingleLiveEvent&lt;Void&gt; mEditTaskCommand = <span class="keyword">new</span> SingleLiveEvent&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>그런데 자세히 보니 LiveData 를 그대로 쓰지 않고 변형된 형태로 쓰고 있다. IO 의 경우 데이터를 Event 로 한번 더 래핑하였고, sample 에서는 아예 새로운 구현체를 만들어 사용하고 있었다.</p>
<p>각 구현체의 내부를 좀 더 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SingleLiveEvent.java</span></span><br><span class="line"><span class="keyword">super</span>.observe(owner, <span class="keyword">new</span> Observer&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable T t)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mPending.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    observer.onChanged(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Event.kt</span></span><br><span class="line"><span class="function">override fun <span class="title">onChanged</span><span class="params">(event: Event&lt;T&gt;?)</span> </span>&#123;</span><br><span class="line">        event?.getContentIfNotHandled()?.let &#123; value -&gt;</span><br><span class="line">            onEventUnhandledContent(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>각 구현체의 구조는 거의 유사한데 다음과 같은 특징을 가지고 있다.</p>
<ol>
<li>LiveData 에 등록되는 Observer 를 한번 더 래핑한다.</li>
<li>래핑된 Observer 는 <strong>onChanged 콜백이 여러번 호출되는 것을 막는다.</strong></li>
</ol>
<p>구글은 왜 이러한 처리를 거쳐서 LiveData 를 사용했을까? 이유는 LiveData 내부 구조에 있다.</p>
<h2 id="LiveData-는-데이터를-위해-만들어-졌다"><a href="#LiveData-는-데이터를-위해-만들어-졌다" class="headerlink" title="LiveData 는 데이터를 위해 만들어 졌다."></a>LiveData 는 데이터를 위해 만들어 졌다.</h2><p><a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=en" target="_blank" rel="noopener">docs</a> 에서는 LiveData 를 다음과 같이 정의하고 있다.</p>
<blockquote>
<p>LiveData is an observable data holder class</p>
</blockquote>
<p>즉, <strong>LiveData 는 애초에 데이터의 전달을 위해 설계됐다는 얘기다.</strong> 다만, 리엑티브한 개념에서 데이터를 좀 더 추상적으로 생각한다면 이벤트 소스도 하나의 데이터로 생각할 수 있기에 이벤트 전달에 활용을 해도 어색하지는 않다. 다만 구조상 그대로 이벤트를 위해 사용하기에는 한계가 있어 위와 같은 변형 구조로 사용하게 되는 것이다.</p>
<p>여기서 LiveData 의 모든 코드를 다 확인하고 가기는 어려우므로 핵심적인 부분만 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        removeObserver(mObserver);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activeStateChanged(shouldBeActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LiveData 는 N 개의 옵저버가 등록될 수 있고,  각 옵저버는 메모리 관리를 위해 active 라는 상태를 가지고 있다. 해당 코드를 잘보면 생명주기가 바뀔 때마다 옵저버의 active 상태를 체크하며, 생명주기가 onStart 이후이면 옵저버가 active 될 수 있다고 판단한다.</p>
<p>그리고 <strong>옵저버는 inactive → active 로 상태가 바뀌면, LiveData 데이터를 소유하고 있을 경우 이를 콜백으로 전달받는다.</strong></p>
<p>이러한 구조가 이벤트를 전달할 때 왜 문제가 될 수 있을까? 예시 상황을 가정해보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainViewModel.java</span></span><br><span class="line">LiveData&lt;String&gt; mShowLoginEvent = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line">mViewModel.getShowLoginEvent.observe(<span class="keyword">this</span>, <span class="keyword">this</span>::showLoginDialog)</span><br></pre></td></tr></table></figure>

<p>ViewModel 은 AAC ViewModel 을 상속 받은 것으로 가정한다.</p>
<ol>
<li>ViewModel 은 로그인 API 를 수행하고, 성공 시 다이얼로그를 띄우는 이벤트를 정의</li>
<li>MainActivity 가 onCreate 에서 이벤트를 구독</li>
<li>유저 액션으로 로그인 요청 → 로그인 수행 → 성공 → 다이얼로그 노출까지 문제 없음</li>
<li>화면이 회전됨</li>
<li>ViewModel 은 그대로 살아아있음.</li>
<li>Activity 가 다시 onCreate 에서 이벤트를 구독</li>
<li>onStart 가 됐을 때, <strong>구독한 옵저버는 inactive → active 가 되었고 이전에 발행한 로그인 이벤트 데이터가 남아있으므로 콜백이 호출되어 로그인 다이얼로그가 다시 노출 됨</strong></li>
</ol>
<p>이런 케이스도 있을 수 있다. 동일한 AAC ViewModel 을 이용하여 Activity ↔ Fragment 통신을 수행하며 Activity 에 N 개의 Fragment 가 있다면 한번 발행된 이벤트는 이후에 명시적으로 post(=setValue) 를 하지 않아도, 각 Fragment 가 구독할 때 마다 전달받을 것이다.</p>
<p><strong>즉, 이벤트를 구독하는 입장에서는 명시적으로 발행된 이벤트만 소비하고 싶은데 자꾸 이전에 발행됐던 이벤트가 전달되는 현상이 발생한다. 중요도가 높은 이벤트일수록 이러한 현상은 치명적으로 다가올 수 있다.</strong></p>
<p>*구글에 LiveData twice 만 검색해도 고통을 겪은 많은 사람들을 볼 수 있다.</p>
<p><img src="/images/google_search_live_twice.png" alt></p>
<h1 id="그럼-무엇을-선택해야할까"><a href="#그럼-무엇을-선택해야할까" class="headerlink" title="그럼 무엇을 선택해야할까?"></a>그럼 무엇을 선택해야할까?</h1><p>위와 같은 이유로 인해 LiveData 를 이벤트 전달로 사용하기 위해서, onChanged 콜백이 여러번 호출되는 것을 막는 변형구조가 탄생하게 되었다. </p>
<p>그럼 이벤트 전달을 할때는 무엇을 선택하는 것이 좋을까? 진행하고 있는 프로젝트 상황이 각자 다르기에 꼭 하나를 추천하기는 어려울 것 같다. 다만, 현재 진행하고 있는 프로젝트에서 SingleLiveData 와 커스텀 LiveEvent 를 섞어서 사용하고 있으므로 사용해보면서 느낀점을 정리해보면서 마무리하고자 한다.</p>
<h2 id="SingleLiveEvent"><a href="#SingleLiveEvent" class="headerlink" title="SingleLiveEvent"></a>SingleLiveEvent</h2><p><a href="https://github.com/android/architecture-samples/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java" target="_blank" rel="noopener">코드</a> 및 <a href="https://proandroiddev.com/singleliveevent-to-help-you-work-with-livedata-and-events-5ac519989c70" target="_blank" rel="noopener">관련 포스트</a>를 참고하면 금방 이해할 수 있을거라 생각한다.</p>
<p>구조는 단순하다. MutableLiveData 를 상속받아, 명시적으로 setValue 를 호출했을 때만 데이터가 전달되도록 flag 를 걸어주었다.</p>
<ul>
<li>장점은 MutableLiveData 를 상속받았기 때문에 기본적으로 메모리 관리나 LifeCycle 변경에 따른 처리를 따로 해줄필요가 없다. 사용방법도 기존의 LiveData 사용하듯이 쓰면 된다.</li>
<li>단점은 옵저버를 여러개 등록할 수 없다. 제일 처음 구독한 옵저버가 데이터를 소비하면 그 뒤에 등록된 옵저버는 데이터를 전달받을 수 없다. 따라서 글로벌 이벤트나 Activity 나 Fragment 가 동시에 이벤트를 구독하는 케이스 등에서 활용할 수 없다.</li>
</ul>
<h2 id="커스텀-LiveEvent"><a href="#커스텀-LiveEvent" class="headerlink" title="커스텀 LiveEvent"></a>커스텀 LiveEvent</h2><p>이 부분은 커스텀을 어떻게 하느냐에 따라 달라지기 때문에 짧게만 적겠다. 기본적인 구현 아이디어는 LifeCycleOwner 를 전달받아 생명주기에 따른 처리를 해주고, 그외에는 Observer 패턴을 그대로 따른다.</p>
<ul>
<li>장점은 옵저버를 여러개 등록할 수 있으며, LiveData 구조를 따르지 않으므로 이전 이벤트가 다시 전달되지 않는다.</li>
<li>단점은 구조를 바닥부터 새로 짜기 때문에, 초기에 LiveData 보다 안정성이 많이 떨어지는 리스크가 있다.</li>
</ul>
<h1 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h1><p>LiveData 가 나오면서 생명주기 관리에 대한 리소스가 줄어들고 좀 더 리엑티브한 구조로 가기 쉬워진 것은 너무나 환영할 일이다. 하지만 마구잡이로 사용했다가는 새로운 고통을 안겨줄 수 있으므로 잘 이해하고 사용하는 것이 중요하다. (리엑티브한 구조는 디버깅이 너무 괴롭다..) </p>
<p>LiveData 코드는 그리 양이 많지 않아 시간이 될 때 훑어보는 것도 큰 공부가 될 것이라고 생각한다.   👍</p>
]]></content>
      <tags>
        <tag>Android,Reactive,MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title>2월의 성장기</title>
    <url>/2020/02/27/2020-feb-review/</url>
    <content><![CDATA[<p><img src="/images/cover/2019-feb-review-cover.png" alt><br>여유롭게 지나갈 줄 알았지만 폭풍같았던 2월이었다. 바빴던 만큼 깨달은 내용이 많아 짧게 정리했다.</p>
<h1 id="있어야할-곳에-있는-편안함"><a href="#있어야할-곳에-있는-편안함" class="headerlink" title="있어야할 곳에 있는 편안함"></a>있어야할 곳에 있는 편안함</h1><p>최근 작업을 진행하면서 예상보다 훨씬 넓은 범위의 레거시 코드를 수정하게 되었다. 다양한 역사를 지닌 레거시를 보면 볼 수록 강력하게 떠오르는 생각이 있었다.</p>
<p><strong>아, 코드가 있어야할 곳에 있는 것이 이렇게 중요한거구나</strong></p>
<p>좀 더 풀어서 얘기하면 미리 합의된 약속을 지키는 것이라고 볼 수 있다. 약속은 MVP 와 같은 패턴일 수도 있고, 팀내 가이드 라인 혹은 Android 세계에서 암묵적으로 지켜지고 있는 표준일 수도 있다. 중요한 것은 합의된 약속을 지키는 것이다. Next Step 에서 배운 표현을 빌리자면 클-린한 코드를 작성하는 것이 되겠다.</p>
<p>사실 레거시가 왜 이렇게 구현되어있는지 따지는 것은 별 이득이 없다. 그때 당시에는 그게 최선이었을지도 모른다. 하지만 레거시 중에서도 약속이 지켜진 코드는 수정이 간단했고, 약속이 깨진 코드는 어김없이 버그를 유발하거나 결과 대비 많은 시간을 요구하는 차이를 보였다.</p>
<p>그런데 더 중요한 문제는 약속이 깨졌다는 이유로 그 위에 새롭게 약속이 깨진 코드를 짜고 있다는 것이었다. 깨진 약속 위에 새로운 약속을 세우는 것이 당장은 어렵고, 신경쓸게 더 많기 때문이다. 일정이 임박할 수록 ‘나중에 고쳐야지’ 라는 마법의 문장을 남발하며 깨진 코드 위에 깨진 코드를 얹는 유혹에 빠진다. </p>
<p>그 나중은 돌아오지 않는 걸 알고 있으니… 지금부터라도 점진적으로 약속을 지키다보면 언젠가는 눈에 띄는 개선이 이루어져 있지 않을까? 🤔</p>
<h1 id="로우-레벨-지식의-기계적-반응"><a href="#로우-레벨-지식의-기계적-반응" class="headerlink" title="로우 레벨 지식의 기계적 반응"></a>로우 레벨 지식의 기계적 반응</h1><p>자주 반복해서 겪는 이슈, 자주 사용되는 속성 값, 기본적인 API 사용법 등 로우한 레벨의 지식을 기계적으로 체화시켜놓으면 더 높은 레벨에 대한 고민과 설계를 할 수 있는 여유를 확보할 수 있다. 어차피 검색하면 다 나온다고 하지만 이건 굉장히 중요한 포인트라고 생각한다.</p>
<p><strong>내가 하루에 쏟을 수 있는 집중력과 에너지는 명확한 한계가 있기 때문이다.</strong> 그렇다고 docs 를 전부 외우려는 것은 아니고, 반복되는 내용들은 필요할 때 빠르게 참고할 수 있도록 짧게 정리하고 있다. 👉🏻 <a href="https://progjh.gitbook.io/today-i-learned/" target="_blank" rel="noopener">TIL</a> 한번 내용을 정리한 후, 여러번 참고하다보면 내 머리속에 나름의 인덱스가 생겨 나중에는 관련 토픽만 보면 자동으로 떠오르는 효과가 있었다. 😮</p>
<h1 id="좀-더-개발로…"><a href="#좀-더-개발로…" class="headerlink" title="좀 더 개발로…"></a>좀 더 개발로…</h1><h2 id="상속은-신중히-사용하자"><a href="#상속은-신중히-사용하자" class="headerlink" title="상속은 신중히 사용하자"></a>상속은 신중히 사용하자</h2><p>레거시 코드를 처리할 때도 가장 골치가 아픈 케이스는 상속과 엮인 것이다. 바뀐 스펙에 대한 도메인이 상위 클래스에 엮여있다? 그런데 그 클래스가 BaseActivity 이다? 상속받는 클래스를 찍어보니 100개를 우습게 넘어간다. 사이드 이펙트를 예측할 수 없으니 함부로 건드릴수가 없고, 간단한 스펙에도 많은 시간과 에너지가 소모된다.</p>
<p>이펙티브 자바에서도 지적했지만 <strong>상위 클래스는 상속받는 하위 클래스를 예측할 수 없다. 그리고 계속해서 변경사항이 생긴다.</strong> 하위 클래스는 점점 더 쌓여가는데 호환성때문에 변경은 점점더 악순환에 빠지게 된다.</p>
<p>상속이 필요한 순간이 분명히 있다. 사용할 때는 꼭 신중히 상위 클래스의 코드를 작성하고, 의도를 명확히 밝혀주는 것이 좋다. </p>
<h2 id="LiveData-는-이벤트-전달로-적합하지-않다"><a href="#LiveData-는-이벤트-전달로-적합하지-않다" class="headerlink" title="LiveData 는 이벤트 전달로 적합하지 않다"></a>LiveData 는 이벤트 전달로 적합하지 않다</h2><p>MVVM 패턴을 적용할 경우, 대부분의 케이스는 databinding 을 이용하여 구현이 가능하다. 하지만 Dialog 를 띄운다던지, 다른 Activity 를 시작하는 등 반드시 Activity/Fragment 레벨에서 수행되어야 하는 작업들이 존재하며 이는 특정 Event 를 Activity/Fragment 가 구독하는 방식으로 풀 수 있다. </p>
<p>Event 를 전달하는 방식에는 RxJava, LiveData, 커스텀 Observer 구현 등 여러 옵션이 있다. LiveData 가 나온 뒤에는 주로 LiveData 를 활용하는 추세로 보인다.</p>
<p>문제는 LiveData 가 이름에서도 나타나듯이 데이터의 변경을 전달하는 것은 적합하나 Event 를 전달하기에는 내부 구현에 몇가지 문제점을 가지고 있다. 구글에서는 이를 보완하고자 io 앱 내에서 SingleLiveData 와 같은 구현체를 사용하고 있으나 이 역시 한계점을 가지고 있다. 자세한 내용은 다음 포스트에서 적어보려한다.</p>
<p>추후에는 생각이 바뀔수도 있으나 최근에 내린 결론은 LiveData 는 이벤트 전달용으로 적합하지 않다.</p>
<h1 id="강제성과-습관의-형성"><a href="#강제성과-습관의-형성" class="headerlink" title="강제성과 습관의 형성"></a>강제성과 습관의 형성</h1><p>나는 강제성이 없으면 잘 움직이지 않는다. 그리고 무지하게 게으르다. 습관이 형성되기 위해서 최소 1년은 반복해야한다고 생각하기 때문에, 긍정적인 강제성을 부여해주는 글또를 망설임 없이 다시 신청하게 되었다.</p>
<p>이번 기수 목표는 3가지 이다.</p>
<ol>
<li><p>문장을 짧고 간결하게 쓰는 연습</p>
<p> → 평소에 글을 잘 적지 않다보니, 문장이 너무 장황해지는 경향이 있다. 짧으면서도 핵심있게 내용을 전달하는 문장을 쓰고 싶다.</p>
</li>
<li><p>각기 다른 성격의 글쓰기 연습</p>
<p> → 개인 위키 성격의 TIL 페이지와 기술/이슈/삶에 대한 회고성글을 적는 블로그 2가지를 각각 운영 해보려한다. 각 목적에 맞는 문장과 구성을 연구해보려한다.</p>
</li>
<li><p>Pass 사용 안하기</p>
<p> → 글쓰기 습관을 확실히 다지겠다는 의지를 보이기 위해 이번에는 Pass 를 안써보려한다.</p>
</li>
</ol>
<p>아! 그리고 글또 4기는 안드로이드 개발자분들이 이전 기수보다 많이 참여하신 것으로 보이는데, 배워갈 수 있는 기회가 더 늘게되어 기쁘다. 🥰</p>
]]></content>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] Process 재시작 과 Fragment 생명 주기</title>
    <url>/2020/02/23/fragment_lifecycle_with_restarted_process/</url>
    <content><![CDATA[<p><img src="/images/bike_cover.jpg" alt></p>
<p>최근에도 큰 규모의 리펙토링을 진행했는데, Fragment 생명주기에 대한 지식이 부족하여 많은 이슈를 발생시켰다. 😭 이번 포스팅에서는 해당 이슈의 원인과 해결법에 대해 적어보려 한다.</p>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul>
<li>프로세스가 재 시작 될 때 Activity, Fragment 의 생명 주기 흐름이 조금 다르게 진행된다.</li>
<li>Fragment 에서 Activity 의 데이터를 참조할 때는 onActivityCreated 메소드 내에서 진행하자.</li>
</ul>
<h1 id="프로세스-Activity-Fragment-의-생명주기"><a href="#프로세스-Activity-Fragment-의-생명주기" class="headerlink" title="프로세스, Activity, Fragment 의 생명주기"></a>프로세스, Activity, Fragment 의 생명주기</h1><p>안드로이드의 독특한 특징 중 하나는 프로세스 생명 주기와 어플리케이션 생명 주기와 항상 동일하지 않다는 점이다. 앱이 실행되고 있어도 프로세스를 죽일 수 있고 반대로, 앱을 종료해도 프로세스가 바로 종료되는 것은 아니다.</p>
<p>대표적으로 시스템이 프로세스를 죽이는 경우는 다음과 같다.</p>
<ul>
<li>메모리가 부족할 경우 시스템은 우선순위가 낮은 프로세스를 죽인다.</li>
<li>앱이 일정 기간 이상 백그라운드 상태에 있을 경우 시스템은 해당 앱의 프로세스를 죽인다.</li>
<li>앱이 허용했던 권한을 해제 시 시스템은 해당 앱의 프로세스를 죽인다.</li>
</ul>
<p>하지만 이렇게 앱과 프로세스의 수명 주기가 일치하지 않을 경우 유저는 영문도 모른채 간헐적으로 처음부터 재시작하는 앱을 경험하게 될 것이다. 이에 onSaveInstance 메소드를 제공하여 데이터를 백업하고 사용하여 사용자에게 영향을 주지 않도록 설계되어 있다.</p>
<p>문제는 이렇게 ‘시스템이 프로세스를 죽이고, 해당 프로세스가 재시작 됐을 경우’ Activity 와 Fragment 의 생명주기 흐름이 일반적인 상황과는 조금 다르게 진행된다.</p>
<h1 id="일반적인-상황에서-생명-주기-흐름"><a href="#일반적인-상황에서-생명-주기-흐름" class="headerlink" title="일반적인 상황에서 생명 주기 흐름"></a>일반적인 상황에서 생명 주기 흐름</h1><p>사용자가 처음 앱을 구동하는 상황으로 가정한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainActivity.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"lifeCycle"</span>, <span class="string">"Activity onCreate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize ...</span></span><br><span class="line"></span><br><span class="line">        addFragment();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 onCreate 메소드 에서 Fragment 를 초기화 해준다고 했을 때, LifeCycle 은 다음과 같은 순서로 진행된다.</p>
<pre><code>E/lifeCycle: Activity onCreate
E/lifeCycle: Fragment onAttach
E/lifeCycle: Fragment onCreate
E/lifeCycle: Fragment onCreateView
E/lifeCycle: Fragment onActivityCreated</code></pre><h1 id="시스템에-의해-kill-된-프로세스가-재-시작-될-때-생명-주기-흐름"><a href="#시스템에-의해-kill-된-프로세스가-재-시작-될-때-생명-주기-흐름" class="headerlink" title="시스템에 의해 kill 된 프로세스가 재 시작 될 때, 생명 주기 흐름"></a>시스템에 의해 kill 된 프로세스가 재 시작 될 때, 생명 주기 흐름</h1><p>좀 더 자세한 흐름을 보기 위해 로그를 아래와 같이 세분화 하였다. 그 외에 변경사항은 없다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainActivity.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"lifeCycle"</span>, <span class="string">"Activity onCreate : before super.onCreate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.e(<span class="string">"lifeCycle"</span>, <span class="string">"Activity onCreate : after super.onCreate"</span>);</span><br><span class="line">        </span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        addFragment();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>시스템에 의해 kill 된 프로세스를 재 시작 했을 때 LifeCycle 은 다음과 같은 순서로 진행된다.</p>
<pre><code>E/lifeCycle: Activity onCreate : before super.onCreate
E/lifeCycle: Fragment onAttach
E/lifeCycle: Fragment onCreate
E/lifeCycle: Activity onCreate : after super.onCreate
E/lifeCycle: Fragment onCreateView
E/lifeCycle: Fragment onActivityCreated</code></pre><p>….!!!</p>
<p>일반적인 상황일 때의 흐름과 큰 차이점이 있다. </p>
<ol>
<li>base Activity 에서 Fragment 를 복구한다.</li>
<li>Fragment 복구가 완료되면 supre.onCreate() 다음 라인으로 흐름이 반환되어 나머지 로직이 진행된다.</li>
</ol>
<p>몇 번을 반복 해봐도 흐름 순서가 동일한 것으로 보아 비동기로 진행되는 것은 아닌 것으로 추측된다.</p>
<h1 id="발생할-수-있는-문제"><a href="#발생할-수-있는-문제" class="headerlink" title="발생할 수 있는 문제"></a>발생할 수 있는 문제</h1><p>위와 같은 차이점은 Fragment 의 onCreate 메소드 내에서 Activity 의 데이터를  참조할 경우 문제가 발생할 수 있다. </p>
<p>Activity 의 여러 initialize 작업이 진행되기 전에 Fragment 의 onCreate 가 불리기 때문에 존재하지 않는 데이터를 참조하여 NPE 가 발생하게 된다. 내가 겪었던 문제도 정확히 이와 같은 케이스였다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MainActivity.class</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"lifeCycle"</span>, <span class="string">"Activity onCreate : before super.onCreate"</span>);</span><br><span class="line">        <span class="comment">// --&gt; Restore Fragment !!!! : called onAttach(), onCreate()</span></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Log.e(<span class="string">"lifeCycle"</span>, <span class="string">"Activity onCreate : after super.onCreate"</span>);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        addFragment();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h1><ol>
<li><p>super.onCreate(savedInstanceState) 가 호출되기 전에 initialize 를 진행한다.</p>
<p> → 추천하지 않는다. 오히려 하위 Activity 가 초기화되지 않았을 때 발생하는 사이드 이펙트가 더 많을 수 있다.</p>
</li>
<li><p><strong>onActivityCreated()</strong> 메소드 내에서 Activity 레벨의 변수를 참조한다.</p>
<p> → 구글에서 권장하는 방법이며, 애초에 이 메소드의 존재 이유라고 생각한다.</p>
<blockquote>
<p>Called when the fragment’s activity has been created and this fragment’s view hierarchy instantiated. It can be used to do final initialization once these pieces are in place, such as retrieving views or restoring state.</p>
</blockquote>
<p> 사실 해당 내용을 공부하기 전까지는 이 메소드의 필요성을 잘 느끼지 못했다. 어차피 onCreate() 나 onActivityCreated() 나 Activity 의 onCreate() 가 끝나고 불리는 것은 동일하다고 생각했기 때문이다. </p>
<p> 하지만 onCreate() 는 <strong>Fragment 의 생성</strong>을 알려줄 뿐 Activity 와 직접적인 연관은 없다. </p>
<p> docs 에서도 이 사실을 친절히 짚어주고 있다.</p>
<blockquote>
<p>Note that this can be called while the fragment’s activity is still in the process of being created. As such, you can not rely on things like the activity’s content view hierarchy being initialized at this point. If you want to do work once the activity itself is created, see onActivityCreated(android.os.Bundle)</p>
</blockquote>
<p> 사실상 오늘 내용의 핵심이 모두 담겨있다…</p>
</li>
</ol>
<h1 id="결론-공식-docs-가-먼저다"><a href="#결론-공식-docs-가-먼저다" class="headerlink" title="결론 - 공식 docs 가 먼저다."></a>결론 - 공식 docs 가 먼저다.</h1><p>항상 넘겨짚는 순간에 실수가 발생한다. 스스로 정확하게 설명할 수 없다면 다시 공부하는 수 밖에 없다.</p>
<p>그리고 위 내용을 찾아보면서 파편화된 정보나 내용의 불일치로 인해 적지않은 시간을 소비했는데 공식 docs 에서 너무 깔끔히 설명하고 있어 허탈함을 조금 느꼈다. 역시 공식 docs 먼저! 😹</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title>1월의 성장기</title>
    <url>/2020/01/31/2020-jen-review/</url>
    <content><![CDATA[<p>포스팅 하고 싶은 주제들은 많은데 아직 마무리를 못하여 여러개의 토막글만 남아있다..<br>그래서 바람같이 흘러갔던 1월에 느꼈던 점들을 짤막하게 정리해본다.</p>
<p>점점 회고 블로그가 되고있다. 😂</p>
<h1 id="목적에-집중"><a href="#목적에-집중" class="headerlink" title="목적에 집중"></a>목적에 집중</h1><p>개발 방향에 대해 논의를 하는데 의견차가 잘 좁혀지지 않을 때가 있다. 각자의 주장에 타당함이 있을 때 어떻게 해야할까?</p>
<p>내가 요즘 가장 많이 하는 말은 ‘목적을 다시 한번 생각해보자.’ 라는 말이다.</p>
<p>아직 팀의 특정 기술 성숙도가 낮을 때 위와 같은 상황이 자주 벌어지곤한다. 일반적인 구현은 크게 문제가 되지 않는데, 점점 규모가 커지고 복잡해질수록 예외상황이 생기면서 방향성이 흐려지기 시작한다. 나같은 경우에는 MVVM 을 처음 공부하고 도입할 때 자주 겪었다. 아키텍처가 이미 정해준 틀이 있는데, 예외를 처리하기는 어렵고. 그리고 흑마술과 같은 방법으로 때우고자 하는 유혹이 강렬하게 찾아온다..</p>
<p>그럴때 우리가 이 기술을 왜 선택했는지, 이 기술은 무슨 목적으로 나온 것인지 살펴보면 의외로 쉽게 해결방법이 나오곤 했다. 용어와 형식이 주는 느낌에 메이지 말고 항상 그 목적성을 상기하는 것이 중요하다고 느낀다. </p>
<p>(기술을 넘어 아키택처, 패러다임 등을 대입해도 동일하게 적용될 수 있다.)</p>
<h1 id="개선이냐-협업이냐"><a href="#개선이냐-협업이냐" class="headerlink" title="개선이냐, 협업이냐"></a>개선이냐, 협업이냐</h1><p>비교적 오래된 프로젝트를 개발하다보면, 거의 프레임워크화 되어 자주 쓰이는 패턴들이 보이곤 한다.  그리고 새로운 코드를 짤 때 고민에 빠진다.</p>
<p>개선의 관점에서는 고치고 싶은 부분들이 군데군데 보인다. 당시에는 최선의 접근방법이었을 것이지만 지금은 너무 신경써야할 리소스가 많이 드는 방식이다. 개선을 건의할까?</p>
<p>협업의 관점에서는 그동안 팀원들이 쌓아온 팀내의 룰과 같다. 이를 바꾼다는 것은 팀원들의 새로운 학습 리소스 + 예외 케이스에 대한 추가 협의 등 새로운 리소스가 소모될 수 있다. 그냥 사용할까?</p>
<p>두 가지 모두 중요한 측면이라고 생각하기에, 항상 긴 내적갈등을 겪는다.</p>
<p>현재 내 방침은 이슈가 되는 부분이 퍼포먼스 혹은 지속적인 관리 이슈를 유발하는 경우에는 1) 타당한 이유와 2) As-Is 와 To-Be 의 확실한 차이점을 내새워 팀원들을 설득하고, 그외에는 패턴을 그대로 사용하기로 했다. 그리고 팀원들이 모두 동의했을 경우 개선 작업은 <strong>반드시 내가 주도하여 마무리 할 것</strong>. 뒤에서 불평만 하는 사람이 되기 싫다.</p>
<h1 id="간결한-것이-최선의-설명일-수-있다"><a href="#간결한-것이-최선의-설명일-수-있다" class="headerlink" title="간결한 것이 최선의 설명일 수 있다"></a>간결한 것이 최선의 설명일 수 있다</h1><p>최근에 이메일을 작성할 때 받은 피드백이었다. </p>
<ul>
<li>두괄식 작성</li>
<li>전달하고자 하는 내용은 짧게. 전문 용어나 자세한 히스토리 X.</li>
</ul>
<p>안드로이드에서만 추가한 내용을 다른 플랫폼에 공유하는 메일이었는데, 나는 개발자의 마인드로 추가된 내용과 히스토리를 엄청 디테일하게 적었다. 그리고 위와 같은 피드백을 받았는데, 그 이유로는</p>
<ol>
<li>사람들은 하루에도 수십개의 참조메일을 받기 때문에 길면 잘 안읽을 수 있다(!)<br>읽어도 당사자가 아니면 이해하기 어렵다. 결국 내가 전달하고자 하는 내용조차 묻힐 수 있음.</li>
<li>상세한 히스토리는 추가 요청때 전달해줘도 충분하다.</li>
</ol>
<p>명쾌했다! 아직도 메일로 전달하는 것은 좀 더 숙달되어야 함을 느낀다.</p>
]]></content>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>2019년 하반기 회고</title>
    <url>/2019/12/22/2019-second-half-review/</url>
    <content><![CDATA[<p>이직 후 정신없는 하반기를 보냈다. 기대 이상의 성취를 얻은 부분도 있고, 아예 시도조차 못한 부분도 있었다. 스스로 회고하며 기억에 남을 만한 일들을 정리했다.</p>
<h1 id="개발"><a href="#개발" class="headerlink" title="개발"></a>개발</h1><h2 id="의도를-드러내는-코드-짜기"><a href="#의도를-드러내는-코드-짜기" class="headerlink" title="의도를 드러내는 코드 짜기"></a>의도를 드러내는 코드 짜기</h2><p>우리의 기억력은 빈약하고 왜곡되기 쉽다. 복잡한 비즈니스 로직과 히스토리를 반년 뒤에도 기억할리가 없기 때문에 주섬주섬 주석을 달지만, 이마저도 나중에 보면 이해하기 어려울 때가 많다.</p>
<p>결국은 코드 자체를 통하여 의도를 드러내는 것이 가장 이상적인 형태이다. 이를 실천하기 위해 많은 고민과 노력이 동반 되었고, 특히 하반기에 수강했던 <a href="https://vagabond95.github.io/2019/11/23/nextstep-class-review/" target="_blank" rel="noopener">NextStep 과정</a>이 아주 큰 도움이 되었다.</p>
<h2 id="예외-처리와-Stateless-한-코드-짜기"><a href="#예외-처리와-Stateless-한-코드-짜기" class="headerlink" title="예외 처리와 Stateless 한 코드 짜기"></a>예외 처리와 Stateless 한 코드 짜기</h2><p>‘설마 이 상황이 발생하겠어?’ 라는 마음가짐으로 코드를 짜면 항상 그 부분에서 문제가 발생하게 되는 것을 피부로 겪었다. 많은 사용자 수와 그에 대응되는 수많은 환경을 고려했을 때, 발생할 수 없는 상황은 없다고 생각하는 것이 옳다. 발생할 수 있는 모든 예외 상황에 대한 가드 처리가 필요하며, 너무 많은 가드 처리는 가독성을 떨어트릴 수 있으므로 언어/코드 레벨에서 사전에 방지할 수 있는 방법은 없는지 많은 고민을 했다. 최근까지 도달한 결론은 꼭 필요한 상태(State)가 아니면 사용하지 않는 방향으로 하여 관리포인트와 사이드 이펙트를 줄여나가자는 것으로 마무리 했다.</p>
<h2 id="아무리-강조해도-지나치지-않은-커뮤니케이션"><a href="#아무리-강조해도-지나치지-않은-커뮤니케이션" class="headerlink" title="아무리 강조해도 지나치지 않은 커뮤니케이션"></a>아무리 강조해도 지나치지 않은 커뮤니케이션</h2><p>개발자라고 해서 항상 주어진 업무 시간 전부를 개발에 쓰기는 어렵다. 정기적/비정기적인 커뮤니케이션 구간이 항상 존재하기 때문이다. 피할 수 없는 일이라면 잘하고 싶다. 잘하기 위해 다음과 같은 노력을 했다.</p>
<h3 id="커뮤니케이션-대상에-대한-공통된-합의"><a href="#커뮤니케이션-대상에-대한-공통된-합의" class="headerlink" title="커뮤니케이션 대상에 대한 공통된 합의"></a>커뮤니케이션 대상에 대한 공통된 합의</h3><p>같은 개념을 얘기하는 데 다른 언어가 사용되고, 같은 언어를 사용하는데 다른 개념(혹은 구현)으로 설명될 때가 많았다. 이러한 불일치를 보정하는 과정이 발생할 때마다 진행의 병목이 생기고 커뮤니케이션 비용이 높아지는 것이 부담되기 시작했다. 그래서 이를 내가 할 수 있는 일들을 하나씩 진행해봤다. </p>
<p>1) 기본적으로 커뮤니케이션 시작 전에 이야기하고자 하는 목적과 대상을 한번 더 체크 했다. (ex/ 저는 A 의 B 부분에 대해 논의해야하는 것으로 알고 있는데 맞을까요~?) 이렇게 하면 초기 리소스는 조금 더 들 수 있지만 이미 커뮤니케이션이 어느정도 진행된 후 보정하는 것보다는 훨씬 나은 결과를 얻었다. 매번 이 방식을 고수하다보니, 나중에는 먼저 얘기를 꺼내주시는 분들도 생겼다!</p>
<p>2) 팀장님에게 좀 더 정기적인 코드 리뷰 시간 확보를 요청했다. 이 일정은 개념/구현에 대한 논의를 거쳐 통일된 방향으로 나아가는 시간이 되었고, 이 이후 팀원간 커뮤니케이션 속도가 빨라졌을 뿐만아니라 구현에 대한 통일성도 얻어갈 수 있었다.</p>
<h3 id="설득의-기술"><a href="#설득의-기술" class="headerlink" title="설득의 기술"></a>설득의 기술</h3><p>기획서에서는 한 줄 분량의 내용인데 수많은 클래스를 고쳐야 한다거나 IOS 에서는 쉽지만 Android 에서는 구현 복잡도가 큰 구현 사항이 넘어올 때가 있다. 모든 요구사항을 다 처리해주는 슈퍼 개발자가 되고 싶지만… 아직 그럴 실력도 안되고 개발 기간도 제한되어 있기 때문에 결국 설득을 위한 커뮤니케이션을 피할 수 없었다. </p>
<p>복잡한 내부 히스토리와 예외 상황이 존재하기는 하나, 기본적으로 내 전략은 다음과 같았다.</p>
<ul>
<li>개발과 관련된 내용을 배제하고 최대한 이해하기 쉽게 상황과 이유를 설명한다.</li>
<li>구현하지 못하는 내용에 대한 대체 옵션을 제시한다.</li>
</ul>
<p>전략을 실제 대화로 구성하면 다음과 같다.</p>
<p>“A 스펙은 비슷한 행동을 수행하는 다른 화면에도 영향이 가기 때문에 이번 버전에 일괄적으로 적용하기는 조금 어려울 것 같아요. 다만, 범위를 B 까지만 한다면 가능할 것 같은데 이렇게 진행하는 것은 어떨 까요?”</p>
<p>결국 개발팀에서는 할 수 없는 나름의 이유가 있고, 다른팀에서는 해야하는 나름의 이유가 있기 때문에 무조건 받아줄수도, 무조건 거절할 수 도 없기 때문에 위와 같은 절충안을 생각했다. 그리 어려운 방식은 아니였지만 설득의 성공률은 굉장했다!</p>
<h1 id="개발-외"><a href="#개발-외" class="headerlink" title="개발 외"></a>개발 외</h1><h2 id="운동은-장기-레이스로"><a href="#운동은-장기-레이스로" class="headerlink" title="운동은 장기 레이스로"></a>운동은 장기 레이스로</h2><p>주짓수에 본격적으로 재미를 붙히기 시작했을 때, 대회에 출전하여 수상해보고 싶은 욕심이 생겼다. 준비 기간이 짧아 몸의 신호를 무시하고 무리하게 운동을 진행했는데 결국 출전 직전에 큰 부상을 겪게 되었다. 손목에 힘을 주기 어려울 만큼 통증이 심해서 주짓수는 물론이고 운동 자체를 몇 달간 쉬게 되었다. 운동을 못하니 체력이 급속도로 떨어지고, 스트레스 해소가 되지않아 멘탈에도 많은 영향을 주었다. </p>
<p>다행히 지금은 많이 회복되어 퇴근 후 가볍게 헬스를 하고 있다. 운동을 다시 시작하니 점차 몸의 활력이 돌아옴을 느낀다. 결국 운동은 죽기 전까지 꾸준히 필요하다. 지치지 않는 장기 레이스를 잘 수행할 수 있도록 적절한 페이스 조절이 필요함을 실감했다.</p>
<h2 id="의도적인-휴식과-충전"><a href="#의도적인-휴식과-충전" class="headerlink" title="의도적인 휴식과 충전"></a>의도적인 휴식과 충전</h2><p>학습과 성장에 대한 열망을 넘어 강박 수준까지 가다보니 기습적으로 찾아오는 무기력함과 매너리즘에 속절없이 당했던 순간이 많았다. 이를 방지하기 위해 의도적으로 쉬면서 재충전하는 시간을 만들려고 노력했는데 아, 의도적으로 쉬려고 하는 것도 참 쉽지 않음을 느꼈다. 특히, 하고싶은 것을 하면서 보내는 시간 자체가 계속해서 뒤쳐지고 있다는 느낌이 들어서 이를 떨쳐 내는 것이 쉽지 않았다.</p>
<p>그래도 의식적으로 노력하여 시간을 제법 확보 했고, 나름 알차게 사용했다고 생각된다. 특히 올 하반기에는 경제와 관련된 많은 책을 읽으며 새로운 분야로 발을 내딛는 재미를 느꼈고, 비슷한 관심사를 가진 사람들이 모인 독서 모임을 신청하여 다양한 사람들의 삶을 엿보는 시간도 가지게 되었다. 운동도 이러한 시간의 연장선이라고 볼 수 있다. </p>
<p>무엇을 하든 유연하게 균형을 맞추는 일이 참 중요하다고 생각한다. 너무 뻣뻣하면 부러지기 쉽다.</p>
]]></content>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>[후기] Next Step - 클린코드를 위한 TDD, 리팩토링 with Java 과정을 마무리 하며</title>
    <url>/2019/11/23/nextstep-class-review/</url>
    <content><![CDATA[<h1 id="코드에-대한-고민-Next-Step"><a href="#코드에-대한-고민-Next-Step" class="headerlink" title="코드에 대한 고민, Next  Step"></a>코드에 대한 고민, Next  Step</h1><p>이직 후, 오랜 기간 서비스된 앱을 개발하게 되면서 가장 자주 들었던 생각이 있다.</p>
<blockquote>
<p>아, 이건 레거시 구조 때문에 더이상 건드리기가 어렵다.</p>
</blockquote>
<p>사실 이미 존재하는 레거시 코드를 탓하는 것은 큰 의미가 없다. 중요한 것은 앞으로 내가 작성하는 코드 역시 이러한 레거시 코드가 될 수 있다는 것이었다. 그래서 최근부터 유지 보수하기 쉬운 코드란 무엇인지, 레거시는 왜 관리하기가 어려운지 고민하기 시작했고, 관련된 내용의 글과 책을 찾아보며 나름의 결론을 내고자 했었다.</p>
<p>그러던 중 우연히 한 개발자의 글을 통해, 내가 고민하고 있는 포인트와 비슷한 내용을 다룬 강의가 있다는 것을 알게 되었고 그것이 바로 Next Step 의 강의 였다. 소개된 커리큘럼과 진행 방식을 보며, 투자할 가치가 있다고 생각되었고 바로 수강 신청을 했다.</p>
<h1 id="의도적인-수련을-통한-학습"><a href="#의도적인-수련을-통한-학습" class="headerlink" title="의도적인 수련을 통한 학습"></a>의도적인 수련을 통한 학습</h1><p>최근 읽었던 책에서 <strong>의도적 수련</strong> 이라는 개념을 이야기하는 부분이 있었다. 내용의 핵심은, 매일 어떠한 일을 반복하더라도 이를 의도적으로 분석하고 개선하고자 하는 노력이 없으면 실력이 늘지 않는다는 것이다. 우리가 양치질을 매일 반복한다고 양치질의 전문가가 되지 않는 것처럼 말이다.</p>
<p>그리고 Next Step 의 독특한 수업 진행 방식은 이러한 의도적 수련을 지속적으로 할 수 있도록 도와주는 형태로 이루어져 있었다.</p>
<p>수업은 다음과 같은 루틴으로 반복된다.</p>
<ol>
<li>주 1회 TDD, Clean Code, Refactoring 에 대한 오프라인 강의가 이루어 진다.</li>
<li>배운 개념을 바탕으로 해당 주차의 과제를 수행한다. </li>
<li>과제는 단계별로 이루어져 있으며 각 단계의 요구사항을 모두 구현하면 PR 을 보내, 담당 리뷰어에게 피드백을 받는다.</li>
<li>모든 단계의 피드백을 반영하면 해당 과제가 마무리 된다.</li>
<li>1-4 의 과정 반복</li>
</ol>
<p>일반적인 강의와 가장 큰 차이점은 <strong>구현한 코드에 대한 리뷰를 받는 과정</strong>이 있다는 것이다. </p>
<p>매번 각 과제의 단계마다 구현한 내용에 대하여 피드백을 받는다. 이때 피드백은 문제의 해답이 아니라 방향성만 제시 해주기 때문에, 스스로 생각해보고 각각의 결정에 대한 트레이드 오프를 고려하는 시간을 만들어준다. 또한 다소 추상적일 수 있는 수업 내용을 실제 코드에서 적용해 나가는 과정에서 제대로 개념을 이해하고 넘어갈 수 있었다.<br><img src="/images/next-step-review/feedback.png" alt></p>
<p>(피드백만 잘 반영해 나가도, 어느샌가 자연스럽게 클린 코드를 바탕으로 리펙토링하고 있는 자신을 발견할 수 있다.)</p>
<h1 id="기억에-남는-수업-내용"><a href="#기억에-남는-수업-내용" class="headerlink" title="기억에 남는 수업 내용"></a>기억에 남는 수업 내용</h1><p>수업 내용 중 기억에 많이 남았던 부분을 정리하고 이에 대한 생각들의 정리이다. (수업 내용의 일부는 미리 허락을 받고 적었다.)</p>
<h2 id="클린코드를-지향해야-하는-이유"><a href="#클린코드를-지향해야-하는-이유" class="headerlink" title="클린코드를 지향해야 하는 이유"></a>클린코드를 지향해야 하는 이유</h2><p>우리가 클린코드를 지향 해야하는 이유는 무엇일까? </p>
<p>이 물음은 인간은 완벽하지 않다는 개념에서 출발한다. 코드를 짠 순간은 빈틈이 없어 보이지만, 시간이 지날수록 스스로도 과거의 자신을 이해하지 못하며 관리하기 어려운 코드가 되어 버린다. 왜냐하면 인간 역시 스스로 계속 변화하는 변수이기 때문이다. 따라서 코드를 짜는 개발자를 믿을 수 없다. 믿어서는 안된다. <strong>우리는 지킬 수 있는 약속을 만들고, 이 약속을 믿어야 한다</strong>.</p>
<p>모두가 약속에 기반하여 코드를 짜면, 설령 시간이 흘러 사람이 변했더라도 약속을 상기시키며 수월하게 관리하고 변경할 수 있다. 클린코드는 그러한 약속들이라고 생각할 수 있다.</p>
<p>→ 너무나 공감되는 대목이었다. 코딩의 신의 강림한듯한 날에 마무리한 후 엄청난 뿌듯함을 가지고 퇴근을 했는데, 며칠 뒤에 다시 보니 너무나 복잡도가 높아 이해하기가 어려워 결국 바닥부터 다시 짰던 경험이 있다. 같은 맥락에서 팀 차원의 공용 컨벤션이나 아키텍처 구조 등을 가이드로 정하고 이를 지키려는 노력들이 중요하다고 생각한다.</p>
<h2 id="Out-→-In-vs-In-→-Out-처음부터-완벽한-코드는-없다"><a href="#Out-→-In-vs-In-→-Out-처음부터-완벽한-코드는-없다" class="headerlink" title="Out → In vs  In → Out : 처음부터 완벽한 코드는 없다"></a>Out → In vs  In → Out : 처음부터 완벽한 코드는 없다</h2><p>어떠한 도메인에 대한 구현을 하게 될 때 우리는 다음과 같은 접근 방식 중 하나를 선택하여 구현을 할 수 있다. </p>
<p><strong>Out → In 방식</strong></p>
<ul>
<li>도메인의 요구사항을 충족할 수 있을 정도로만 빠르게 구현한다.</li>
<li>하나의 객체가 많은 역할을 수행하고 있을 수 있다.</li>
<li>도메인 지식이 없거나 요구사항 복잡도가 높은 경우 적합하다.</li>
</ul>
<p><strong>In → Out 방식</strong></p>
<ul>
<li>도메인을 가장 단위의 객체부터 나누어 기능을 구현하고, 이를 확장해 나간다.</li>
<li>각 객체가 수행하는 역할이 작고 명확해진다.</li>
<li>도메인 지식이 있거나 요구사항이 단순한 경우 적합하다.</li>
</ul>
<p>→ 이 내용의 핵심은 어떤 방식이 더 낫다는 것이 아니라 상황에 맞게 적절하게 선택해야 한다는 것이다. 나의 경우 이러한 사실을 일찍 깨닫지 못하고, Out → In 방식이 클린 코드의 규칙들을 지키지 못하는 것 같다는 느낌이 들어서 새로운 도메인이 주어진 과제를 시작부터 In → Out 방식으로 접근했었다. 처음에는 작은 레벨 부터 객체를 확장시켜 나가면서 도메인의 요구사항을 충족하는게 어렵지 않았다. 그러나 점점 스펙이 추가 될 수록, 좋지 않는 냄새가 나는 코드가 되어져 갔다. (어? 굉장히 익숙한 상황 아닌가?) 왜냐하면 도메인 지식이 충분하지 않기 때문에 설계 과정에서 놓치는 점들이 많았기 때문이다.  결국 몇 번의 갈아엎음을 반복하면서 도메인 지식이 충분히 쌓인 후에야, 새로운 스펙이 추가 됐을 때 In - Out 방식으로 구현이 가능 해지기 시작했다. </p>
<p>프로그래밍의 대부분이 그런 것 같다. 모든 상황에 절대적으로 적용할 수 있는 만능 키는 없다고 본다. 다만, 각각의 선택에 대한 트레이드 오프를 인지하고 있고, 그것을 토대로 상황에 맞게 선택하는 지혜가 필요하다.</p>
<h2 id="팀내에서-어떻게-도입할-것인가"><a href="#팀내에서-어떻게-도입할-것인가" class="headerlink" title="팀내에서 어떻게 도입할 것인가?"></a>팀내에서 어떻게 도입할 것인가?</h2><p>수업 내용을 듣더라도 당장 내일부터 팀에 적용하는 것은 무리가 있을 수 있다. 우리는 어떤 전략을 취해야 하는가?</p>
<p>사람은 감성적인 측면이 더 강하기 때문에 이성적, 논리적으로 제안하는 것보다 친분관계를 쌓고 실력에 대한 신뢰 형성 후 얘기를 나누어 보는 것이 더 승산이 있다.</p>
<p>우선은 내가 맡은 코드부터 바꿔보는 작은 시도를 하고 성공하는 경험을 느낀다. 그렇게 작은 시도와 성공을 반복하며 범위를 넓혀 가다가 관심이 보이는 동료가 있으면 같이 이야기를 나누며 전파하고, 팀원 전체에게 전파해 나간다. 만약 이러한 과정이 실패하더라도 내 성장이 따라오기 때문에 잃는 것은 없다. 시도해 볼만한 싸움이다.</p>
<p>→ 감성적인 측면으로 접근한다는 새로운 관점의 설득 방식이 기억에 남았다. 실제로 강력한 논리로 무장한 의견을 제시 하더라도 잘 받아 들여지지 않는 반면, 친하고 신뢰가 있는 동료의 몇 마디에 통과가 되는 상황을 본적이 있다. 전략을 성공시키기 위해서는 다양한 무기를 활용할 필요가 있다. 좋은 무기 중 하나가 되지 않을까?</p>
<h1 id="강의를-듣기-전에…"><a href="#강의를-듣기-전에…" class="headerlink" title="강의를 듣기 전에…"></a>강의를 듣기 전에…</h1><p>내가 강의를 듣기 전에 궁금 했었던 부분의 정리이다. </p>
<p><strong>클라이언트 개발자가 들어도 될까?</strong></p>
<ul>
<li><p>결론적으로는 들어도 된다. 100% 자바 베이스로 [TDD, Refactoring, Clean Code] 에 대한 내용을 학습하는 것이기 때문에 개발 스택에 상관없이 내용을 따라갈 수 있다. 나는 처음 OT 시간에, 주변에 전부 백엔드 개발자분들만 계서서 수강대상이 아닌줄 알고 혼란에 빠졌던 기억이 난다.</p>
<p>  추가로 나는 처음 과제 진행을 할 때 기존에 익숙한 Android 스타일로 단계를 진행하다가, 관련된 피드백을 참조하여 익숙한 스타일을 깨고 다른 식으로 접근 해보기 위해 노력 했었다.</p>
</li>
</ul>
<p><strong>먼저 선수 과정으로 공부해야할 것이 있을까?</strong></p>
<ul>
<li>git, java 가 익숙하지 않은 사람은 기본적인 개념을 익히고 가면 좋다. 물론 각 과정에서 git, java 를 깊게 다루는 것은 아니기 때문에 진행하면서 같이 익혀도 상관은 없으나, 그만큼 초반에 더 많은 시간을 투자해야한다는 것을 염두해두자.</li>
<li>객체지향의 오해와 진실, 이펙티브 자바, 클린 코드 등의 책을 읽고 가면 좀 더 빠른 이해와 과제 진행이 되지 않을까 싶다. 그러나 권장 사항일뿐 필수는 아니다.</li>
</ul>
<p><strong>정말 직장 다니면서 할 수 있을까?</strong></p>
<ul>
<li><p>할 수 있다. 그런데 각오는 해야 한다. 퇴근 후에 지친 상태에서 과제를 진행 하는게 쉽지 않다. 하루종일 코드를 봤는데, 또 코드를 봐야 한다는 압박감도 찾아온다.</p>
<p>  또한 뒤로 갈수록 난이도가 올라가기 때문에, 점점 더 많은 시간의 투자가 요구된다. 평일과 주말을 가리지 않고 적지않은 시간을 투자 했는데, 갈수록 한주 내에 과제를 마무리하는 것이 쉽지 않았다. (글을 쓰는 이 시점에도 아직 마무리하지 못한 과제가 남아있다. 😂)</p>
<p>  물론 과제에 대한 마감 기한이 없고, 하나의 과제라도 확실히 내 것으로 가져가는 것이 중요하다고 하셨기 때문에 너무 무리해서 과제를 진행할 필요는 없다.</p>
<p>  나 같은 경우 지속적으로 하기 위해 일종의 보상 체계를 구축 했는데, 퇴근 후 딱 한시간 만 온전히 내가 하고 싶은 것을 하고 자기 전까지 과제를 진행하는 방법이었다. 효과는 굉장했다!</p>
</li>
</ul>
<p><strong>야근이나, 개인적인 사정으로 강의를 못듣게 되면 어떡하나?</strong></p>
<ul>
<li>다음 기수에서도 똑같을지 모르겠으나, 내가 수강했던 기간에는 매번 강의가 끝난 후 촬영된 영상이 제공되었다. 또한 슬랙 DM 으로 언제든 궁금한 것을 물어볼 수 있기 때문에 갑작스러운 야근이나, 개인 사정으로 듣지 못하더라도 크게 걱정할 필요는 없다.</li>
</ul>
<h1 id="마무리-하며"><a href="#마무리-하며" class="headerlink" title="마무리 하며"></a>마무리 하며</h1><p>이 수업 과정을 마쳤다고 해서 TDD, Clean Code, Refactoring 의 종착점에 도달했다고 얘기할 수는 없다. 오히려 이제 시작이라고, 나아가야 한다고, 출발선에 세워 주는 느낌이다. 달려가는 과정 속에서는 분명히 많은 어려움이 따라오겠지만 이제라도 올바른 레이스를 시작할 수 있게 된 것에 감사함을 느낀다.  글을 마무리하고, 미처 끝내지 못한 과제를 하러 다시 달려야겠다. 🤟</p>
<p>항상 열정적으로 강의를 진행해주신 재성님, 매번 디테일한 리뷰와 함께 함께 고민을 나누어 주셨던 리뷰어분들께 감사드린다.</p>
<p><strong>link :</strong> <a href="https://edu.nextstep.camp/" target="_blank" rel="noopener">https://edu.nextstep.camp/</a> </p>
<p>다음 기수의 강의가 열리기 전에 미리 대기 신청을 할 수 있으므로, 관심이 있으면 클릭!</p>
]]></content>
      <tags>
        <tag>Review</tag>
        <tag>TDD</tag>
        <tag>Clean Code</tag>
        <tag>Refactoring</tag>
      </tags>
  </entry>
  <entry>
    <title>[git] squash merge 된 branch 를 rebase 할 때 생기는 이슈 - onto 옵션의 활용</title>
    <url>/2019/11/03/git-rebase-onto/</url>
    <content><![CDATA[<h1 id="문제-상황"><a href="#문제-상황" class="headerlink" title="문제 상황"></a>문제 상황</h1><p><strong>1.초기 브랜치 상황</strong></p>
<pre><code>// master
A

// old_feature
A - B - C - D

// new_feature (dependent old feature)
A - B - C - D - E - F - G - H</code></pre><p><strong>2. squash merge</strong></p>
<p>이후 old_feature 가 squash merge 로 master 에 반영되었다.</p>
<pre><code>// master
A - X</code></pre><p><strong>3. conflict 발생</strong></p>
<p>new_feature 작업이 마무리된 후, 변경된 master 를 기준으로 rebase 하여 PR 을 날리려고 시도하였다. </p>
<p><strong>기대한 브랜치</strong></p>
<pre><code>// new_feature (rebase from master)
A - X - E&apos; - F&apos; - G&apos; - H&apos;</code></pre><p>그런데 conflict 가 발생하면서 old_feature 의 커밋 ‘A - D’ 를 순차적으로 resolve 처리해야하는 상황이 발생했다. <strong>master 의 커밋 ‘X’ 에 이미 old_feature 브랜치의 변경사항이 모두 반영되어 있는데</strong>, 왜 이런 일이 발생하는 것일까?  </p>
<h1 id="원인"><a href="#원인" class="headerlink" title="원인"></a>원인</h1><p>원인을 알아보기 위해  Rebase 가 진행되는 과정을 살펴보도록 하자. </p>
<pre><code>git rebase master</code></pre><p>이렇게 아무런 옵션을 주지 않고 rebase 명령을 요청할 경우 다음과 같은 과정으로 진행된다.</p>
<ol>
<li>체크아웃 된 브랜치와 master 브랜치가 나뉘기 전인 공통의 조상 커밋으로 이동한다.</li>
<li>공통 커밋부터 체크아웃 된 브랜치의 HEAD 까지 diff를 만든다.</li>
<li>만들어진 diff 를 순차적으로 적용한다.</li>
</ol>
<p>위 과정을 베이스로 conflict 가 난 상황을 다시 재현 해보자.</p>
<ol>
<li>new_feature 를 master branch 를 통해 리베이스 한다.</li>
<li>master 와 new_feature 의 공통 커밋인 <strong>A 로 이동한다</strong>.<ul>
<li>old_feature 와 new_feature 의 공통 커밋은 D 이지만, 스쿼시 옵션으로 인해 <strong>old_feature 의 ‘B~D’ 커밋이 X로 통합 되었으므로</strong> 리베이스 과정에서는 D 를 찾을 수 없다.</li>
</ul>
</li>
<li>A 부터 new_feature 의 HEAD 까지  순차적으로 diff 를 적용한다.</li>
<li>B,C,D 의 diff 를 반영할 때 <strong>X 에는 B,C,D 의 내용이 이미 반영되어있으므로</strong> 중복된 내용에 대해 다시conflict 가 발생하고 과정이 꼬이게 된다.</li>
</ol>
<p><strong>결론</strong><br>squash 로 인해 기존의 공통 커밋이 새로운 커밋으로 통합되어 사라지게 되면서, rebase 과정에서 conflict 가 발생  </p>
<h1 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h1><p>원인은 rebase 의 기본 동작을 수행했을 때 A 커밋부터 시작되는 것이었다. 그렇다면 old_feature 가 반영된 X 커밋의  이후 커밋부터 rebase 를 수행하도록 할 수 는 없을까?</p>
<p>다행히도 <code>rebase 에서는 --onto 옵션을 제공하여 rebase 가 동작할 커밋 범위를 지정</code>할 수 있다.</p>
<pre><code>git rebase --onto master HEAD~4</code></pre><p>위와 같이 요청할 경우 rebase 는 HEAD 를 포함하여 최근 4개의 커밋 범위까지 rebase 를 수행한다. 즉, new_feature 기준으로 E - F - G - H 범위 내에서 rebase 가 수행된다. master 에는 E~H 에 대한 내용이 없으므로 conflict 발생없이 한줄로 예쁘게 rebase 가 완료된다.</p>
<p><strong>rebase 가 완료된 브랜치</strong></p>
<pre><code>// new_feature
A - X - E&apos; - F&apos; - G&apos; - H&apos;</code></pre><p><strong>번외</strong></p>
<p>커밋 범위를 지정하는 것이 번거로울 경우 아래와 같은 방법으로 동일한 결과를 얻을 수 있다. </p>
<pre><code>git rebase --onto master old_feature new_feature</code></pre><p>해당 명령은 old_feature 에 존재하는 커밋을 제외하고, new_feature 에 대해 rebase 를 수행한다. 따라서 new_feature 에서, old_feature 에 있는 B-D 커밋은 제외하고, 그 뒤의 E-H 커밋에 대해서만 rebase 가 진행된다.</p>
<p>단, 해당 방법은 old_feature 가 삭제 되지 않았을 경우에만 사용이 가능하다는 제약이 있다.</p>
]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>[도서] 오브젝트 정리 Chapter 4 (캡슐화, 응집도, 결합도)</title>
    <url>/2019/10/20/object-book-4/</url>
    <content><![CDATA[<p>이번 글에서는 데이터 중심 클래스의 정의와 단점을 알아보고, 이를 해결하기 위한 방법으로 캡슐화와 응집도/결합도에 대한 완전한 이해를 얻어가는 것이 목적이다.</p>
<h1 id="데이터-중심으로-설계된-클래스"><a href="#데이터-중심으로-설계된-클래스" class="headerlink" title="데이터 중심으로 설계된 클래스"></a>데이터 중심으로 설계된 클래스</h1><p><a href="https://vagabond95.github.io/2019/10/13/object-book-1-3/" target="_blank" rel="noopener">이전글</a> 내용을 살펴보면 객체지향 애플리케이션을 구현하는 것은 각 객체가 책임을 수행하며 서로간의 협력을 통해 공동체를 구축한다는 것을 의미한다. 즉, 중요한 것은 객체가 다른 객체와 <strong>협력하는 방법</strong>이며, 각 객체가 내부에 어떤 상태를 가지고 관리하는 지에 대한 것은 부가적인 문제일 뿐이다.  </p>
<p>그러나, 우리가 일반적으로 클래스를 설계하는 과정은 어떨까? </p>
<ol>
<li>처음부터 객체간의 협력과 책임에 대해 고민하는 것은 머리아프다.</li>
<li>따라서 우선 클래스에 어떤 데이터가 들어가야할지 결정한다.</li>
<li>또한 어떤 상황에서도 객체가 사용될 수 있게 최대한 많은 getter/setter 를 추가한다.  </li>
</ol>
<p>이러한 설계방식을 <strong>데이터 중심 설계</strong> (혹자는 추측에 의한 설계전략)라고 부르며, 데이터 중심 설계는 객체의 외부가 아닌 내부에 초점을 맞추게 된다. </p>
<p>데이터 중심 클래스의 객체는 단순한 데이터의 집합일 뿐이다. 따라서 제공되는 메소드는 과도한 접근자와 수정자 뿐이며, 이 데이터를 사용하여 로직을 수행하는 일은 별도의 객체에서 수행하게 된다. 이로 인하여 객체의 인터페이스에 내부 구현이 노출되고, 인터페이스를 이용하여 협력하는 또다른 객체 역시 데이터 중심 클래스의 내부구현에 종속되게 된다. (캡슐화가 이루어지지 않음) 문제는 <strong>객체의 내부 구현은 언제든 변화가 생길 수 있다는 점</strong>이다. 따라서 데이터 중심의 설계는 변화가 발생했을 때 협력하는 모든 객체가 영향을 받게되므로 변화에 매우 취약한  설계방식 이다. </p>
<h1 id="캡슐화-응집도-결합도"><a href="#캡슐화-응집도-결합도" class="headerlink" title="캡슐화, 응집도, 결합도"></a>캡슐화, 응집도, 결합도</h1><p>좋은 객체지향 설계의 척도를 이야기할 때 빠지지 않고 등장하는 얘기들이 있다. 캡슐화가 잘되어야한다. 높은 응집도와 낮은 결합도를 가져야한다. 귀에 못박히도록 들었으나 해당 문장이 가지고 있는 진정한 의미를 이해하고 있었다고 단언할 수 있을까?</p>
<h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>캡슐화가 무엇일까? 라고 질문하면 “객체 내부 구현을 외부로부터 감추는 것이다.” 라고 쉽게 얘기할 수 있다. 구현레벨에서는 접근 제한자를 이용하여 맴버변수를 숨기고 getter/setter 를 구성하며 캡슐화가 적용된 코드라고 얘기하곤 한다.</p>
<p>안타깝게도 위 내용은 캡슐화의 본질을 온전히 이해하고 있지 못하고 있다. 캡슐화는 분명 내부구현을 외부로부터 감추는 것이 맞다. 하지만 중요한 것은 <strong>왜 감추느냐</strong>는 것이다. 위에서 얘기한 데이터 중심의 설계방식을 살펴보면 그 이유를 알 수 있다. 캡슐화를 통해 감추는 이유는 내부구현을 숨김으로 인하여 내부구현의 변화가 발생하더라도 협력하는 <strong>외부 객체에 변화의 영향이 퍼져나가지 않도록 막기 위함</strong>이다. </p>
<p>너무 당연한 얘기일까? 그렇다면 다시 질문해보자. 접근제한자로 변수를 숨기고 getter/setter 를 통해 접근 및 조작하는 것은 캡슐화가 이루어진 것이라고 할 수 있을까? 캡슐화를 한 것은 맞다. 이러한 방식을 데이터 캡슐화라고 부른다. 그러나 데이터 캡슐화만으로는 캡슐화의 목적을 달성하지 못한다. getter 가 제공된다는 것은 필연적으로 어떤 로직을 수행하기 위해 해당 데이터가 필요하다는 의미이며, 그 로직은 또다른 객체에서 수행될 수 밖에없다. 그리고 만약 getter 의 return type 이 바뀐다면? 또다른 객체 역시 내용을 변경할 수 밖에 없다. 이러한 케이스를 <strong>객체의 내부구현이 드러난다</strong>고 표현한다.  캡슐화의 목적은 내부구현을 숨기는 것인데, 데이터 캡슐화만으로는 내부구현이 드러나게 되는 아이러니한 상황이 발생하는 것이다. (내부구현은 return type 뿐만 아니라 parameter, method 자체 로도 드러날 수 있다.)</p>
<pre><code>// 캡슐화의 목적이 이루어지지 않은 클래스
public class Movie {
    private String title;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }
}</code></pre><p>자, 데이터를 숨기는 것만으로는 캡슐화의 목적이 달성될 수 없음을 알았다. 그렇다면 어떤 수준까지 해야할까? 책에서는 다음과 같이 얘기하고 있다.</p>
<blockquote>
<p>다시한번 강조하지만 캡슐화란 변할 수 있는 어떤 것이라도 감추는 것이다. 그것이 속성의 타입이건, 할인 정책의 종류건 상관없이 내부 구현의 변경으로 인해 외부가 객체가 영향을 받는다면 캡슐화를 위반한 것이다.</p>
</blockquote>
<p>변경될 수 있는 모든 것을 감추는 것, 그것만이 캡슐화의 목적에 다다를 수 있다. 그리고 이러한 규칙은 협력을 잘 구성하고 책임을 스스로 수행할 수 있도록 구성하면 자연스레 지켜지게 된다. 즉 캡슐화를 하기 위해 일련의 작업들을 수행하는 것이 아니라, 객체지향 프로그래밍의 규칙을 지키다보면 자연스럽게 캡슐화가 보장되어가는 형태가 된다.</p>
<p>그래도 역시 이해하기에 모호한 부분이 있다. 그래서 캡슐화가 잘 되었는지 파악할 수 있는 기준들을 소개하고자 한다.</p>
<h2 id="응집도와-결합도"><a href="#응집도와-결합도" class="headerlink" title="응집도와 결합도"></a>응집도와 결합도</h2><p>응집도와 결합도는 소프트웨어품질을 측정하기 위한 기준이지만 캡슐화의 정도를 측정할때도 유용하게 활용될 수 있다. 객체지향 관점에서 각 개념은 다음과 같이 풀어내고 있다.</p>
<ul>
<li><strong>응집도</strong>는 클래스/객체에 얼마나 관련 높은 책임이 할당되었는지를 나타낸다.</li>
<li><strong>결합도</strong>는 클래스/객체가 협력에 필요한 적절한 수준의 관계만 유지하고 있는지 나타낸다.</li>
</ul>
<p>… 객체지향을 오해하기 쉬운 이유는 이러한 애매하고 추상적인 개념들을 명확하게 이해하기가 어렵기 때문이라고 생각한다.</p>
<p>처음으로 돌아가 생각해보자. 좋은 설계란 무엇인가? 변경하기 쉬운 설계이다. 그리고 높은 응집도와 낮은 결합도를 가졌을 때 우리는 좋은 설계라고 부르곤한다. 따라서 각 개념은 결국 <strong>변경</strong>과 관련이 있다는 얘기가 된다. 변경의 관점에서 다시한번 각 개념을 살펴보자.</p>
<p>어플리케이션에 여러 모듈(객체)가 있을 때</p>
<ul>
<li><p><strong>(변경의 관점에서) 응집도</strong>는 변경이 발생했을 때 어플리케이션내에서 변경이 발생하는 정도를 의미한다. 예를들어 특정 기능에 대한 변경이 있을때 대해 하나의 모듈만 변경된다면 응집도가 높고, 다수의 모듈이 함께 변경돼야하면 응집도가 낮다고 할 수 있다.</p>
<p>  응집도가 낮다면 하나의 변경점에 대해 다수 모듈의 변경이 동반되기 때문에 변경에 부담이 생기기 시작한다.</p>
</li>
<li><p><strong>(변경의 관점에서) 결합도</strong>는 하나의 모듈에서 변경이 발생했을 때, 다른 모듈의 변경을 요구하는 정도를 의미한다. 예를들어 하나의 모듈을 수정했을 때 함께 변경해야하는 모듈의 수가 많을 수록 결합도가 높다고 할 수 있다.</p>
<p>  결합도가 높다면 모듈의 내부구현이 변경되었을 때 영향을 받는 모듈 수가 많으므로 변경에 부담이 생기기 시작한다.</p>
</li>
</ul>
<p>위 개념을 잘 이해했다면 왜 높은 응집도와 낮은 결합도가 충족된 것이 좋은 설계인것인지 알 수 있을 것이다.</p>
<p>위에서 살펴본 데이터 중심설계는 낮은 응집도와 높은 결합도를 가진 객체를 양산하기 쉬운 방식인데 이유는 다음과 같다.</p>
<p>응집도 개념에서 살펴보면, 객체의 클래스가 데이터를 중심으로 설계되었으므로 해당 객체의 책임은 데이터를 조작하고 내뱉는 것 그 이상도 이하도 아니다. 즉 데이터를 제공하는 객체가 스스로 일을 처리하지 못하므로, 로직을 수행하는 객체가 이를 수행하게 된다. 문제는 로직을 수행하는 객체가 또다른 데이터를 제공하는 객체를 맡기 시작할 경우 해당 객체의 책임은 점점 비대해지고 둘중 한쪽에서만 변경이 발생해도 필연적으로 같이 영향을 받게 된다. 하나의 클래스에서 변경이 발생했는데 전혀 연관이 없을 것같은 부분에서 사이드 이펙트가 발생하는 케이스가 대표적으로 각 클래스의 응집도가 낮은 상황이다.</p>
<p>결합도 개념에서 살펴보면, 마찬가지로 데이터를 제공하는 객체가 스스로 일을 처리하지 못하므로 해당 데이터를 다른 객체에서 처리하게 된다. 만약 해당 객체의 데이터가 변경될 경우 (parameter, type) 데이터를 사용하는 모든 객체에게 변화의 영향이 퍼지게 된다.</p>
<p>결국 내용을 돌아보면 다시 객체의 책임과 협력으로 귀결된다. 다음 글에서는 어떻게 객체에 책임을 잘 할당할 수 있는지에 대해 알아보자.</p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><ul>
<li>우리는 데이터 중심의 설계를 하고있었을 확률이 높다.</li>
<li>캡슐화의 진정한 목적을 항상 기억하자.</li>
<li>코드를 변경하기 어렵다면 응집도/결합도 정도를 점검해보자.</li>
<li>결국 좋은 설계란 <strong>변경하기 쉬운</strong> 설계다.</li>
</ul>
]]></content>
      <tags>
        <tag>OOP</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>[도서] 오브젝트 정리 Chapter 1 - 3</title>
    <url>/2019/10/13/object-book-1-3/</url>
    <content><![CDATA[<p>변경은 언제든 찾아올 수 있다. 변경은 피할 수 없다. 이러한 사실을 깨달은 사람들은 변경에 유연하게 대응할 수 있는 방법을 고민해왔고 이에 다영한 해결법이 제시되었다. 이번에 다루게 될 객체지향 프로그래밍도 그 중 하나라고 할 수 있다. </p>
<p>객체지향 프로그래밍. 익숙하지만 제대로 이해하고 활용하고 있다고 얘기하기는 어려운 그런 녀석이었다. Java 를 사용하면 객체지향일까? 클래스 개념을 활용하면 객체지향일까? 안타깝게도 Java 내에서 class 를 사용해도 얼마든지 절차지향적인 코드가 나올 수 있고, 실제로도 그런 코드를 많이 양산해왔다. 객체지향적인 설계에 대한 고민이 깊어질때 즘 ‘객체지향의 사실과 오해’ 책으로 알게된 조영호님의 신간이 나왔음을 들었고 ‘오브젝트’ 책을 읽기 시작했다. 이번 포스팅은 챕터 1 ~ 3 을 읽고 정리하는 내용으로 채웠다.</p>
<h1 id="객체간의-협력과-책임-설계-레벨"><a href="#객체간의-협력과-책임-설계-레벨" class="headerlink" title="객체간의 협력과 책임 (설계 레벨)"></a>객체간의 협력과 책임 (설계 레벨)</h1><blockquote>
<p>OOP 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.</p>
</blockquote>
<h2 id="잘못된-방식"><a href="#잘못된-방식" class="headerlink" title="잘못된 방식"></a>잘못된 방식</h2><p>OOP 를 막 입문하면 가장 흔하게 하는 실수가 객체의 행동이 아닌 상태에 초점을 맞추는 것이다. 객체의 상태를 먼저 결정하고, 상태에 필요한 행동을 결정한다. 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다. 또한 객체의 내부 구현은 언제든 바뀔 수 있기 때문에 결국 외부에 변화가 전파된다.</p>
<h2 id="객체지향-관점에서-객체의-구성-방식"><a href="#객체지향-관점에서-객체의-구성-방식" class="headerlink" title="객체지향 관점에서 객체의 구성 방식"></a>객체지향 관점에서 객체의 구성 방식</h2><p>→ 객체는 어떤 협력을 참여하는가</p>
<p>→ 협력을 위해서 어떤 행동을 해야하는가</p>
<p>→ 행동하기 위해서 어떤 상태를 가져야하는가</p>
<h3 id="1-객체간의-협력과-수행해야할-책임을-파악할-것"><a href="#1-객체간의-협력과-수행해야할-책임을-파악할-것" class="headerlink" title="1. 객체간의 협력과 수행해야할 책임을 파악할 것"></a>1. 객체간의 협력과 수행해야할 책임을 파악할 것</h3><blockquote>
<p>어플리케이션안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다. 객체가 어떤 협력에 참여하고 있기 때문이다. 그리고 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문이다.</p>
</blockquote>
<p>객체가 책임을 할당하는 데 필요한 메세지를 먼저 식별하고, 메세지를 처리할 객체를 나중에 선택하는 것이 중요하다. 이런 방식으로 객체를 구성할 경우 다음과 같은 이점이 있다.</p>
<ol>
<li>객체가 최소한의 퍼블릭 인터페이스를 가질 수 있게 된다.</li>
<li>객체의 퍼블릭 인터페이스는 무엇을 하는지만 나타낼 뿐, 어떻게 수행하는지가 노출되지 않는다.</li>
</ol>
<h3 id="2-책임을-수행하기-위해-필요한-상태-및-내부-구현-정의"><a href="#2-책임을-수행하기-위해-필요한-상태-및-내부-구현-정의" class="headerlink" title="2. 책임을 수행하기 위해 필요한 상태 및 내부 구현 정의"></a>2. 책임을 수행하기 위해 필요한 상태 및 내부 구현 정의</h3><p>객체의 퍼블릭 인터페이스가 정해졌다면, 다음으로는 퍼블릭 인터페이스로 들어온 요청을 객체 스스로 처리할 수 있도록 구성해야한다. 즉, 내부 구현 및 내부 구현에 필요한 상태의 정의가 필요하다. 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다. 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문이다.</p>
<p>협력관계속에서 다른 객체에게 무엇을 제공해야 하고 다른 객체로부터 무엇을 얻어야 하는지를 고민해야만 훌륭한 책임을 수확할 수 있다.</p>
<h3 id="3-책임을-조합하여-역할을-정의"><a href="#3-책임을-조합하여-역할을-정의" class="headerlink" title="3. 책임을 조합하여 역할을 정의"></a>3. 책임을 조합하여 역할을 정의</h3><p>어느정도 객체의 책임이 정의되었다면 객체의 역할을 정의할 수 있다. 코드레벨에서는 Java 기준으로 ‘interface, abstract class 를 구현한다.’ 라고도 얘기할 수 있다. 객체의 역할을 정의해주는 것이 중요한 이유는 동일한 협력을 수행하는 객체들을 추상화할 수 있기 때문이다. 협력관계가 역할이라는 추상화된 형태로 묶일 경우 당연히 변화에도 대응하기 쉬워진다. 책에서는 객체의 역할에 대해 다음과 같이 비유했다.</p>
<ul>
<li>서로 다른 배우들(객체)이 동일한 배역(역할)을 연기할 수 있다.</li>
<li>하나의 배우(객체)가 서로 다른 배역(역할)을 연기할 수 있다.</li>
</ul>
<p>협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부다. 역할은 객체의 구조나 상태에 의해 정의될 수 없으며, 시스템의 문맥 안에서 무엇을 하는지에 의해서만 정의될 수 있음을 주의해야한다. </p>
<p>번외로, 오직 한 종류의 객체만 협력에 참여하는 상황에서 역할이라는 개념을 고려하는 것이 유용할까? 역할이라는 개념을 생략하고 직접 객체를 이용해 협력을 설계하는 것이 더 좋지 않을까? 라는 궁금증이 생길 수 있다. 책에서 내린 결론은 다음과 같다.</p>
<p>“협력에 적합한 책임을 수행하는 대상이 한 종류라면, 간단하게 객체를 이용하면 된다. 만약 여러 종류의 객체가 협력에 이용될 수 있다면 협력의 대상은 역할이 될 것이다.</p>
<p><strong>하지만 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 하고 역할과 객체를 명확하게 구분하는 것은 그렇게 중요하지는 않다는 것이다.</strong>“</p>
<p>즉, 상황에 맞게 역할(추상화된 형태) 혹은 객체 (구체적인 형태)를 잘 선택해서 사용하되, 어차피 바뀔 수 있는 내용이므로 설계 초기에는 크게 신경쓰지 않아도 된다고 이야기 하고 있다.</p>
<h1 id="객체-지향-구현-기법-구현-레벨"><a href="#객체-지향-구현-기법-구현-레벨" class="headerlink" title="객체 지향 구현 기법 (구현 레벨)"></a>객체 지향 구현 기법 (구현 레벨)</h1><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>클래스를 구현하거나 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다. 데이터와 기능을 객체 내부로 함께 묶는 것을 <strong>캡슐화</strong>라고 한다.캡슐화 된 객체는 상태는 숨기고 행동만 public 인터페이스로 공개한다.</p>
<p>객체의 외부와 내부를 구분하면 클래스를 사용하는 입장에서 알아야할 지식의 양이 줄어들고, 클래스 구현자는 내부 구현을 변경할 수 있는 폭이 넓어진다.</p>
<h2 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h2><p>객체를 추상화된 형태로 제공할 수 있다. 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문이다. (구체적인 상황은 항상 변경된다.) </p>
<p>주의할 점은 다형성을 이용하여 설계를 유연하게 가져갈수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다. 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.</p>
<h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>상속이 가치있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. (다형성 - 업캐스팅의 활용)</p>
<p>주의할 점으로 상속은 객체지향 프로그래밍에서 코드를 재사용하기 위해 널리 사용되는 되지만 두가지 관점에서 설계에 안좋은 영향을 미친다. (이펙티브 자바에서도 동일한 내용의 챕터가 존재한다.) ****</p>
<p>구현의 재사용성으로 이용된 상속은 변경에 취약하고, 부모클래스의 캡슐화를 깨기때문에 지양해야한다. 따라서 상속의 사용 목적은 구현의 재사용보다 인터페이스를 재사용하는 것에 초점을 맞춰야 한다. </p>
<p>하지만 실제 개발시에는 상속을 통해 내부 구현을 재사용해야할 일이 생기기 마련이다. 따라서 상황에 맞게 적절히 활용하는 지혜가 요구된다.</p>
<p>상황별로 권장되는 방법은 다음과 같다.</p>
<ul>
<li>구현내용 재사용 X, 다형성 활용 O : interface (Java)</li>
<li>구현내용 재사용 O, 다형성 활용 O : abstract class (Java)</li>
<li>구현내용 재사용 O, 다형성 활용 X : composition (디자인 패턴)</li>
</ul>
<h1 id="설계의-트레이드-오프"><a href="#설계의-트레이드-오프" class="headerlink" title="설계의 트레이드 오프"></a>설계의 트레이드 오프</h1><ul>
<li>어떤 기능을 설계하는 방법은 한가지 이상일 수 있다.</li>
<li>동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이트 오프의 산물이다. 어떤 경우에도 모든 상황을 만족시킬 수 있는 설계를 만들 수는 없다.</li>
</ul>
<p>구현과 관련된 모든 것들이 트레이드 오프의 대상이 될 수 있다. 작성하는 모든 코드에는 합당한 이유가 있어야 한다. 비록 아주 사소한 결정이더라도 트레이드 오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.</p>
]]></content>
      <tags>
        <tag>OOP</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] targetSdkVersion, compileSdkVersion, minSdkVersion 이란 무엇인가?</title>
    <url>/2019/09/20/android-api-version-manage/</url>
    <content><![CDATA[<p>보통 프로젝트를 새롭게 세팅 할경우, targetSdkVersion / compileSdkVersion / minSdkVersion 를 각각 지정할 수 있다. 세팅 이후에는 크게 건드릴 일이 없기에 평소에는 크게 신경쓰이지 않는 값이다. </p>
<p>그런데… <a href="https://developers-kr.googleblog.com/2018/01/improving-app-security-and-performance-on-google-play.html" target="_blank" rel="noopener">새로운 Google Play 방침</a> 에 따르면  <strong>play store 에 등록되어 있는 앱을 업데이트 하거나, 새로 앱을 등록 할 경우 정해진 <code>targetSdkVersion</code> 을 만족해야 한다.</strong> 평소에 어렴풋하게 의미를 알고 있었는데 항상 헷갈려서 이번 기회에 정리 해보기로 했다.</p>
<p>targetSdkVersion 뿐만 아니라 compileSdkVersion, minSdkVersion  모두 <strong>안드로이드 API 버전</strong>과 관련된 값이므로 묶어서 한번에 다룰 예정이다.</p>
<hr>
<h1 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h1><p><strong>앱이 기기에서 동작할 때 사용되는 Android API 버전을 의미한다. (런타임)</strong> 따라서 실제 앱 동작에 영향을 주게 되므로 신중히 올려야 한다. 이때 기기의 Android OS API 버전과 혼동하여 헷갈리기 쉬우므로 각 케이스별로 분리하여 살펴보자.</p>
<p>앱은 기본적으로 targetSdkVersion 에 명시된 API 버전을 기준으로 동작한다. 예외적으로 기기 OS 버전이 낮아 아직 targetSdkVersion 의 API 버전을 지원하지 않을 경우 기기 OS 버전을 따라간다.</p>
<h3 id="1-OS-version-gt-targetSdkVersion"><a href="#1-OS-version-gt-targetSdkVersion" class="headerlink" title="1.  OS version &gt; targetSdkVersion"></a>1.  OS version &gt; targetSdkVersion</h3><ul>
<li>기기의 OS 버전 : API 26</li>
<li>앱의 targetSdkVersion : API 24</li>
</ul>
<p>해당 기기는 안드로이드 API 26 에서 제공하는 기능을 <strong>모두 사용할 수 있는</strong> 기기이다. 여기서 포인트는 사용할 수 있다는 것이지, 항상 해당 버전의 기능만 사용한다는 의미가 아니라는 것이다. </p>
<p>위 사례처럼 앱이 targetSdkVersion 값을 24 로 정했을 경우, 기기는 API 26 버전에서 제공하는 기능을 사용할 수 있지만 앱은 API 24 베이스로 동작한다.</p>
<h3 id="2-OS-version-targetSdkVersion"><a href="#2-OS-version-targetSdkVersion" class="headerlink" title="2. OS version == targetSdkVersion"></a>2. OS version == targetSdkVersion</h3><ul>
<li>기기의 OS 버전 : API 26</li>
<li>앱의 targetSdkVersion : API 26</li>
</ul>
<p>이 경우는 os 와 target 이 동일하므로, 앱이 해당 기기에서 API 26 버전 베이스로 동작한다.</p>
<h3 id="3-OS-version-lt-targetSdkVersion"><a href="#3-OS-version-lt-targetSdkVersion" class="headerlink" title="3.  OS version &lt; targetSdkVersion"></a>3.  OS version &lt; targetSdkVersion</h3><ul>
<li>기기의 OS 버전 : API 26</li>
<li>앱의 targetSdkVersion : API 27</li>
</ul>
<p>이 경우는 보통 국내 제조사들의 OS 업데이트가 늦기 때문에 발생될 수 있는 상황이다.</p>
<p>앱은 기기의 OS 버전인 API 26 베이스로 동작한다. </p>
<hr>
<h1 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h1><p><strong>컴파일 시 사용되는 Android API 버전을 의미한다. (컴파일 타임)</strong> 따라서 실제 개발중 사용할 수 있는 android API 범위는 compileSdkVersion 에 의해 결정된다. compileSdkVersion  값은 가급적 최신으로 유지하기를 권장하는데, targetSdkVersion 을 변경하지 않는 한 실제 배포되는 앱에 대한 사이드 이펙트가 없기 때문이다.</p>
<p>보통 최신 API 가 나오면 compileSdkVersion 을 먼저 올려서, 최신 API에 대한 대응이 완료된 후 targetSdkVersion 을 올린다. 만약 최신 버전 API 에서 새로 생긴 기능이 있고 이를 추가할 경우 warning 을 통해 하위 버전에서는 작동하지 않으므로 분기 처리를 요구한다.</p>
<p>추가로 gradle 내에 buildToolVersion 값이 있는데, 정상적인 빌드를 위해 complieSdkVersion 을 올릴 때 같이 최신버전으로 맞춰주는 것을 권장한다.</p>
<hr>
<h1 id="잠깐-버전이-분할-되어-관리되어야-하는-이유는"><a href="#잠깐-버전이-분할-되어-관리되어야-하는-이유는" class="headerlink" title="잠깐, 버전이 분할 되어 관리되어야 하는 이유는?"></a>잠깐, 버전이 분할 되어 관리되어야 하는 이유는?</h1><p>왜 안드로이드는 이렇게 각각 별도의 버전 정책을 둔 것일까? </p>
<p>이유를 유추해보면 다음과 같다. API 버전이 올라가면 Deprecated 되거나, 새롭게 추가된 것이 존재할 것이다. 이때 기기 os 버전을 기준으로 앱이 실행되도록 하면, 해당 버전이 대응이 안되어있던 앱들은 전부다 의도하지 않은 동작이 발생할 수 있다. 따라서 <strong>개발자들에게 앱이 컴파일타임과 런타임에 영향받는 API 버전을 각각 관리할 수 있도록 하여 위와 같은 문제를 예방</strong>하도록 하도록 한다.</p>
<p>최근에는 google 에서 많은 앱들이 targetSdkVersion 을 올리지 않아, 자신들이 의도한만큼 업데이트가 잘 반영되지 않고 이에 따라 좋지않은 사례들이 나오고 있음을 깨달았다. (최신 API는 당연히 이전 버전에서 문제가 되었거나 개선되어야할 점을 반영한 것이기 때문에 이전 API 보다 좋을 수 밖에 없고 빠르게 적용해주는 것이 좋다.) 이에 대한 대책으로 2018년 8월 이후로 target 을 구글이 명시한 최신버전으로 맞추지 않으면 playstore 에 업로드 및 업데이트를 할 수 없는 정책을 추가했다.</p>
<p>새로운 API가 나왔지만 아직 대응하기 어려울 경우, target 을 올리지만 않으면 된다. 하지만 되도록 최신버전은 바로 대응해주는 것이 일정관리 및 정신건강에 이롭다고 느낀다.</p>
<hr>
<h1 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h1><p>해당 앱을 구동할 수 있는 <strong>최소 커트라인</strong>이라고 이해하면 쉽다. 플랫폼의 OS 버전이 minSdkVersion 보다 낮을경우 앱이 설치되지 않는다.</p>
<hr>
<h1 id="API-버전-분기-처리와-SupportLibrary"><a href="#API-버전-분기-처리와-SupportLibrary" class="headerlink" title="API 버전 분기 처리와 SupportLibrary"></a>API 버전 분기 처리와 SupportLibrary</h1><p>우리는 사용자의 플랫폼이 어떤 버전을 사용하는지 미리 알 수 없기 때문에 버전별 API 변경 사항에 맞게 사용할 수 있도록 분기 처리를 해주어야 한다. </p>
<p>실제로 AndroidStudio 에서도 분기처리가 필요한 기능을 그냥 사용할 경우 warning 을 통해 알려주게 되는데 무시하고 진행해도 빌드는 정상적으로 되지만, 추후에 배포됐을 때 사용자 기기의 OS 버전에 따라 크래시가 발생할 수 있다.</p>
<h2 id="애증의-minSdkVersion"><a href="#애증의-minSdkVersion" class="headerlink" title="애증의 minSdkVersion"></a>애증의 minSdkVersion</h2><p>분기 처리를 해야하는 버전의 범위는 minSdkVersion 을 기준으로 체크한다. minSdkVersion 은 앱이 구동될 수 있는 최소 요구 버전이므로, minSdkVersion 이 낮을수록 개발 시 대응해야 하는 버전이 많고, 높을수록 대응해야 하는 버전이 적다. 다양한 버전 대응을 위한 분기 처리가 많아질 수록 관리포인트가 늘어나고, 가독성도 떨어지게 되어 점점 보기 싫어지는 코드가 된다..</p>
<p>특히 알림 기능(Notification) 의 경우 특정 버전 이상에서만 되는 기능들이 굉장히 많은데 이를 모두 분기 처리하다보면 실제 로직을 파악하기 쉽지 않다. </p>
<p>개발자 입장에서는 minSdkVersion 값이 높을 수록 대응할 버전이 줄어드로 피로도가 적으므로, 앱의 minSdkVersion 이 높은 것이 회사 복지라는 우스갯소리도 있다. (우리도 조금만 더 올렸으면 좋겠다..)</p>
<p>그래도 보통 최대한 많은 고객에게 앱을 제공하기 위해 대부분 회사는 커버러지 99.8% ~ 99.9% 에 포함되는 버전까지는 대응하는 것으로 알고 있다.</p>
<h2 id="SupportLibrary"><a href="#SupportLibrary" class="headerlink" title="SupportLibrary"></a>SupportLibrary</h2><p>위에서 살펴본 것 처럼 하위 호환성을 유지하기 위한 분기문으로 인해, 점점 코드의 가독성이 떨어지는 상황을 필연적으로 맞이하게 된다. 안드로이드에서는 다음 문제를 해결하기 위해 <a href="https://developer.android.com/topic/libraries/support-library" target="_blank" rel="noopener">SupportLibrary</a> 라는 대안을 내놓게 되었다.</p>
<p>서포트 라이브러리는 내부적으로 버전에 대한 분기 처리가 되어있어, 별도의 추가 작업없이 바로 기능을 수행하는 코드를 작성하면 된다.</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] 키보드 높이 구하기</title>
    <url>/2019/09/08/android-keyboard-height/</url>
    <content><![CDATA[<p><img src="/images/cover/android-keyboard-height-cover.jpg" alt><br>Android 개발을 진행하다보면 Keyboard Height 를 알고싶은 상황을 마주할 때가 있다. 하지만 안타깝게도 <strong>Android에서 Keyboard Height 를 알 수 있는 native API 는 제공되지 않는다.</strong>  따라서 약간의 편법(?)을 통해 값을 알아내야 하는데, 오늘 포스팅에서는 그 과정을 다뤄보려 한다.</p>
<h1 id="원리"><a href="#원리" class="headerlink" title="원리"></a>원리</h1><p>Keyboard height 를 구하는 방법에 대한 다양한 접근법이 제시되고 있으나, 결국 핵심원리는 다음과 같다.</p>
<ol>
<li>키보드가 없을 때 화면 전체의 높이를 구한다.</li>
<li>Keyboard 가 올라왔을 때, Keyboard 가 가리고 있는 부분을 제외한 화면의 높이를 구한다.</li>
<li>1번 값 - 2번 값 = Keyboard Height</li>
</ol>
<h1 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h1><p>화면이라는 단어는 자체는 매우 추상적이다. 위 원리의 핵심은 화면의 높이를 구하는 것이므로 코드 레벨의 사전 정의가 필요해보인다.<br>해당 포스트에서는 안드로이드에서 제공하고 있는 <a href="https://developer.android.com/reference/android/view/View" target="_blank" rel="noopener">View</a> 클래스를 화면으로 정의했다. 그 이유는 높이를 구하는 과정에서 활용할 수 있는 API 가 모두 View 에서 제공되기 때문이다.</p>
<hr>
<h2 id="1-화면의-높이를-구한다"><a href="#1-화면의-높이를-구한다" class="headerlink" title="1. 화면의 높이를 구한다."></a>1. 화면의 높이를 구한다.</h2><p>View 는 getHeight() 메소드를 제공하기 때문에, 높이를 알아는 것이 어렵지 않다. 문제는 getHeight() 를 통해 얻어온 높이가 해당 View 의 정확한 높이라고 보장할 수 없다. 왜냐하면 View 의 높이는 초기화되자마자 결정되는 것이 아니라 일련의 측정 단계를 거쳐 결정이 되는데, 그 단계가 끝나기 전에 getHeight() 를 호출했을수도 있기 때문이다.</p>
<p>따라서 정확한 View 의 높이를 알기 위해서는 View 의 크기가 결정된 이후에 getHeight() 를 호출해야 한다.<br>View 에서 제공하는 <a href="https://developer.android.com/reference/android/view/ViewTreeObserver.OnGlobalLayoutListener" target="_blank" rel="noopener">ViewTreeObserver.OnGlobalLayoutListener</a> 를 이용하면 결정되는 타이밍을 캐치할 수 있다. </p>
<p>OnGlobalLayoutListener 는 해당 View에 변경점이 생겼을 때, 이를 콜백형태로 감지할 수 있다. 변경되는 내용에는 View 의 크기가 결정되는 것도 포함되므로 우리는 해당 콜백이 호출되었을 때 View.getHeight() 를 호출하면 정확한 높이를 얻을 수 있다.</p>
<p>코드 레벨로는 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> viewHeight = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">rootView.getViewTreeObserver().addOnGlobalLayoutListener(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> currentViewHeight = rootView.getHeight();</span><br><span class="line">    <span class="keyword">if</span> (currentViewHeight &gt; viewHeight) &#123;</span><br><span class="line">        viewHeight = currentViewHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-Keyboard-가-올라왔을-때-Keyboard-가-가리고-있는-부분을-제외한-화면의-높이를-구한다"><a href="#2-Keyboard-가-올라왔을-때-Keyboard-가-가리고-있는-부분을-제외한-화면의-높이를-구한다" class="headerlink" title="2. Keyboard 가 올라왔을 때, Keyboard 가 가리고 있는 부분을 제외한 화면의 높이를 구한다."></a>2. Keyboard 가 올라왔을 때, Keyboard 가 가리고 있는 부분을 제외한 화면의 높이를 구한다.</h2><p>이 과정은 두가지 단계로 나누어 생각해보자.</p>
<ol>
<li>Keyboard 가 언제 올라왔는지 감지</li>
<li>현재 화면상에 보여지고 있는 영역의 높이 구하기</li>
</ol>
<h3 id="1-Keyboard-가-언제-올라왔는지-감지"><a href="#1-Keyboard-가-언제-올라왔는지-감지" class="headerlink" title="(1) Keyboard 가 언제 올라왔는지 감지"></a>(1) Keyboard 가 언제 올라왔는지 감지</h3><p>1단계는 다시 <a href="https://developer.android.com/reference/android/view/ViewTreeObserver.OnGlobalLayoutListener" target="_blank" rel="noopener">ViewTreeObserver.OnGlobalLayoutListener</a> 를 이용하여 진행할 수 있다.</p>
<p>Keyboard 의 활성화/비활성화를 감지하는 아이디어는 다음과 같다.</p>
<ol>
<li>(SoftInputMode 값에 따라 다르지만) 일반적으로 Keyboard 가 올라오면 Keyboard 의 크기만큼 화면의 높이가 줄어들게 된다.</li>
<li>해당 화면(View)의 ViewTreeObserver 에 OnGlobalLayoutListener 를 등록할 경우 View의 높이가 변경될 때 이를 감지할 수 있다</li>
<li>따라서 높이가 변경되는 시점을 Keyboard 가 활성화/비활성화 된 상황이라고 추정할 수 있다. </li>
</ol>
<p>View 를 이용할 수 있는 것은 알았다. 그럼 우리는 <strong>어떤 View 를 이용하여 위 과정을 진행해야할까?</strong></p>
<h4 id="1-Activity-의-RootLayout-을-이용한다"><a href="#1-Activity-의-RootLayout-을-이용한다" class="headerlink" title="1) Activity 의 RootLayout 을 이용한다."></a>1) Activity 의 RootLayout 을 이용한다.</h4><p>가장 무난하고 쉬운 선택이다. Acitivity 의 Xml 에서 root level 에 있는 layout 을 View 로 이용하는 방법이다. 실제로도 대부분의 케이스에서는 잘 동작한다.</p>
<p>하지만 이 방법은 치명적인 단점이 존재한다. Activity 의 <a href="https://developer.android.com/guide/topics/manifest/activity-element#wsoft" target="_blank" rel="noopener">windowSoftInputMode</a> 옵션 값에따라 정상적으로 동작하지 않을 수 있다는 것이다.</p>
<p>windowSoftInputMode 옵션은 가상 Keyboard 와 Activity 의 상호작용을 지정하는 옵션인데, ‘AdjustNothing’ 와 같은 일부 옵션값은 <strong>Keyboard 가 올라와도 Activity Height 의 변화가 없기 때문에</strong> 두번째 단계를 수행할 수 없다. 따라서 Acitivity 의 windowSoftInputMode 값에 따라 동일한 결과를 보장받지 못하기 때문에, 범용적으로 활용되기 어렵다.</p>
<h4 id="2-PopupWindow-를-이용한다"><a href="#2-PopupWindow-를-이용한다" class="headerlink" title="2) PopupWindow 를 이용한다."></a>2) PopupWindow 를 이용한다.</h4><p>좀 더 개선된 선택지이다. </p>
<p>PopupWindow 는 고유의 SoftInputMode 을 별도로 지정할 수 있다. 따라서 Acitivity windowSoftInputMode 옵션이 무엇이든 영향을 받지 않고, 독립적으로 활용이 가능하다. 따라서 RootLayout 을 이용하는 1번 방식의 단점을 보완할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyboardObserver</span> <span class="keyword">extends</span> <span class="title">PopupWindow</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">            setSoftInputMode(SOFT_INPUT_ADJUST_RESIZE | SOFT_INPUT_STATE_ALWAYS_VISIBLE);</span><br><span class="line">            setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);</span><br><span class="line">    </span><br><span class="line">            ...</span><br><span class="line">    </span><br><span class="line">            rootView.getViewTreeObserver().addOnGlobalLayoutListener(() -&gt; &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-현재-화면상에-보여지고-있는-영역의-높이-구하기"><a href="#2-현재-화면상에-보여지고-있는-영역의-높이-구하기" class="headerlink" title="(2) 현재 화면상에 보여지고 있는 영역의 높이 구하기"></a>(2) 현재 화면상에 보여지고 있는 영역의 높이 구하기</h3><p>2단계는 View 에서 제공하는 <a href="https://developer.android.com/reference/android/view/View.html#getWindowVisibleDisplayFrame(android.graphics.Rect)" target="_blank" rel="noopener">View.getWindowVisibleDisplayFrame()</a> 를 활용하여 진행할 수 있다.</p>
<p>getWindowVisibleDisplayFrame(rect) 메소드는<br>해당 View 를 그리고 있는 window 를 기준으로, <strong>현재 보여지고 있는 영역의 크기를 반환한다</strong>. 따라서, Keyboard가 올라왔을 때 해당 메소드를 호출할 경우 Keyboard로 인하여 가려진 영역을 제외한 화면의 높이를 얻을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Rect visibleFrameSize = <span class="keyword">new</span> Rect();</span><br><span class="line">view.getWindowVisibleDisplayFrame(visibleFrameSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visibleFrameHeight = visibleFrameSize.bottom - visibleFrameSize.top;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-Keyboard-의-높이-구하기"><a href="#3-Keyboard-의-높이-구하기" class="headerlink" title="3. Keyboard 의 높이 구하기"></a>3. Keyboard 의 높이 구하기</h2><p>각 과정의 결과를 빼기면 하면 Keyboard 의 높이를 알 수 있다.</p>
<p>코드레벨로는 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> originHeight = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">rootView.getViewTreeObserver().addOnGlobalLayoutListener(() -&gt; &#123;</span><br><span class="line">    getKeyboardHeight(rootView);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKeyboardHeight</span><span class="params">(View targetView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetView.getHeight() &gt; originHeight) &#123;</span><br><span class="line">            originHeight = targetView.getHeight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Rect visibleFrameSize = <span class="keyword">new</span> Rect();</span><br><span class="line">        rootView.getWindowVisibleDisplayFrame(visibleFrameSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> visibleFrameHeight = visibleFrameSize.bottom - visibleFrameSize.top;</span><br><span class="line">        <span class="keyword">int</span> keyboardHeight = originHeight - visibleFrameHeight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keyboardHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 PopupWindow 를 활용한다면 간략하게는 아래와 같이 구현할 수 있을 것이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyboardHeightProvider</span> <span class="keyword">extends</span> <span class="title">PopupWindow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> View rootView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> originHeight = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 개별 SoftInputMode 세팅</span></span><br><span class="line">        setSoftInputMode(SOFT_INPUT_ADJUST_RESIZE | SOFT_INPUT_STATE_ALWAYS_VISIBLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Popup window 는 보이지 않아야 하므로 0 으로 세팅.</span></span><br><span class="line">        setWidth(<span class="number">0</span>);</span><br><span class="line">        setHeight(MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        rootView.getViewTreeObserver().addOnGlobalLayoutListener(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// callback, event 등으로 height 전달</span></span><br><span class="line">            getKeyboardHeight(rootView);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKeyboardHeight</span><span class="params">(View targetView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (targetView.getHeight() &gt; originHeight) &#123;</span><br><span class="line">            originHeight = targetView.getHeight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Rect visibleFrameSize = <span class="keyword">new</span> Rect();</span><br><span class="line">        rootView.getWindowVisibleDisplayFrame(visibleFrameSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> visibleFrameHeight = visibleFrameSize.bottom - visibleFrameSize.top;</span><br><span class="line">        <span class="keyword">int</span> keyboardHeight = originHeight - visibleFrameHeight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> keyboardHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>각 단계와 코드를 보면 알겠지만 그리 깔끔하게 구현되지는 않는다. 개인적으로 native API 를 지원해줬으면 하는 바램이다. 😹<br>위 코드를 그대로 사용하기 보다는 각 과정의 원리를 이해하고 프로젝트의 요구사항에 맞게 상세 구현을 채워나가는 방향으로 진행하면 될 것 같다.<br>실제 프로덕트 레벨에서는 아직까지 사용 시 큰 이슈가 없었으나 혹시 엣지 케이스가 보이거나 더 좋은 방법이 있다면 꼭 공유해주셨으면 좋겠다. 🙌 </p>
<h1 id="참고사항"><a href="#참고사항" class="headerlink" title="참고사항"></a>참고사항</h1><ul>
<li>만약 PopupWindow 를 이용한다면, Activity 의 레퍼런스를 가지고 있을수 있기 때문에 메모리릭 예방차원에서 반드시 onPause/onStop 생명주기내에 해당 popupWindow 를 dismiss 해주는 것을 권장한다.</li>
<li>위 방법에도 한계점은 당연히 존재한다. 바로, <strong>한번도 Keyboard 를 활성화 시키지 않은 상태에서 Keyboard 의 높이를 구할 수는 없다는 것이다.</strong> 다른 방법이 있을까 하여 비슷하게 Keyboard 높이를 이용한 에니메이션이 적용된 카카오톡의 동작을 살펴보았으나, 카카오톡 역시 최초로 Keyboard 가 활성화되기 전까지는 Keyboard 의 높이와는 무관한 에니메이션으로 동작하는 것을 확인하였다. 디테일은 다를 수 있으나 기본적으로 높이를 구하는 원리는 비슷할 것으로 예상된다. 추후에 활성화 여부와 상관없이 구할 수 있는 방법을 알게 될 경우 따로 포스팅으로 공유하려 한다.</li>
<li>위 구현은 화면의 Orientation 이 고려되어 있지 않다. 만약 화면 회전이 가능한 앱의 경우 각 orientation/높이를 key/value 로 하는 map 을 이용하여 관리하는 것도 하나의 방법이다.</li>
</ul>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] 그런 Rx Java 로 괜찮은가  2 - Mulitple API, 병렬 처리 (flatMap, merge, zip)</title>
    <url>/2019/08/10/is-this-rxjava-2/</url>
    <content><![CDATA[<p>RxJava 의 큰 장점 중 하나는 무엇이든 Observable 소스로 추상화하고, 이를 제공되는 Operation을 이용하여 손쉽게 가공할 수 있다는 점이다. 안드로이드 개발 중 가장 흔하게 접할 수 있는 케이스로는 Retrofit - RxJava 조합을 이용한 API 통신이 있다. </p>
<p>기본적인 API 콜 코드</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyService.fetchUserData()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(user -&gt; updateViewFrom(user));</span><br></pre></td></tr></table></figure>

<p>그런데 개발을 진행하다보면, 한번에 다수의 API 를 호출해야 할 상황을 맞이할 때가 있다. 역시 RxJava 에서 제공하는 다음 Operation 들을 활용하면 어려운 일이 아니다. 그러나 여전히 잘못 사용할 수 있는 여지가 존재한다. 기본적인 활용 방법과 주의해야할 점을 알아보자.</p>
<h1 id="Multiple-API-call"><a href="#Multiple-API-call" class="headerlink" title="Multiple API call"></a>Multiple API call</h1><p>보통 flatMap, merge, zip 3가지 옵션을 자주 활용하게 된다.</p>
<p>처음에 각 연산자의 역할과 차이점을 명확히 구별하기 어려울 수 있는데, 다음과 같은 예시로 먼저 가볍게 느낌만 알아보자. </p>
<p>어느 매장에서 치킨과 피자를 주문하였다. 이때 주문 옵션에 flatMap, merge, zip 을 선택할 수 있다.</p>
<ul>
<li><strong>치킨.flatMap(피자)</strong> 옵션을 선택한 경우 : 치킨을 조리하고, 완성된 치킨을 이용하여 피자를 만든 후 피자가 제공된다.</li>
<li><strong>merge.(치킨, 피자)</strong> 옵션을 선택한 경우 : 치킨, 피자 중 먼저 음식이 완성된 순서대로 제공된다.</li>
<li><strong>zip.(치킨, 피자, 치킨 피자 세트)</strong> 옵션을 선택한 경우 : 치킨, 피자 둘다 음식이 완성되면 치킨 피자 세트가 제공된다.</li>
</ul>
<h2 id="1-API-콜-간에-의존성이-있다-flatMap"><a href="#1-API-콜-간에-의존성이-있다-flatMap" class="headerlink" title="1. API 콜 간에 의존성이 있다 : flatMap"></a>1. API 콜 간에 의존성이 있다 : flatMap</h2><p>각 API 호출 간에 의존성이 있는 케이스에서는 flatMap 을 활용하자. 예를 들면 첫번째 API 콜을 이용하여 인증 토큰을 얻어 오고, 인증 토큰을 이용하여 두번째 API 콜을 하는 케이스.</p>
<p><strong>flatMap</strong> 연산자는 특수한 형태의 map 연산자이다. map 의 경우 다른 데이터 타입으로 가공하지만, flatMap 의 경우 <strong>다른 데이터를 발행할 수 있는</strong> <strong>Observable 소스</strong>로 가공한다. </p>
<p>첫번째 API 를 호출하고, 그 결과를 이용하여 두번째 API 를 호출하는 코드</p>
<pre><code>firstCall()
    .flatMap(firstCallResult -&gt; secondCall(firstCallResult))
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(secondCallResult -&gt; updateResult(secondCallResult))</code></pre><h2 id="2-각각의-API-결과를-한곳에서-처리하고-싶다-merge"><a href="#2-각각의-API-결과를-한곳에서-처리하고-싶다-merge" class="headerlink" title="2. 각각의 API 결과를 한곳에서 처리하고 싶다 : merge"></a>2. 각각의 API 결과를 한곳에서 처리하고 싶다 : merge</h2><p>API 가 서로 의존성이 없고, 각 결과를 하나의 옵저버에서 받고 싶을 경우 merge 를 활용하자.</p>
<p><strong>merge</strong> 연산자는 여러 개의 Observable 소스에서 발행한 데이터를 모아서(merge) 한곳에서 모두 받을 수 있도록 해준다. </p>
<p>첫번째 API, 두번째 API 를 각각 호출하고 그 결과를 처리하는 코드</p>
<pre><code>Observable.merge(firstCall(), secondCall())
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(eachResult -&gt; updateResultWithIndividual(eachResult))</code></pre><h2 id="3-각각의-API-의-결과를-조합하고-싶다-zip"><a href="#3-각각의-API-의-결과를-조합하고-싶다-zip" class="headerlink" title="3. 각각의 API 의 결과를 조합하고 싶다 : zip"></a>3. 각각의 API 의 결과를 조합하고 싶다 : zip</h2><p>각각의 API 호출 결과를 모아서 한번에 받고 싶을 경우 zip 을 활용하자.</p>
<p><strong>zip</strong> 연산자는 여러 개의 Observable 소스에서 발행한 데이터들을 모은 후, <strong>모든 Observable 소스에서 데이터가 발행이 완료 됐을 경우</strong> 모았던 데이터를 결합하여 하나의 데이터 형태로 발행한다. 이때 각 결과를 어떻게 결합 할지에 대한 정의를 해줘야 한다.</p>
<p>첫번째 API, 두번째 API 결과를 합친 결과를 처리하는 코드</p>
<pre><code>Observable.zip(
        firstCall(), 
        secondCall(), 
        (firstResult, secondResult) -&gt; new combinedResult(firstResult, secondResult))
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(combinedResult -&gt; updateResult(combinedResult)</code></pre><h2 id="그외"><a href="#그외" class="headerlink" title="그외.."></a>그외..</h2><p>위 내용에서는 자주 사용 되는 3개의 연산자만 설명했지만, 그 외에도 여러 특수한 케이스에서 활용할 수 있는 연산자가 많이 있다. 또한 API 호출이 아니라 Observable 소스로 추상화될 수 있는 그 무엇이든 위 연산자 들의 정의대로 활용이 가능하니 한번 익혀두면 두고두고 유용할 것이라 생각된다.</p>
<h1 id="정말-효율적인-처리-일까-Feat-병렬처리"><a href="#정말-효율적인-처리-일까-Feat-병렬처리" class="headerlink" title="정말 효율적인 처리 일까? (Feat. 병렬처리)"></a>정말 효율적인 처리 일까? (Feat. 병렬처리)</h1><p>이전 글에서도 얘기했지만, RxJava 는 같은 작업을 처리 하더라도 접근할 수 있는 경로가 매우 다양하다. 또한 각 연산자들이 어느정도 추상화되어있는 형태이다 보니 정확히 이해하지 않고 사용할 경우 결과는 그럴듯하나 내부적으로는 비효율적으로 동작할 수 있다.</p>
<p>사실은 위 예시에서도 비효율적으로 동작하는 부분이 존재한다. 다시 zip 을 활용하는 케이스로 돌아가보자. 우리가 zip 을 활용하여 API 콜을 묶을 때 기본적으로 다음과 같이 작동할 것이라고 생각한다.</p>
<p>“두개의 API가 각각 <strong>동시에</strong> 호출되고, 각 결과가 모두 도착하면 하나의 데이터로 발행이 되겠지?” </p>
<p>그런데 실제 API 콜을 프로파일러로 분석해보면, io 스케줄러 쓰레드에서 <strong>순차적으로</strong> API 를 호출함을 알 수 있다. 즉, 비동기 처리는 되었지만 <strong>병렬로 동작하지 않게 된다.</strong></p>
<h2 id="비-효율적인-방법-병렬처리-X"><a href="#비-효율적인-방법-병렬처리-X" class="headerlink" title="비 효율적인 방법 (병렬처리 X)"></a>비 효율적인 방법 (병렬처리 X)</h2><pre><code>Observable.zip(
        firstCall(), 
        secondCall(), 
        (firstResult, secondResult) -&gt; new combinedResult(firstResult, secondResult))
    .subscribeOn(Schedulers.io())
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(combinedResult -&gt; updateResult(combinedResult)</code></pre><p>다음 코드를 보고 이런 궁금증이 생길 수 있다.</p>
<p>‘subscribeOn 에 io 스캐쥴러를 설정해줬으니, 가장 처음 수행되는 zip 이 io 쓰레드에서 동작하는거 아닌가?’</p>
<p>맞다. zip 연산 자체는 io 쓰레드에서 수행된다. 하지만 zip 의 정의를 다시 한번 생각해보자. zip 은 단지 2개 혹은 그 이상의 Observable 소스가 발행하는 데이터를 묶어서 하나의 데이터로 발행하는 역할을 수행할 뿐이지, <strong>개별 Observable 소스의 아이템이 발행되는 쓰레드는 관여하지 않는다.</strong>  따라서 zip 연산자는 ios 쓰레드에서 <strong>순차적으로</strong> Observable 소스를 발행 했던 것이다.</p>
<h2 id="효율적인-방법-병렬처리-O"><a href="#효율적인-방법-병렬처리-O" class="headerlink" title="효율적인 방법 (병렬처리 O)"></a>효율적인 방법 (병렬처리 O)</h2><p>개별 Observable 소스가 각각 다른 쓰레드에서 아이템이 발행 되길 원할 경우 다음과 같이 소스에 스케쥴러를 각각 설정 해줘야한다.</p>
<pre><code>Observable.zip(
        firstCall().subscribeOn(Schedulers.io()), 
        secondCall().subscribeOn(Schedulers.io()), 
        (firstResult, secondResult) -&gt; new combinedResult(firstResult, secondResult))
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe(combinedResult -&gt; updateResult(combinedResult)</code></pre><p>또한 zip 연산에 대한 스케쥴러 설정이 사라졌는데, 사실 zip 연산 자체가 별도의 쓰레드에서 수행될 이유는 없기 때문이다. </p>
<p>zip 연산외에 merge 에서도 위 내용은 동일하게 적용되니 개발시 참고하자!</p>
<h1 id="맺으며"><a href="#맺으며" class="headerlink" title="맺으며"></a>맺으며</h1><p>RxJava 는 강력한 도구이지만 그만큼 숙지해야할 내부 정책들도 제법 많다. 이러한 정책들, 낯선 접근방식 때문에 여전히 러닝커브가 높다고 여겨지지만 한번 적응하면 이만한 도구가 없다고 느껴지는 것도 사실이다. 잘 흡수하여 무기로 갈고 닦는다면 개발시 직면하는 다양한 문제들을 해결해줄 것이라고 생각한다. 🤟</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] 그런 Rx Java 로 괜찮은가  1 - subscribeOn, observeOn</title>
    <url>/2019/07/20/is-this-rxjava-1/</url>
    <content><![CDATA[<p>구글은 점점 더 안드로이드 아키텍처를 리엑티브하게 구조화 하려는 움직임을 보이고 있고, Databinding, LiveData 그리고 RxJava 는 그러한 구조화 작업의 핵심 토대를 담당하고 있다. 또한 주력으로 사용되는 Retroift 부터 AAC 의 Room, Paging 에 이르기까지 많은 안드로이드 라이브러리가 RxJava 를 지원하고 있다. </p>
<p>시대의 흐름에 따라 이제는 거의 필수가 되어버린 RxJava 이기에 더이상 미루지 못하고 활용 방법을 익히기 시작했으나 워낙 제공되는 operation 이 많고 사람들이 사용하는 스타일도 제각각 달라서 스스로 사용법을 익히기까지 많은 시행착오를 겪어야 했다. 위 시리즈는 그동안 RxJava 를 사용하면서 겪었던 경험을 바탕으로 놓치기 쉽거나, 활용했을 때 좋았던 방식들을 적어 나가는 포스트가 될 것 같다. 깊은 수준의 내용은 아니지만, 이 글들을 통해 조금이나마 삽질의 시간을 줄이고 적절하게 RxJava 를 활용하는데 도움이 되었으면 좋겠다. </p>
<h1 id="subscribeOn-observeOn-잘-사용하고-있나"><a href="#subscribeOn-observeOn-잘-사용하고-있나" class="headerlink" title="subscribeOn, observeOn 잘 사용하고 있나?"></a>subscribeOn, observeOn 잘 사용하고 있나?</h1><h2 id="Schedular-퀴즈"><a href="#Schedular-퀴즈" class="headerlink" title="Schedular 퀴즈"></a>Schedular 퀴즈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// # 1</span></span><br><span class="line">myService.getUsers()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .flatMap(Observable::fromIterable)</span><br><span class="line">    .filter(User::isMember)</span><br><span class="line">    .map(<span class="keyword">this</span>::saveToCache)</span><br><span class="line">    .toList()</span><br><span class="line">    .subscribe(View::showUser);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// # 2</span></span><br><span class="line">myService.getUsers()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .flatMap(Observable::fromIterable)</span><br><span class="line">    .filter(User::isMember)</span><br><span class="line">    .map(<span class="keyword">this</span>::saveToCache)</span><br><span class="line">    .toList()</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(View::showUser);</span><br></pre></td></tr></table></figure>

<p>위 두 케이스는 user 리스트를 요청하는 API 를 호출한 후 필요한 비즈니스 로직을 수행하는 코드이다.</p>
<p>각 케이스의 차이점은 observerOn, subscribeOn 의 호출 순서가 다르다는 점이다. 2개의 코드에서 각각의 스트림 연산이 어느 쓰레드에서 수행되는지 잠시 예상해보자. </p>
<p>만약 정확히 얘기할 수 있다면 이미 subscribeOn, observeOn 에 대한 이해가 충분할 것이라 예상되어 해당 글은 리마인드 차원에서 가볍게 보고 넘어가면 될 것 같다. 👏</p>
<p>위 문제의 답은 다음과 같다.<br>첫번째 케이스는 getUsers() 에 대한 연산만 io Schedular 쓰레드 위에서 수행되며, <strong>나머지 모든 하위 스트림 연산은 메인쓰레드에서 수행된다.</strong><br>두번째 케이스는 getUsers() ~ toList 연산까지 io Schedular 위에서 수행되며, subscribe 내에서 콜백으로 <strong>최종 데이터를 전달받는 연산만 메인쓰레드에서 수행된다</strong>.</p>
<p>따라서 첫번째 케이스는 굳이 메인 쓰레드에서 수행하지 않아도 될 비즈니스 로직을 수행하고 있는 것 이므로 <strong>자원의 낭비가 있는 코드</strong>라고 볼 수 있다. (만약 엄청나게 많은 리소스가 요구되는 비즈니스 로직이라면…😭)</p>
<h2 id="정의와-올바른-활용법"><a href="#정의와-올바른-활용법" class="headerlink" title="정의와 올바른 활용법"></a>정의와 올바른 활용법</h2><p>사실 각 케이스에서 subscribeOn 은 어느 순서에 호출하든 결과는 변하지 않는다. 위 결과의 차이를 만드는 것은 <strong>observeOn 의 호출 위치</strong>이다.<br>호출위치라고? subscribeOn, observeOn 의 정의를 한번 살펴보자.</p>
<blockquote>
<p>subscribeOn </p>
<ul>
<li>observable source 가 observer 에 의해 <strong>subscribe 됐을 때, source 가 데이터를 다음 스트림으로 전달하는 액션</strong>을 수행하는 스케쥴러를 지정.</li>
</ul>
</blockquote>
<blockquote>
<p>observeOn </p>
<ul>
<li><strong>observerOn 이후 수행되는 스트림의 액션</strong>을 수행하는 스케쥴러를 지정</li>
</ul>
</blockquote>
<p>간단히 얘기하면 </p>
<ul>
<li>subscribeOn 는 [첫번째 스트림 ~ observeOn 호출 전 까지의 스트림] 의 쓰레드를 지정 </li>
<li>observeOn 은 [해당 observeOn 호출 이후의 스트림] 의 쓰레드를 지정한다.</li>
</ul>
<p>위 정의에 따르면 observeOn 은 <strong>어느 순서에 호출되느냐에 따라</strong> 영향을 받는 스트림이 달라지게 된다. 따라서 첫번째 케이스는 getUsers() 이후 바로 observeOn 이 호출 됐으므로 이후 스트림의 연산이 메인쓰레드에서 수행되게 되는 것이다.</p>
<p>만약 이러한 특성을 고려하지 않고 기계적으로 코드를 작성하게 될 경우, 첫번째 케이스 처럼 작성하게 될 가능성이 있고 이는 RxJava 가 의도한 특성을 제대로 활용하지 못하고 있는 것이라고 볼 수 있다. (내가 그랬다..)</p>
<p>위 정의와 본래 의도에 맞게 다시 코드를 작성하면 아래와 같다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myService.getUsers()</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.computation()) </span><br><span class="line">    .flatMap(Observable::fromIterable)</span><br><span class="line">    .filter(User::isMember)</span><br><span class="line">    .map(<span class="keyword">this</span>::saveToCache)</span><br><span class="line">    .toList()</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(View::showUser);</span><br></pre></td></tr></table></figure>

<ul>
<li>computation 쓰레드로 바꾸지 않고, io 쓰레드 위에서 그대로 진행되어도 상관은 없으나, 각 schedualars 가 본래 역할에 맞게 사용될 수 있도록 하기위해 바꾸었다.</li>
</ul>
<h2 id="그외-subscribeOn-observeOn-활용시-도움이-될만한-사실들"><a href="#그외-subscribeOn-observeOn-활용시-도움이-될만한-사실들" class="headerlink" title="그외 subscribeOn, observeOn 활용시 도움이 될만한 사실들"></a>그외 subscribeOn, observeOn 활용시 도움이 될만한 사실들</h2><ul>
<li>subscribeOn, observeOn 호출은 필수가 아닌 옵션이다.</li>
<li>subscribeOn, observeOn 모두 호출하지 않았을 경우 subscribe() 를 호출한 thread 에서 스트림연산이 수행된다. (일반적으로는 메인쓰레드 일 것이다.)</li>
<li>subscribeOn 은 최초 1회 호출만 적용되며, 그 이후 다시 호출하는 것은 무시된다.</li>
<li>observeOn 은 호출 횟수에 제한이 없다.</li>
<li>subscribeOn 만 호출할 수 있다. 따라서 subscribeOn 정의에 따라 모든 스트림 연산은 subscribeOn 에서 지정한 쓰레드 위에서 수행된다.<ul>
<li>observeOn(AndroidSchedulars.mainThread()) 를 기계적으로 호출하지 말자. 백그라운드 상에서 수행될 작업만 있는 스트림일 경우 subscribeOn(Schedulars.xx) 호출만으로 충분하다.</li>
</ul>
</li>
<li>observeOn 만 호출할 수 있다. (하지만 활용한 케이스 X)</li>
<li>subscribeOn 의 호출 순서는 결과에 영향을 주지 않지만, 되도록 첫번째 혹은 마지막에 호출하는 것이 가독성 측면에서 좋다고 느낀다. 특히 메소드 체이닝이 길어질 수록 더더욱 흐름 파악에 도움이 된다.</li>
</ul>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p><strong>subscribeOn / observeOn 를 상황에 맞게 활용하고, 특히 observeOn 은 호출 순서에 주의하자.</strong></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>2019년 상반기 회고</title>
    <url>/2019/07/07/2019-first-half-review/</url>
    <content><![CDATA[<p>상반기에 많은 일들이 있었던 것 같은데 막상 적으려니까 잘 떠오르지 않아 당황스러웠다. 이래서 평소에 기록을 해두는 습관을 형성 해두는 것이 중요한 것 같다.</p>
<h1 id="이직"><a href="#이직" class="headerlink" title="이직"></a>이직</h1><p>1년 4개월 동안 다니던 회사를 뒤로하고 첫 이직을 했다. <a href="https://zoyi.co" target="_blank" rel="noopener">조이</a>에서 개발자를 시작한 것은 정말 현명한 선택이었다. 입사 전과는 비교할 수 없을 만큼 많이 배우고 성장하는 시간을 보냈다. 그렇게 좋은 환경이었음에도 불구하고 이직을 하게 된 계기는 단순했다. 내 사고가 어느 한 방향으로 굳기 전에 새로운 변화를 맞이하여 자극을 주고 싶었고, 구체적인 자극으로서 좀 더 많은 유저가 사용하는 큰 스케일의 프로젝트를 개발 해보고 싶었다. 목표가 생기자 퇴근 후 새벽까지 이직 공부를 하며 여러 곳에 지원을 했고 결과적으로 <strong>NAVER</strong>에 입사를 하게 되었다.</p>
<p>사실 업무와 이직 준비를 동시에 하는 기간은 정신적으로나 육체적으로나 정말 힘들었고 포기하고 싶었던 순간이 많았다. 하지만 결과적으로 그 시간을 겪으면서 현재 내 수준을 정확히 점검할 수 있었고 당시에 정리했던 공부 내용들이 지금까지도 개발하면서 아주 큰 도움이 되고 있다. 이직할 생각이 없더라도 정기적으로 면접을 보는 경험이 좋다는 얘기가 이런 맥락에서 였나 싶었다.</p>
<p>네이버 내에서 맡게 된 서비스는 ‘네이버 카페’ 다. 사실 입사 전에 네이버 카페를 자주 쓰는 편이 아니었어서(…) 실 사용자수가 어느정도 인지 감이 없었는데, 생각했던 수치보다 10배나 높았다! 아주 많은 자극을 받게 될 것 같다. 👏  또한 개인적으로 인복이 정말 많다고 생각되는 것이, 전 회사 그리고 현재에도 정말 좋은 팀과 동료 들을 만나게 되었다. 특히 시니어분들이 보여주시는 모습은 나중에 내가 그 위치로 올라갔을 때 꼭 닮고 싶은 부분이었다. 현재는 입사 프로젝트를 마치고 작은 테스크부터 점차 수행 해나가고 있으며, 빨리 새로운 환경에 적응을 마치고 깃헙에 많은 잔디를 심고 싶다.</p>
<h1 id="개발"><a href="#개발" class="headerlink" title="개발"></a>개발</h1><p>작년 한해는 RxJava, Dagger, Clean Architecture, 함수형 프로그래밍 등 특정 기술 영역을 익히는데 관심과 시간을 투자 했다면 올해 초부터는 기본기를 좀 더 다지는 한 해를 보내고 있다. 개발을 막 시작하던 때에는 기술만 도입하면 모든 문제가 해결될 것 처럼 보였지만 역시 은탄환은 없었다. 좀 더 복잡하고 어려운 스펙, 난해한 이슈들을 맞이할수록 결국에는 기본 영역 레벨로 내려가 고민을 하게 된다. 그리고 그러한 상황들을 맞이할 때마다 내 부실한 지식과 한계를 명확히 느꼈다. 동료 개발자와 기초적인 지식과 관련하여 커뮤니케이션을 할 때, 잘 모르는 내용 이었지만 일단 아는 척을 하고 집에 가서 그 내용을 찾아볼 때는 부끄러움과 약간의 분함(?)도 찾아왔다. 위와 같은 경험을 한 뒤로는 각 분야의 기초 서적들을 구입해 퇴근 후 틈틈히 공부하고 그 내용을 노션에 정리하기 시작했다.</p>
<img src="https://user-images.githubusercontent.com/27072782/60766066-f7145700-a0de-11e9-9bc8-18b3ad08ce4d.png" class="study" width="500" height="600" title="study">

<p> 공부를 하면 할 수록 내가 겉핥기 수준으로 알고 있는 부분이 많았고, 기존의 코드들도 좀 더 깊이 이해가 되는 부분들이 생기기 시작했다. 실제로 라이브러리나 프레임워크 내부 소스코드를 분석하다 보니 곳곳에 객체지향 원칙, 자료구조 등 기본적인 지식들이  녹아져있음을 깨닫게 되었다. 아직도 부족한 수준이지만, 꾸준히 채워 나가는데 의의를 두려한다.</p>
<h1 id="개발-외적인-것들"><a href="#개발-외적인-것들" class="headerlink" title="개발 외적인 것들"></a>개발 외적인 것들</h1><p><strong>주짓수</strong></p>
<img src="https://user-images.githubusercontent.com/27072782/60766085-3e024c80-a0df-11e9-9b1e-369b9680c2fd.jpeg" class="bbj" width="500" height="500" title="bbj">

<p>친구의 지속적인 권유로 마지못해 <strong>주짓수</strong>를 시작했다. 무술류 운동은 평생 해볼일이 없을 줄 알았는데 이게 하다 보니 생각보다 재미있다..? 요즘은 입사 적응 기간이라 좀 꺾였지만 한동안은 모든 여가 시간을 주짓수로 보낼 만큼 열성을 다해서 했다. 꾸준히 운동을하면서 느낀 것이 꼭 주짓수가 아니더라도 규칙적으로 땀을 흘리는 활동은 일상생활에 많은 플러스를 가져다 준다는 것이었다. 하지만 역시나 스스로 운동을 시작한다는 것은 참으로 어려운 의지의 영역 이기에 글또 처럼 운또(?)와 같은 모임을 만들어서 운동을 꾸준히 할 수 있는 환경을 구축하는 것도 좋은 시도가 될 수 있을 것 같다.</p>
<p><strong>집밖으로!</strong><br>주말이든 휴가든 집에서 거의 나가지 않는 생활을 했었는데, 요즘은 의도적으로 집을 떠나려고 노력하고 있다. 집에서는 한없이 나태해지기 쉽기 때문에 이것을 경계 하려는 목적도 있고 다양한 환경, 다양한 사람들을 접하며 보고 느끼는 것이 삶에 긍정적인 영향을 주고 있음을 느끼고 있기 때문이다. 최근 목표로는 몽골 여행을 생각하고 있다. 일반적인 여행보다는 많이 힘들다는 얘기들이 많지만, 그렇기에 더더욱 체력이 점점 떨어지기 전에 도전 해보고싶다.</p>
<h1 id="2019년-하반기-목표"><a href="#2019년-하반기-목표" class="headerlink" title="2019년 하반기 목표"></a>2019년 하반기 목표</h1><p><strong>개발적인 측면에서는 다음과 같은 목표를 이루고 싶다.</strong></p>
<ul>
<li>네트워크 기초지식 다지기</li>
<li>서버 프레임워크를 통해 기본적인 서버구조 익히기</li>
<li>AAC 라이브러리를 활용하여 스펙 구현하기</li>
</ul>
<p><strong>개발 외적인 측면에서는 다음과 같은 목표를 이루고 싶다.</strong></p>
<ul>
<li>주짓수 블루벨트 달성</li>
<li>계족산 황톳길 등산하기</li>
<li>스노클링</li>
<li>다른 직군의 사람들과 네트워킹 2회 이상</li>
</ul>
<h1 id="글또-3기-다짐"><a href="#글또-3기-다짐" class="headerlink" title="글또 3기 다짐"></a>글또 3기 다짐</h1><p>꾸준히 무엇 인가를 하는 습관을 형성하기 위해서는 어느 정도의 강제성과 보상이 주어지는 환경이 중요하다고 생각한다. 그런 측면에서 글또라는 모임은 정말 좋은 취지로 그러한 환경을 잘 조성 해주는 것 같아서 운영하시는 분들과 성실히 참여해주시는 분들이 대단하다고 생각했었다. 1기 때부터 지원을 고민했지만 언젠간 하겠지라는 생각으로 미뤘었고, 그 언젠가는 오지 않는걸 알기에 이번에는 공고가 나오자마자 신청을 하게 됐다. 이번 회고 글을 쓰면서 평소에 글을 써본 경험이 적어서 작은 분량임에도 불구하고 작성하는 데에도 많은 시간이 소요됐지만 신기하게도 시간가는 줄 모르고 재밌게 적게되는 경험을 하게 됐다. 남은 기간 동안 서로의 글들을 통해 많은 배움과 성장이 있음을 기대하며 나도 열심히 달려 나가야겠다.</p>
]]></content>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] Nullaway 를 활용하여 NullPointerException 예방하기</title>
    <url>/2018/09/21/what-is-nullaway/</url>
    <content><![CDATA[<p>한번도 <strong>NullPointerException</strong> (이하 NPE)를 겪어보지 않은 사람은 있을지 몰라도, 한번만 NPE 를 겪어본 사람은 없을것이다. NPE 로 인한 크래시가 나기 전까지는 그 존재를 알 수 없기 때문에 항상 Null 값 처리를 신경 쓰면서 개발을 진행해야 한다. 잊을만하면 나타나는 NPE를 바라보면서 한숨을 쉬고 있을 때쯤, 동료 개발자에게 미리 NPE 예방에 도움을 주는 <a href="https://github.com/uber/NullAway" target="_blank" rel="noopener">Nullaway</a> 라이브러리를 소개받았다.</p>
<p>Nullaway 는 @Nullable 어노테이션을 이용하여 <strong>Compile Time 에 Null check</strong> 검사를 수행한다. 간결하고, 강력해보인다.</p>
<h2 id="Nullaway-세팅하기"><a href="#Nullaway-세팅하기" class="headerlink" title="Nullaway 세팅하기"></a><strong>Nullaway 세팅하기</strong></h2><p><code>gradle</code> 기반으로 가이드가 되어있고, Android / Non - Android 방식으로 나뉘는데 거의 차이가 없다. 이 글에서는 Android 방식을 기준으로 설명한다.</p>
<p>App 모듈 Gradle 파일에 다음과 같이 추가해주면 설정이 끝난다.</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'net.ltgt.errorprone'</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">  repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">      url <span class="string">"https://plugins.gradle.org/m2/"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath <span class="string">"net.ltgt.gradle:gradle-errorprone-plugin:0.0.13"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  &lt;!--￼<span class="number">0</span>--&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!name.toLowerCase().contains(<span class="string">"test"</span>)) &#123;</span><br><span class="line">    options.compilerArgs += [</span><br><span class="line">        <span class="string">"-Xep:NullAway:ERROR"</span>,</span><br><span class="line">        <span class="string">"-XepOpt:NullAway:AnnotatedPackages=com.your.package"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Configuration</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">tasks.withType(JavaCompile) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!name.toLowerCase().contains(<span class="string">"test"</span>)) &#123;</span><br><span class="line">    options.compilerArgs += [</span><br><span class="line">        <span class="string">"-Xep:NullAway:ERROR"</span>,</span><br><span class="line">        <span class="string">"-XepOpt:NullAway:AnnotatedPackages=com.your.package"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다른 부분은 그대로 사용해도 상관없지만 해당 부분은 각 프로젝트에 맞게 수정을 해줘야 한다. Nullaway의 적용범위를 설정할 수 있다.</p>
<p>필수로 추가해줘야 하는 부분은 <code>-XepOpt:NullAway:AnnotatedPackages</code> 옵션이다. 해당 옵션값은 Nullaway 가 검사할 패키지를 지정한다. 위 옵션값으로 지정된 패키지 및 그 하위 패키지는 Nullaway가 요구하는 @Nullable 어노테이션 처리가 모두 되어있다고 가정하며, 만약 처리가 안되어 있을 경우 빌드시 에러를 발생시킨다.</p>
<p>그외에 자주 쓰이는 옵션은 다음과 같다.</p>
<ul>
<li><code>-XepOpt:NullAway:UnannotatedSubPackages</code> : Nullaway가 요구하는 어노테이션 처리가 안되어 있는 패키지를 지정한다. 해당 패키지 및 그 하위패키지는 Nullaway 검사에서 제외된다.</li>
<li><code>-XepOpt:NullAway:ExcludedClasses</code> : Nullaway가 요구하는 어노테이션 처리가 안되어 있는 클래스를 지정한다. 해당 클래스는 Nullaway 검사에서 제외된다.</li>
</ul>
<p><strong>2개 이상의 패키지 혹은 클래스를 옵션값으로 주고 싶을 경우</strong></p>
<p>같은 옵션의 값을 여러번 추가하면 될 거 같지만, 실제로는 가장 마지막에 추가된 값만 옵션에 적용되기 때문에 원하지 않는 결과가 나올 수 있다. 따라서 2개 이상의 클래스 / 패키지를 지정하고 싶을 경우에는 정규식을 이용해야 한다.</p>
<p><em>com.project</em> 의 하위 패키지인 <em>foo</em>, <em>bar</em> 패키지를 Nullaway 검사에서 제외시키고 싶을 때</p>
<ul>
<li><code>&quot;-XepOpt:NullAway:UnannotatedSubPackages=com.project.(foo|bar)&quot;</code></li>
</ul>
<p>prefix로 <strong>test_</strong> 가 붙은 패키지들을 Nullaway 검사에서 제외시키고 싶을 때</p>
<ul>
<li><code>&quot;-XepOpt:NullAway:UnannotatedSubPackages=com.project.test_[a-zA-Z0-9.]*&quot;</code></li>
</ul>
<p>그외 자세한 설명은 <a href="https://github.com/uber/NullAway/wiki/Configuration" target="_blank" rel="noopener">Docs</a> 를 참고!</p>
<h2 id="사용-방법"><a href="#사용-방법" class="headerlink" title="사용 방법"></a><strong>사용 방법</strong></h2><p>Android Support Library 에서 제공하는 <code>@Nullable</code> 어노테이션을 이용한다. Null 이 될 수 있는 필드, Null을 리턴할 수 있는 메소드에 <code>@Nullable</code>, Null 이 될 수 없는 필드, Null 을 리턴하지 않는 메소드는 <code>@NonNull</code> 을 추가해주면 된다. 아무런 어노테이션도 추가되지 않은 변수, 메소드는 @NonNull 로 인식한다. @Nullable 이 추가되어있는 필드는 항상 Null safe 체크 이후에 사용될 수 있고, @NonNull 이 추가되어 있는 필드는 Null 값이 들어올 수 없다는 것을 기본전제로 Null check 검사를 수행한다.</p>
<p>예제</p>
<p>아래 코드를 빌드할 경우 NonNull 타입 파라미터에 Null 이 들어갔으므로 Nullaway가 에러를 낸다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testModel</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    Log.e(<span class="string">"TEST"</span>, model.isValid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    testModel(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>따라서 다음과 같이 처리해줘야 한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testModel</span><span class="params">(@Nullable Model model)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (model != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	Log.e(<span class="string">"TEST"</span>, model.isValid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>만약 Null check 없이 그대로 model 을 사용하려고 할 경우, 역시 에러를 낸다.</p>
<p>Nullaway가 에러를 띄워주는 케이스는 <a href="https://github.com/uber/NullAway/wiki/Error-Messages" target="_blank" rel="noopener">Error Messages</a> 에 정리되어 있다.</p>
<h2 id="실제-프로젝트에-적용해보면서-느낀-점"><a href="#실제-프로젝트에-적용해보면서-느낀-점" class="headerlink" title="실제 프로젝트에 적용해보면서 느낀 점"></a><strong>실제 프로젝트에 적용해보면서 느낀 점</strong></h2><ol>
<li>방어코드를 잘 추가했다고 생각했음에도 처리되지 않았던 부분이 많았고, 관련 코드를 모두 수정하여 앱의 안정성을 올리는데 도움을 주었다.</li>
<li>Nullaway 소개글에 나온 것 처럼 처리 속도가 빨라 빌드시간이 추가로 더 늘어나지는 않음.</li>
<li>코드를 작성할 때 Nullable, NonNull 을 고려하게 된다는 점이 좋았음.</li>
</ol>
<p>코틀린으로 넘어가게 되면 사용하지 않아도 무방하고 자바로 계속 개발할 경우 한번 적용해보는 것을 추천한다.</p>
<p>샘플 링크 <a href="https://github.com/vagabond95/NullAwaySample" target="_blank" rel="noopener">https://github.com/vagabond95/NullAwaySample</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] TextView 에서 textIsSelectable와 LinkMovementMethod를 같이 사용할때 발생하는 이슈</title>
    <url>/2018/06/13/text_is_selectable_issue/</url>
    <content><![CDATA[<h2 id="발단"><a href="#발단" class="headerlink" title="발단"></a><strong>발단</strong></h2><p>며칠 전부터 이슈트래킹 대시보드에서 아래 에러가 빈번하게 리포트되는 일을 겪었다.</p>
<pre><code>Fatal Exception: java.lang.IndexOutOfBoundsException: setSpan (-1 ... -1) starts before 0
       at android.text.SpannableStringInternal.checkRange(SpannableStringInternal.java:442)
       at android.text.SpannableStringInternal.setSpan(SpannableStringInternal.java:163)
       at android.text.SpannableStringInternal.setSpan(SpannableStringInternal.java:152)
       at android.text.SpannableString.setSpan(SpannableString.java:46)
       at android.text.Selection.setSelection(Selection.java:76)
       at android.widget.TextView.semSetSelection(TextView.java:13203)</code></pre><p>코딩을 할 때 신경써서 범위를 지정하지 않을 경우 종종 겪는 에러였는데, 디버깅을 해도 해당 부분은 모두 예외처리가 잘 되어있어 원인을 쉽게 찾을 수 없었다.</p>
<h2 id="해결"><a href="#해결" class="headerlink" title="해결"></a><strong>해결</strong></h2><p>그러던 중 우연히 재현 조건을 찾게 되었고, 조건은 TextView 에서 특정 텍스트를 복사하려고 드래그를 시도할 때 랜덤하게 크래시가 발생했다. 복사 기능은 TextView 의 <code>textIsSelectable</code> 옵션을 활용하여 제공하고 있었기 때문에, ‘textIsSelectable’ 과 ‘IndexOutOfBoundsException’ 키워드를 엮어 내용을 찾아보니 <a href="https://stackoverflow.com/questions/15836306/can-a-textview-be-selectable-and-contain-links" target="_blank" rel="noopener">힌트가 될만한 정보</a> 를 얻을 수 있었다.</p>
<p>내용인즉, <code>textIsSelectable</code> 옵션과 <code>LinkMovementMethod</code> 를 같이 사용했을 때 의도하지 않은 결과가 나올 수 있다는 것이었다. <strong><code>LinkMovementMethod</code> 는 안드로이드에서 제공하는 녀석이어서 원인이 될 것이라고 생각하지 못했다.</strong> 우리 프로젝트에서도 <code>textIsSelectable</code> 옵션이 적용된 TextView 에서 <code>LinkMovementMethod</code> 를 같이 사용하고 있었기에, 혹시나 하는 마음으로 위 내용을 참고하여 CustomMovementMethod 만든 후 적용시켜봤다. 그리고 다시 테스트를 반복하여 시도해본 결과 더이상 크래시가 발생하지 않았다.</p>
<h2 id="정확한-원인은"><a href="#정확한-원인은" class="headerlink" title="정확한 원인은?"></a><strong>정확한 원인은?</strong></h2><p>버그를 해결하고 나서 위 문제가 발생한 원인을 다시 생각해 봤다.</p>
<ol>
<li>발단은 span 을 적용하는 과정에서 문제가 발생한 것이었다.</li>
<li>위 재현조건에서 span 을 적용하는 상황은 <code>textIsSelectable</code> 옵션을 활성화한 TextView 에서, 특정 text 에 대해 드래그를 했을 배경에 컬러가 입혀지는 상황이다.</li>
<li>‘textIsSelectable 옵션만 적용했을 때’ 는 위 크래시가 발생하지 않는것으로 보아, <code>LinkMovementMethod</code> 내부에서 <strong>드래그 영역의 컬러에 대한 span이 적용되는 범위를 임의로 컨트롤</strong>하는 로직이 있음을 유추할 수 있었다. 좀 더 세밀하게 추적하기 위해 <code>LinkMovementMethod</code> 코드를 그대로 가져와서 로그를 추가한 뒤 다시 상황을 재현해보았다.</li>
<li><strong>원인을 찾았다!</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClickableSpan[] links = buffer.getSpans(off, off, ClickableSpan.class);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (links.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">          links[<span class="number">0</span>].onClick(widget);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">          Selection.setSelection(buffer,</span><br><span class="line">              buffer.getSpanStart(links[<span class="number">0</span>]),</span><br><span class="line">              buffer.getSpanEnd(links[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Selection.removeSelection(buffer);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>LinkMovementMethod 의 경우 TextView 에 대한 touch 이벤트를 감지할 수 있는 <code>onTouchEvent</code> 라는 콜백 메소드가 존재하며, 위 코드가 해당 콜백의 핵심 로직이다. 코드를 잘 살펴보면 buffer 로 들어온 text에 ClickableSpan이 없을 경우에는 buffer 의 selection 을 초기화 하는 과정을 수행한다. 그런데 위에서 적었던 stacktrace 내용을 살펴보면 드래그 영역에 대한 span 의 범위는 결국 selection 으로 부터 가져오기 때문에 selection을 초기화해버릴 경우에 의도하지 않은 동작이 발생하게 되는 것이다.</li>
</ol>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a><strong>결론</strong></h2><p>위 이슈를 겪으면서 얻은 결론은 두가지이다.</p>
<ol>
<li>TextView 에서 <code>textIsSelectable</code> 과 <code>LinkMovementMethod</code> 를 같이 사용하는 것은 좋지 않으며, 부득이하게 사용해야 할 경우 Custom 하게 만들어서 사용하는 것이 좋다.</li>
<li>Android 에서 제공하는 API도 문제의 원인이 될 수 있다. 다만 이 부분은 직접 겪기전까지는 알기 어려울 듯 하다.</li>
</ol>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>[안드로이드] API 26, Oreo Notification 대응기</title>
    <url>/2018/04/19/notification-with-oreo/</url>
    <content><![CDATA[<h2 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a><strong>들어가며</strong></h2><p>안드로이드에서 제공하는 알림(Notification) 은 강력한 기능들을 제공하고 있다. 그리고 매번 API 버전이 올라갈 때마다 빈번하게 Update 가 되는 녀석이기 때문에 계속해서 주시하고 있어야하는 놈이기도 하다. 그동안 아무생각없이 copy &amp; paste 만 하면서 사용하고 있던 스스로를 돌아보며 다시한번 알림의 전반적인 사용방법에 대해 정리하고자 포스트를 적었다.</p>
<h3 id="개발-환경"><a href="#개발-환경" class="headerlink" title="개발 환경"></a><strong>개발 환경</strong></h3><ul>
<li>supportLibrary Version - 26.1.0</li>
<li>complileSDK Version - 26</li>
<li>targetSDK Version - 26</li>
</ul>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL; DR"></a><strong>TL; DR</strong></h2><p>오레오에서 알림 대응은 피할 수 없다. 미대응시 작동 X 😱</p>
<h2 id="오레오대응-더이상은-피할-수-없다"><a href="#오레오대응-더이상은-피할-수-없다" class="headerlink" title="오레오대응.. 더이상은 피할 수 없다?"></a><strong>오레오대응.. 더이상은 피할 수 없다?</strong></h2><p>아직 비교적 최신 버전인 오레오 대응을 굳이 처음부터 다르는 이유는 다음과 같다.</p>
<ol>
<li><p><a href="https://developers-kr.googleblog.com/2018/01/improving-app-security-and-performance-on-google-play.html" target="_blank" rel="noopener">새로운 Google Play 방침</a> 에 따르면  play store 에 등록되어 있는 앱을 업데이트 하거나, 새로 앱을 등록 할 경우 <code>targetSdkVersion &gt;= 26</code> 을 만족해야 한다. 따라서 오레오(8.0) 대응을 피할 수 없게 되었다.</p>
<p> 2018년 하반기 부터</p>
</li>
<li><p>오레오 여러 변경 사항 중 특히 신경써줘야 할 부분은 알림(Notification) 에 대한 변경사항인데, 이를 반영하지 않을 경우 <strong>알림이 오지않는 치명적인 상황이 발생한다.</strong></p>
</li>
</ol>
<h2 id="NotifcationChannel-의-등장"><a href="#NotifcationChannel-의-등장" class="headerlink" title="NotifcationChannel 의 등장"></a><strong>NotifcationChannel 의 등장</strong></h2><p>우리가 처리해줘야하는 부분은 오레오에서 새롭게 등장한 <a href="https://developer.android.com/training/notify-user/channels" target="_blank" rel="noopener">NotificationChannel</a> 과 관련되어있다. 왜 google 은 이 녀석에 대한 처리를 강제했을까? 다음 상황을 살펴보면 그 이유를 짐작할 수 있다.</p>
<p>나는 스마트폰에 알림이 쌓여있는 걸 좋아하지 않아서, 보통 대부분 앱의 알림을 꺼놓는다. 하지만 그때 아쉬운 점이 하나 있었는데, 확인하고 싶은 일부 알림 역시 받을 수 없다는 것이었다.</p>
<p>Android 7.1 (API level 25) 이하 버전에서는 모든 알림이 하나로 묶여 관리됐기 때문에 위의 아쉬운 점을 해결할 수 없었고 이에 대한 대안으로 오레오에서 NotificationChannel 이 새롭게 추가되었다.</p>
<img src="https://user-images.githubusercontent.com/27072782/60758428-7c512a80-a051-11e9-9fa2-ed4b67fbb7f8.jpg" class="notification_channel" width="200" height="120" title="notification_channel">

<p>NotificationChannel 을 적용할 경우 더이상 각 알림이 하나로 묶이지 않고, channel 별로 분리되어 유저가 유연하게 알림을 설정할 수 있다. 위와 같이 notification_practice 앱에는 각각 <code>확인하고싶은 알림</code> 과 <code>보고싶지 않은 알림</code> 채널이 있으며 각 채널별로 수신여부, 잠금화면 표시여부, 소리 &amp; 진동 설정 등 여러 옵션을 세밀하게 설정할 수 있다. 👏👏👏</p>
<h2 id="NotificationChannel-적용하기"><a href="#NotificationChannel-적용하기" class="headerlink" title="NotificationChannel 적용하기"></a><strong>NotificationChannel 적용하기</strong></h2><p>적용과정은 다음과 같다.</p>
<ol>
<li>NotifcationChannel 생성</li>
<li>NotificationManager 에 만들어둔 NotifcationChannel 을 등록</li>
<li>Notification builder 에 등록된 NotifcationChannel의 id 를 등록</li>
</ol>
<h3 id="NotificationChannel-생성-및-등록"><a href="#NotificationChannel-생성-및-등록" class="headerlink" title="NotificationChannel 생성 및 등록"></a><strong>NotificationChannel 생성 및 등록</strong></h3><pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
    String uniqueId = &quot;uniqueId&quot;;
    String channelName = &quot;확인하고 싶은 알림&quot;;
    String description = &quot;확인하고 싶은 알림 채널입니다.&quot;;
    int importance = NotificationManager.IMPORTANCE_HIGH;

    NotificationChannel notificationChannel = new NotificationChannel(uniqueId, channelName, importance);
    notificationChannel.setDescription(description);

    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    notificationManager.createNotificationChannel(notificationChannel);
  }</code></pre><p>NotificationChannel 은 support library 에서 사용할 수 없다. 즉, 오레오 이전버전에서는 지원되지 않기 때문에 반드시 버전체크를 해줘야 한다.</p>
<p>NotificationChannel 을 생성할 때 요구되는 id, name, importance 그리고 description 에 대해 간략히 설명하면 다음과 같다.</p>
<ul>
<li>id : 각 채널을 구분할 수 있는 unique 한 값</li>
<li>name : 유저에게 표시되는 채널 이름</li>
<li>importance : 알림에 대한 중요도이며 이 값에 따라 알림의 동작이 달라진다. API 25 이하버전에서 사용되던 notification priority 개념과 동일. 각 importance 값에 따른 동작의 차이는 <a href="https://developer.android.com/training/notify-user/channels#importance" target="_blank" rel="noopener">importance level</a>에 잘 나와있다.</li>
<li>description : 채널에 대한 설명, 특정 채널 설정 창에서 표기됨</li>
</ul>
<h3 id="Notification-builder-생성-및-channel-id-등록"><a href="#Notification-builder-생성-및-channel-id-등록" class="headerlink" title="Notification builder 생성 및 channel id 등록"></a><strong>Notification builder 생성 및 channel id 등록</strong></h3><pre><code>NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(context, channelId);

    notificationBuilder
        .setSmallIcon(iconResource)
        .setContentTitle(title)
        .setContentText(content)
        .setPriority(NotificationCompat.PRIORITY_HIGH);

    // 기존 빌더에 Channel을 추가할 경우
    notificationBuilder
        .setSmallIcon(iconResource)
        .setContentTitle(title)
        .setContentText(content)
        .setChannlId(channlId)
        .setPriority(NotificationCompat.PRIORITY_HIGH);

    // 알림 생성!
    NotificationManagerCompat.from(context).notify(++notificationId, notificationBuilder.build());</code></pre><p>새롭게 알림 빌더를 구현할 경우 생성자에 channelId 를, 이미 사용하고 있는 빌더가 있다면 해당 빌더에 channel Id 를 추가해주면 된다. (내부 코드는 동일하다.)</p>
<p>setChannelId 을 이용하여 채널을 등록하는 방법을 택했을 때, API 25 이하 버전에서는 <code>null</code> 이 들어가겠지만 내부에서 무시되기 때문에 안심해도 된다.</p>
<h2 id="Notification-Channel-Tips"><a href="#Notification-Channel-Tips" class="headerlink" title="Notification Channel Tips"></a><strong>Notification Channel Tips</strong></h2><h3 id="채널은-딱-한번만-생성해주면-된다"><a href="#채널은-딱-한번만-생성해주면-된다" class="headerlink" title="채널은 딱 한번만 생성해주면 된다."></a><strong>채널은 딱 한번만 생성해주면 된다.</strong></h3><p>즉, 매번 알림을 만들때마다 채널을 다시 만들어줄 필요가 없다. 채널을 관리하는 유틸 클래스를 만들거나, application 클래스 등을 활용하여 재사용하는 방식으로 사용하면 된다.</p>
<h3 id="채널-정보-변경하기"><a href="#채널-정보-변경하기" class="headerlink" title="채널 정보 변경하기"></a><strong>채널 정보 변경하기</strong></h3><p>이미 등록되어 있는 채널의 정보를 다시 바꿀 수 있을까? 가능하다! 하지만, 바꿀 수 있는 정보는 <code>name</code>, <code>description</code> 뿐이며, 그외의 채널정보를 바꾸고 싶을 경우 해당 채널을 삭제한 후 새로운 정보를 가지고 있는 채널을 다시 생성해줘야 한다.</p>
<ul>
<li><p><strong>등록된 채널의 name, description 을 변경하고 싶을 경우</strong></p>
<p>  NotificationChannel notificationChannel = new NotificationChannel(uniqueId, newChannelName, importance);<br>  notificationChannel.setDescription(newDescription);</p>
<p>  NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);<br>  notificationManager.createNotificationChannel(notificationChannel);</p>
</li>
</ul>
<p>변경하고자 하는 name, description 을 가진 채널을 재등록해주면 된다. 이때 변경 전, 변경 후 채널 id가 동일한지 잘 확인하자.</p>
<ul>
<li><p><strong>등록된 채널을 삭제하고 싶을 경우</strong></p>
<p>  NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);<br>  notificationManager.deleteNotificationChannel(channelId);</p>
</li>
</ul>
<h3 id="Sound-설정도-잊지말자"><a href="#Sound-설정도-잊지말자" class="headerlink" title="Sound 설정도 잊지말자"></a><strong>Sound 설정도 잊지말자</strong></h3><ul>
<li><p>기존에는 builder 상에서 sound 설정을 해줬지만, 오레오 부터는 알림이 채널별로 관리되므로 sound 설정도 각 채널 별로 해줘야 한다.</p>
<p>  AudioAttributes audioAttributes = new AudioAttributes.Builder()</p>
<pre><code>.setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
.setUsage(AudioAttributes.USAGE_NOTIFICATION_RINGTONE)
.build();</code></pre><p>  notificationChannel.setSound(soundUri, audioAttributes);</p>
</li>
<li><p><code>setSound()</code> 메소드에는 2개의 인자가 들어가는데 첫번째, sound 는 기존에 사용하던 파일의 uri 를 넣어 주면된다. 두번째 <strong>AudioAttributes</strong> 가 이번에 새롭게 생긴 녀석인데, 위 코드와 같이 추가로 설정해주지 않으면 소리가 나오지 않는다.</p>
</li>
</ul>
<h2 id="추가로-알게된-사실들"><a href="#추가로-알게된-사실들" class="headerlink" title="추가로 알게된 사실들"></a><strong>추가로 알게된 사실들</strong></h2><ol>
<li><p><strong>priority 와 importance level 이 다를경우 무엇이 우선될까?</strong></p>
<p> 알림 빌더 생성시 API 25 이하 버전을 위해 priority 값을 반드시 설정해줘야 한다. 따라서 오레오(26) 이상의 버전은 importance 값과 priorty 값 모두 가지고 있게 되는데, 이때 (매우 드물겠지만) 각각의 값이 다를 경우 어떤 값을 따라갈까?</p>
<ul>
<li><p>importance 는 IMPORTANCE_HIGH 설정 (가장 높은 기대값)</p>
</li>
<li><p>priority 는 PRIORITY_MIN 설정 (가장 낮은 기대 값)</p>
<p>결과는 importance 를 따라감을 확인 했다.</p>
</li>
</ul>
</li>
<li><p><strong>설정한 importance / priority 값이 항상 알림의 동작을 결정한다고 보장할 수 없다.</strong></p>
<p> 위의 importance 값에 대해 설명할 때 해당 값이 알림의 동작을 결정한다고 얘기했었다. 그런데 이제와서 보장할 수 없다니?</p>
<p> docs 에서 이부분을 명확히 설명해주고 있다.</p>
</li>
</ol>
<blockquote>
<p>Although you must set the notification importance/priority as shown here, the system does not guarantee the alert behavior you’ll get. In some cases the system might change the importance level based other factors, and the user can always redefine what the importance level is for a given channel</p>
</blockquote>
<p>즉, 정리하면 importance / priority 값이 알림의 동작을 결정하는 것은 맞으나 <code>다양한 상황에서 해당 값이 바뀔 수 있으므로</code> 항상 설정해준 값대로 알림이 동작할 것이라고 판단하지 말라는 의미이다. 실제로 importance 값을 high 로 세팅한 channel 이 있어도 해당 channel 설정에서 중요도(importance) 값을 변경할 경우 high 가 아닌 가장 최근에 변경한 값으로 적용됨을 확인 할 수 있다. (사실 유저입장에서는 유저가 변경한 설정이 유지되는게 맞으므로 자연스러운 로직이다.)</p>
]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
