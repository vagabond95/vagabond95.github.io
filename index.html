<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vagabond95.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="내일 잊기전에 오늘 적어두는 블로그">
<meta property="og:type" content="website">
<meta property="og:title" content="기록은 기억을 지배한다">
<meta property="og:url" content="https://vagabond95.me/index.html">
<meta property="og:site_name" content="기록은 기억을 지배한다">
<meta property="og:description" content="내일 잊기전에 오늘 적어두는 블로그">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="기록은 기억을 지배한다">
<meta name="twitter:description" content="내일 잊기전에 오늘 적어두는 블로그">

<link rel="canonical" href="https://vagabond95.me/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>기록은 기억을 지배한다</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143694036-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-143694036-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head> 

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">기록은 기억을 지배한다</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">I Android you</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="list fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-til">

    <a href="https://progjh.gitbook.io/today-i-learned/" rel="noopener" target="_blank"><i class="fire fa-fw"></i>TIL</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/android_with_junit5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/android_with_junit5/" class="post-title-link" itemprop="url">[Android] Android with JUnit5 (번역)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-01 18:49:51 / Modified: 19:11:23" itemprop="dateCreated datePublished" datetime="2020-11-01T18:49:51+09:00">2020-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cover/junit5.png" alt></p>
<p>본 글은 저자의 허락을 받고 해당 <a href="https://medium.com/@boonkeat/android-unit-testing-with-junit5-d1b8f9c620b6" target="_blank" rel="noopener">글</a>을 번역한 내용이다. 부족한 영어 실력으로 의역한 부분이 많아 본 저자의 의도와 다르게 작성된 부분이 있을 수 있는 점에 대해 미리 양해를 구한다.</p>
<p>Android 진영에서 작성되는 대부분의 단위 테스트는 Android Studio 에서 제공되는 JUnit4 를 이용하여 작성된다. 이러한 테스트 케이스에 대해 우리가 직면했던 큰 문제중 하나는 <strong>가독성</strong> 이슈였다. 일반적인 프로젝트에서 단위 테스트의 개수는 1000개 혹은 그 이상을 넘기기 쉬운데, 이러한 다수의 테스트 케이스가 있을 때 이에 대한 이름을 어떻게 지을 것인지가 문제였다. 네이밍이 잘못될 경우 테스트가 실패했을 때마다 해당 테스트가 무엇을 수행하는지 알기 위해 많은 에너지를 써야하기 때문이다.</p>
<p>이때 Junit5 을 사용할 경우 단위 테스트가 잘 문서화 될 수 있다.</p>
<p>해당 글은 두 부분으로 나뉜다.</p>
<p>첫 번째 파트에서는 테스트 케이스 네이밍 방법 및 JUnit5를 사용하는 동기에 대해 다룬다.<br>두 번째 파트는 Android 용 JUnit5 테스트를 작성하는 방법을 다룬다.</p>
<h1 id="네이밍-발전-과정"><a href="#네이밍-발전-과정" class="headerlink" title="네이밍 발전 과정"></a>네이밍 발전 과정</h1><p>처음 테스트 코드 작성 시 우리는 다음과 같이 이름을 짓게된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testWhenButtonClickedThenIfFlagTrueLaunchActivity</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>노력하면 가능할지도 모르지만, 일반적으로 이러한 네이밍의 테스트 코드를 볼 때 해당 테스트 클래스가 모든 케이스를 다루는지 확인 것은 꽤 힘이 드는 일이다. 해당 예제에서는 하나의 플래그만 다루지만, 만약 또다른 조건이 있다면? 수백개의 테스트 케이스를 거치면 머리가 지끈거릴 것이다.</p>
<p>그리고 우리는 코틀린에서 아래와 같이 표현이 가능함을 알게되었다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `When button <span class="keyword">is</span> clicked, If flag <span class="keyword">is</span> <span class="literal">true</span>, then launch activity`<span class="params">()</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>또한 많은 사람들이 <a href="https://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank" rel="noopener">BDD</a> 방식으로 테스트를 네이밍 하기위해 노력하고 있는 것을 알기에 조건(Given), 실행(When), 예상 결과(Then) 방식으로도 작성을 해봤다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `Given flag <span class="keyword">is</span> <span class="literal">true</span>, When button <span class="keyword">is</span> clicked, Then activity <span class="keyword">is</span> launched`<span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `Given flag <span class="keyword">is</span> <span class="literal">false</span>, When button <span class="keyword">is</span> clicked, Then activity <span class="keyword">is</span> not launched`<span class="params">()</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>초기 표현보다 좀 더 나아보인다. 하지만 아래와 같이 조건이 여러 개일 경우 여전히 읽는데 어려움이 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `Given flag <span class="keyword">is</span> <span class="literal">true</span> and listener <span class="literal">null</span> and user <span class="keyword">is</span> logged <span class="keyword">out</span>, When button <span class="keyword">is</span> clicked, Then activity <span class="keyword">is</span> launched and listener not called`<span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> `Given flag <span class="keyword">is</span> <span class="literal">true</span> and listener not <span class="literal">null</span> and user <span class="keyword">is</span> logged <span class="keyword">out</span>, When button <span class="keyword">is</span> clicked, Then activity <span class="keyword">is</span> launched and listener not called`<span class="params">()</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>위 테스트에서 ‘유저가 로그아웃 되어있는 동안은 리스너가 호출되지 않음’ 라는 사실을 쉽게 알 수 있었을까?</p>
<p>Android Studio 에서 이러한 형태의 테스트를 실행하면 다음과 같이 출력된다.<br><img src="/images/post/android_with_junit5/junit.png" alt></p>
<p>수백개의 테스트 케이스를 가지고 있을 때 * test suite 는 단순히 코드를 전달하는 블랙박스가 된다. test suite 는 유용하지만 한편으로는 거대한 미로와 같다. 테스트 케이스가 실패했을 때 원인을 파악하기 위해서는 많은 비용이 발생한다.</p>
<p>*Test suite : 그룹화 된 테스트 케이스</p>
<h1 id="잘-문서화-된-테스트-with-JUnit5"><a href="#잘-문서화-된-테스트-with-JUnit5" class="headerlink" title="잘 문서화 된 테스트 with JUnit5"></a>잘 문서화 된 테스트 with JUnit5</h1><p>JUnit5 에는 많은 기능이 새로 도입 되었고, 특히 다음 두 가지 기능이 안드로이드 테스트를 구성할 때 큰 도움이 된다.</p>
<ul>
<li>Nested Classes</li>
<li>Display Name</li>
</ul>
<p>세션 데이터의 상태에 따라 로그인/로그아웃이 되는 케이스에 대해 살펴보자.</p>
<p>순서대로 JUnit4, JUnit5 로 작성했을 때의 결과다.<br><img src="/images/post/android_with_junit5/junit2.png" alt><br><img src="/images/post/android_with_junit5/junit3.png" alt></p>
<p>JUnit 5 의 경우 테스트 내의 각 상황을 명확하게 인지할 수 있다. 추가로 로그인 상태에 따라 리스너가 호출되는 것을 확인하고 싶을 경우는 어떻게 할까?</p>
<p><img src="/images/post/android_with_junit5/junit4.png" alt></p>
<p>누군가는 ‘단위’라는 맥락에서 볼 때 두 개 이상을 검증해서는 안된다고 주장할 수 있다. OK. 그렇다면 각각의 검증내용을 분리해보자.</p>
<p><img src="/images/post/android_with_junit5/junit5.png" alt></p>
<p>여기서 JUnit5 을 이용할 경우 무엇을 검증하는지 더 잘 파악할 수 있다.</p>
<p><img src="/images/post/android_with_junit5/junit6.png" alt></p>
<p>어떤 형태가 더 나은지 스스로 판단해보자. (특히 테스트가 실패했을 경우)</p>
<p><img src="/images/post/android_with_junit5/junit7.png" alt></p>
<p><img src="/images/post/android_with_junit5/junit8.png" alt></p>
<p>다음으로 안드로이드 내에서 어떻게 JUnit5 을 활용하여 테스트를 작성하는지 알아보자.</p>
<h1 id="JUnit-5-적용하기"><a href="#JUnit-5-적용하기" class="headerlink" title="JUnit 5 적용하기"></a>JUnit 5 적용하기</h1><p>JUnit5 의 컨셉과 적용 방법에 대해 자세하게 다룬 훌륭한 <a href="https://www.lordcodes.com/articles/testing-on-android-using-junit-5" target="_blank" rel="noopener">글</a> 이 이미 있다. 해당 글에서는 몇가지 간단한 내용만 다룰 것이다.</p>
<h2 id="Gradle-설정"><a href="#Gradle-설정" class="headerlink" title="Gradle 설정"></a>Gradle 설정</h2><p><a href="https://github.com/mannodermaus" target="_blank" rel="noopener">Marcel Schnelle</a>이 만든 Gradle plugin 을 이용할 예정이다.</p>
<p>우선 root 레벨의 build.gradle 에 다음과 같이 플러그인을 추가한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  dependencies &#123;</span><br><span class="line">    classpath &quot;de.mannodermaus.gradle.plugins:android-junit5:1.3.2.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그리고 app 레벨의 bulid gradle 에 다음과 같이 plugin 을 적용하고 의존성을 추가한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;de.mannodermaus.android-junit5&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">  testImplementation &quot;org.junit.jupiter:junit-jupiter-api:5.3.2&quot;</span><br><span class="line">  testRuntimeOnly &quot;org.junit.jupiter:junit-jupiter-engine:5.3.2&quot;</span><br><span class="line">  testImplementation &quot;org.junit.jupiter:junit-jupiter-params:5.3.2&quot;</span><br><span class="line">  testRuntimeOnly &quot;org.junit.vintage:junit-vintage-engine:5.3.2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이 설정은 프로젝트에서 JUnit4 와 JUnit5 를 동시에 사용할 수 있도록 해준다. </p>
<h2 id="테스트-클래스"><a href="#테스트-클래스" class="headerlink" title="테스트 클래스"></a>테스트 클래스</h2><p>다음으로 Junit5 으로 작성한 테스트 클래스에 대해 살펴보자. 아래 클래스는 빈 클래스인데 아마 익숙한 형태일 것이다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJunitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">tearDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@BeforeEach 가 붙은 함수에서는 초기화 작업을 수행할 수 있다. 또한 해당 함수는 nested 여부와 상관없이 각 테스트 함수가 수행되기전에 항상 호출 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJunitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mockUserSession: UserSession = mockk()</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> dut: MyClass</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        dut = MyClass(mockUserSession)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">resetMocks</span><span class="params">()</span></span> &#123;</span><br><span class="line">        clearMocks(mockUserSession)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>예제는 given, when, then 규칙에 맞추어 테스트 코드를 작성할 것이다. 해당 예제는 sessionData 의 유효성을 검사할 것이다. <strong>given</strong> 케이스에 해당하는 2개의 nested 클래스를 만들어준다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJunitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mockUserSession: UserSession = mockk()</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> dut: MyClass</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        dut = MyClass(mockUserSession)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">resetMocks</span><span class="params">()</span></span> &#123;</span><br><span class="line">        clearMocks(mockUserSession)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">"Given SessionData is valid"</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDataValid</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">"Given SessionData is not valid"</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDataNotValid</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>각 nested 클래스는 각각 별도의 setup, teardown 함수를 소유할 수 있다. 각 클래스에 서로 다른 결과를 리턴하는 초기화 로직을 넣어보자. </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJunitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mockUserSession: UserSession = mockk()</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> dut: MyClass</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">        dut = MyClass(mockUserSession)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">resetMocks</span><span class="params">()</span></span> &#123;</span><br><span class="line">        clearMocks(mockUserSession)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">"Given SessionData is valid"</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDataValid</span> </span>&#123;</span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">            every &#123; mockUserSession.isValid() &#125; returns <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">"Given SessionData is not valid"</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDataNotValid</span> </span>&#123;</span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">            every &#123; mockUserSession.isValid() &#125; returns <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그 다음 <strong>when</strong> 케이스에 해당하는 클래스를 생성해보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJunitTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">"Given SessionData is valid"</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDataValid</span> </span>&#123;</span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">            every &#123; mockUserSession.isValid() &#125; returns <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(<span class="meta-string">"When onAppStart()"</span>)</span></span><br><span class="line">        <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">OnAppStart</span></span>() &#123;</span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">runTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">                dut.onAppStart()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>마지막으로 결과를 검증하는 then 케이스에 해당하는 테스트 함수를 추가해보자.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJunitTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">"Given SessionData is valid"</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDataValid</span> </span>&#123;</span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">            every &#123; mockUserSession.isValid() &#125; returns <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(<span class="meta-string">"When onAppStart()"</span>)</span></span><br><span class="line">        <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">OnAppStart</span></span>() &#123;</span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">runTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">                dut.onAppStart()</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(<span class="meta-string">"Then state changes to logged in"</span>)</span></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">verifyLoggedIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// Add code to verify state change</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* other verifications or assertions *.</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>해당 테스트를 수행할 경우 아래와 같은 결과로 나타난다. </p>
<p><img src="/images/post/android_with_junit5/junit9.png" alt></p>
<p>다음과 같이 Nested 구조를 줄인 형태로도 구현할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJunitTest</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(<span class="meta-string">"Given SessionData is not valid"</span>)</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDataValid</span> </span>&#123;</span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">            every &#123; mockUserSession.isValid() &#125; returns <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(<span class="meta-string">"When onAppStart(), then state changes to logged in"</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">verifyLoggedIn</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Add code to verify state change</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(<span class="meta-string">"When onDestroy(), then flag changes to false"</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">verifyFlagChange</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Add code to verify state change</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/post/android_with_junit5/junit10.png" alt></p>
<p>이런 식으로 작업할 경우 테스트 케이스를 디자인하는데 도움을 얻을 수 있다. 가령 다음과 같이 검증과정을 누락했을 경우 빠르게 확인이 가능하다.</p>
<p>When onDestroy(), then flag change to ?</p>
<p>한편 조건이나 검증해야 할 내용이 많을 경우 각 그룹을 명확하게 Nested 된 구조로 구성하는 것이 좀 더 낫다. 특정 조건에 대해 얼마나 잘 수행되었는지 파악하기가 더 수월하기 때문이다.</p>
<p><img src="/images/post/android_with_junit5/junit11.png" alt></p>
<p><img src="/images/post/android_with_junit5/junit12.png" alt></p>
<p><strong>@Nested</strong> 클래스는 단순히 결과를 보기 좋게하기 위해 사용하는 것은 아니다. <strong>@Nested</strong> 클래스 는 각각 고유의 <strong>@BeforeEach</strong>, <strong>@AfterEach</strong> 를 수행할 수 있기 때문에 비슷한 범주에 속한 테스트를 같이 그룹화시킬 수 있다.</p>
<p>예를들어 5개의 테스트가 동일한 초기화 코드를 가지고 있을 경우 <strong>@Nested</strong> 클래스 내부에 넣고 하나의 <strong>@BeforeEach</strong> 에서 수행이 가능하다. 이때 클래스 이름은 적절하게 네이밍 되어야한다.</p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>해당 내용들은 Junit 5 의 일부분일 뿐이다. 미처 언급되지 않았지만 유용한 것들이 아직 많이 있다. 다른 개발자가 좀 더 쉽게 이해할 수 있도록 테스트 클래스를 디자인 하기 위해 지금 시작해보는 것은 어떨까?</p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/lambda_with_effectively_final/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/lambda_with_effectively_final/" class="post-title-link" itemprop="url">[Java] lambda 와 effectively final</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-28 17:30:07 / Modified: 17:36:40" itemprop="dateCreated datePublished" datetime="2020-09-28T17:30:07+09:00">2020-09-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cover/lambda_with_effectively_final.jpg" alt><br>자바 8에서 추가된 람다식에는 다음과 같은 규칙이 존재한다.</p>
<ol>
<li>람다식은 외부 block 에 있는 변수에 접근할 수 있다.</li>
<li>외부에 있는 변수가 지역 변수 일 경우 final 혹은 effectively final 인 경우에만 접근이 가능하다.</li>
</ol>
<p>이번 포스트에서는 effectively final 의 정의와 람다식에서 final or effectively final 인 외부 지역 변수만 사용할 할 수 밖에 없는 이유에 대해서 알아보려 한다.</p>
<h1 id="Effectively-final-이란-무엇인가"><a href="#Effectively-final-이란-무엇인가" class="headerlink" title="Effectively final 이란 무엇인가?"></a>Effectively final 이란 무엇인가?</h1><blockquote>
<p>A non-final local variable or method parameter whose value is never changed after initialization is known as effectively final.</p>
</blockquote>
<p>Java 8 에 추가된 syntactic sugar 일종으로, <strong>초기화 된 이후 값이 한번도 변경되지 않았다면</strong> effectively final 이라고 할 수 있다. effectively final 변수는 final 키워드가 붙어있지 않았지만 final 키워드를 붙힌 것과 동일하게 컴파일러에서 처리한다. <strong>‘의미상 final 하다.’</strong> 고 이해해도 괜찮을 것 같다.</p>
<h2 id="적용-사례"><a href="#적용-사례" class="headerlink" title="적용 사례"></a>적용 사례</h2><p>Effectively final 은 anonymous class 나 람다식에서 코드를 좀 더 간결하게 만들어준다.</p>
<p>java 7 에서는 anonymous class 가 외부지역변수 가 final 인 경우에만 접근이 가능했기에 항상 final 키워드를 추가해줘야 했다. java 8 에서는 effectively final 인 경우에도 접근이 가능하게 바뀌어 조건을 만족한다면 final 키워드를 생략할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Addable addableImple = <span class="keyword">new</span> Addable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// Effectively final</span></span><br><span class="line"></span><br><span class="line">        Addable addableImple = <span class="keyword">new</span> Addable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">plusOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> number + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이는 lambda 식에서도 동일하다. (규칙 2를 상기해보자.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java 8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// Effectively final</span></span><br><span class="line"></span><br><span class="line">    Addable addableImple = () -&gt; number + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lambda-에서-사용되는-Local-variable-은-왜-final-or-effectively-final-이여야-할까"><a href="#lambda-에서-사용되는-Local-variable-은-왜-final-or-effectively-final-이여야-할까" class="headerlink" title="lambda 에서 사용되는 Local variable 은 왜 final or effectively final 이여야 할까?"></a>lambda 에서 사용되는 Local variable 은 왜 final or effectively final 이여야 할까?</h1><p>각 단계별로 설명하기 위해 내용이 꽤 긴데,  결론 부분만 보아도 괜찮다.</p>
<h2 id="먼저-확실히-정리할-것"><a href="#먼저-확실히-정리할-것" class="headerlink" title="먼저 확실히 정리할 것"></a>먼저 확실히 정리할 것</h2><p>헷갈릴 수 있는 표현을 먼저 정리하고자 한다. 해당 내용을 다루는 몇몇 글에서 ‘람다식에서 참조하는 <strong>외부 변수</strong>는 final 혹은 effectively final 이어야한다.’ 라고 표현되는 것을 보았는데 이는 엄밀히 얘기하면 틀린 내용이다.</p>
<p>정확한 내용으로 수정하면 다음과 같다.</p>
<p>‘람다식에서 참조하는 <strong>외부 지역 변수</strong>는 final 혹은 effectively final 이어야한다.’</p>
<p>외부 변수라는 단어에는 지역변수, 인스턴스 변수, 클래스 변수가 모두 포함될 수 있는데,  인스턴스 변수나 클래스 변수는 final 혹은 effective final 하지 않아도 람다식에서 사용할 수 있기 때문이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> instanceNumber = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticNumber = <span class="number">1</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// Error, 외부 지역변수는 final 혹은 effectively final 이어야 람다식에서 사용할 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlusByLocalVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> localNumber = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    localNumber = <span class="number">2</span>;</span><br><span class="line">    Addable addableImple = () -&gt; localNumber + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, 값을 변경하더라도 문제 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlusByInstanceVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    instanceNumber = <span class="number">2</span>;</span><br><span class="line">    Addable addableImple = () -&gt; instanceNumber + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, 값을 변경하더라도 문제 없다.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlusByStaticVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    staticNumber = <span class="number">2</span>;</span><br><span class="line">    Addable addableImple = () -&gt; staticNumber + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>너무 깐깐하다고 생각할 수 있지만 이 차이는 뒤에 설명될 내용과 밀접한 연관이 있기 때문에 미리 정확히 구분하는 것이 중요하다.</p>
<p>다시 해당 섹션의 주제로 돌아가서, 람다식에서 사용되는 지역변수가 final or effective final 이어야하는 이유를 알기 위해서는 Capturing lambda 라는 키워드를 살펴볼 필요가 있다.</p>
<h2 id="Capturing-lambda-와-Non-Capturing-lambda"><a href="#Capturing-lambda-와-Non-Capturing-lambda" class="headerlink" title="Capturing lambda 와 Non-Capturing lambda"></a>Capturing lambda 와 Non-Capturing lambda</h2><p>람다식에는 2가지 타입이 존재한다.</p>
<ul>
<li><p><strong>Capturing lambda</strong></p>
<p>  외부 변수를 이용하는 람다식을 의미한다. 외부 변수는 지역변수, 인스턴스 변수, 클래스 변수를 모두 포함한다.</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String message = <span class="string">"CapturingLambda"</span>;</span><br><span class="line">Runnable runnable = () -&gt; System.out.println(message);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Non-Capturing lambda</strong></p>
<p>  외부 변수를 이용하지 않는 람다식을 의미한다.</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = () -&gt; System.out.println(<span class="string">"NonCapturingLambda"</span>);</span><br><span class="line"></span><br><span class="line">Runnable runnable = () -&gt; &#123;</span><br><span class="line">    String message = <span class="string">"NonCapturingLambda"</span>;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Capturing lambda 는 다시 local capturing lambda 와 non - local capturing lambda 로 구분할 수 있다.  local 과 non - local 로 구분하는 이유는 지역 변수가 가지는 특징으로 인해 내부 동작 방식이 다르기 때문이다.</p>
<h2 id="Local-Capturing-lambda"><a href="#Local-Capturing-lambda" class="headerlink" title="Local Capturing lambda"></a>Local Capturing lambda</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlusByLocalVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> localNumber = <span class="number">1</span>;</span><br><span class="line">    Addable addableImple = () -&gt; localNumber + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>외부 변수로 지역 변수를 이용하는 람다식을 의미한다. 다음과 같은 특징이 있다.</p>
<ol>
<li>람다식에서 사용되는 외부 지역 변수는 <strong>복사본이다</strong>.</li>
<li>final 혹은 effectively final 인 지역 변수만 람다식에서 사용할 수 있다.</li>
<li>복사된 지역 변수 값은 람다식 내부에서도 변경할 수 없다. 즉 final 변수로 다뤄야 한다.</li>
</ol>
<p>각 특징이 생기는 이유를 하나씩 살펴보자.</p>
<h3 id="1-람다식에서-사용되는-외부-지역변수는-복사본이다"><a href="#1-람다식에서-사용되는-외부-지역변수는-복사본이다" class="headerlink" title="1. 람다식에서 사용되는 외부 지역변수는 복사본이다."></a>1. 람다식에서 사용되는 외부 지역변수는 <strong>복사본이</strong>다.</h3><p>람다식에서는 외부 지역변수를 그대로 사용하지 못하고 복사본을 사용하는 이유는 다음과 같다.</p>
<ul>
<li><p>지역 변수는 스택 영역에 생성된다. 따라서 지역 변수가 선언된 block 이 끝나면 스택에서 제거된다.</p>
<p>  → 메소드 내 지역 변수를 참조하는 람다식을 리턴하는 메소드가 있을 경우, 메소드 block 이 끝나면 지역 변수가 스택에서 제거 되므로 추후에 람다식이 수행될 때 참조할 수 없다.</p>
</li>
<li><p>지역 변수를 관리하는 쓰레드와 람다식이 실행되는 쓰레드가 다를 수 있다.</p>
<p>  → 스택은 각 쓰레드의 고유의 공간이고, 쓰레드끼리 공유되지 않기 때문에 마찬가지로 람다식이 수행될 때 값을 참조할 수 없다.</p>
</li>
</ul>
<p>위와 같은 이유로 인해 람다식에서는 외부 지역 변수를 직접 참조하지 않고 복사본을 전달받아 사용하게 된다.</p>
<h3 id="2-final-혹은-effectively-final-인-지역-변수만-람다식에서-사용할-수-있다"><a href="#2-final-혹은-effectively-final-인-지역-변수만-람다식에서-사용할-수-있다" class="headerlink" title="2. final 혹은 effectively final 인 지역 변수만 람다식에서 사용할 수 있다."></a>2. final 혹은 effectively final 인 지역 변수만 람다식에서 사용할 수 있다.</h3><p>오늘의 핵심 주제에 드디어 도달했다.</p>
<p>만약 참조하고자 하는 지역 변수가 final 혹은 effectively final 이 아닐 경우 즉, 변경이 가능할 경우 어떤 문제가 발생할 수 있는지 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executelocalVariableInMultiThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> shouldRun = <span class="keyword">true</span>;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (shouldRun) &#123;</span><br><span class="line">            <span class="comment">// do operation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    shouldRun = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>람다식이 어떤 쓰레드에서 수행될지는 미리 알 수 없다. 이 얘기는 곧 외부 지역 변수를 다루는 쓰레드와 람다식이 수행되는 쓰레드가 다를 수 있다는 의미이다. 지역 변수 값(shouldRun) 을 제어하는 쓰레드 A, 람다식을 수행되는 쓰레드 B 가 있다고 가정하자. 문제는 다음과 같다.</p>
<p>쓰레드 B의 shouldRun 값이 가장 최신 값으로 복사되어 전달 됐는지 확신할 수 없다는 것이다. <strong>왜냐하면 shouldRun 은 변경이 가능한 지역 변수이고, 지역 변수를 쓰레드 간에 sync 해주는 것은 불가능 하기 때문이다.</strong>   (지역 변수는 쓰레드 A 의 스택 영역에 존재하기 때문에 다른 쓰레드에서 접근이 불가능하다. volatile 과 같은 키워드가 로컬 변수에서 사용될 수 없는 이유도 이와 같다.) </p>
<p>값이 보장되지 않는다면 매번 다른 결과가 도출 될 수 있다. 예측할 수 없는 코드가 의미가 있을까?<br>이러한 이유로 인해 외부 지역 변수는 전달되는 복사본이 변경되지 않은 최신 값 임을 보장하기 위해 fianl 혹은 effectively final 이어야 한다.</p>
<h3 id="3-복사된-지역-변수-값은-람다식-내부에서도-변경할-수-없다-즉-final-변수로-다뤄야-한다"><a href="#3-복사된-지역-변수-값은-람다식-내부에서도-변경할-수-없다-즉-final-변수로-다뤄야-한다" class="headerlink" title="3. 복사된 지역 변수 값은 람다식 내부에서도 변경할 수 없다. 즉 final 변수로 다뤄야 한다."></a>3. 복사된 지역 변수 값은 람다식 내부에서도 변경할 수 없다. 즉 final 변수로 다뤄야 한다.</h3><p>처음에는 이미 복사가 된 값이므로 변경해도 문제가 없는 것 아닌가? nope.<br>복사될 값의 변조를 막아 최신 값임을 보장하기 위해 final 제약을 걸었는데 람다식 내부에서 변경이 가능할 경우 다시 제자리로 돌아오게 된 격이다. 또한 컴파일 된 람다식은 static 메소드 형태로 변경이 되는데, 이때 복사된 값이 파라미터로 전달되므로 마찬가지로 스택영역에 존재하기 때문에 sync 를 해주는 것도 불가능하다. 따라서 람다식 내부에서도 값이 변경 되어서는 안된다.</p>
<p>컴파일러 레벨에서 앞, 뒤로 final 제약을  걸어줌으로써 멀티 쓰레드 환경에서 대응하기 어려운 이슈를 미연에 방지했다.</p>
<h2 id="Non-local-capturing-lambda"><a href="#Non-local-capturing-lambda" class="headerlink" title="Non - local capturing lambda"></a>Non - local capturing lambda</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> instanceNumber = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> staticNumber = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlusByInstanceVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    instanceNumber = <span class="number">2</span>;</span><br><span class="line">    Addable addableImple = () -&gt; instanceNumber + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPlusByStaticVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    staticNumber = <span class="number">2</span>;</span><br><span class="line">    Addable addableImple = () -&gt; staticNumber + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>외부 변수로 인스턴스 변수 혹은 클래스 변수를 이용하는 람다식을 의미한다. local capturing lambda 와 다르게 final 제약 조건이 없고, 외부 변수 값도 복사하지 않는다. </p>
<p>이유는 인스턴스 변수나 클래스 변수를 저장하고 있는 메모리 영역은 공통 영역이고 값이 메모리에서 바로 회수되지 않기 때문에 람다식에서 바로 참조가 가능하다. 따라서 복사 과정이 불필요하고 참조 시 최신 값 임을 보장할 수 있다. 다만 멀티 쓰레드 환경일 경우 volatile, synchronized 등을 이용하여 sync 를 맞춰주는 작업을 잊어서는 안된다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>람다식에서 외부 지역 변수를 이용할 경우 final 혹은 effectively final 이어야 하는 이유는 지역 변수가 스택에 저장되기 때문에 람다식에서 값을 바로 참조하는 것에 제약이 있어 복사된 값을 이용하게 되는데, 이때 멀티 쓰레드 환경에서 복사 될/복사된 값이 변경 가능 할 경우 이로 인한 동시성 이슈를 대응할 수 없기 때문이다.</p>
<h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p><a href="https://www.baeldung.com/java-effectively-final" target="_blank" rel="noopener">https://www.baeldung.com/java-effectively-final</a></p>
<p><a href="https://www.baeldung.com/java-lambda-effectively-final-local-variables" target="_blank" rel="noopener">https://www.baeldung.com/java-lambda-effectively-final-local-variables</a></p>
<p><a href="https://dzone.com/articles/how-lambdas-and-anonymous-inner-classesaic-work" target="_blank" rel="noopener">https://dzone.com/articles/how-lambdas-and-anonymous-inner-classesaic-work</a></p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/adb_starter_guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/adb_starter_guide/" class="post-title-link" itemprop="url">[Android] adb 기본 가이드</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-16 21:49:19 / Modified: 21:56:28" itemprop="dateCreated datePublished" datetime="2020-08-16T21:49:19+09:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cover/adb_starter_guide.jpg" alt><br>대부분의 디버깅 작업은 안드로이드 스튜디오 내부 디버거와 프로파일러를 이용하면 진행이 가능하기 때문에 adb 의 필요성을 크게 느끼지 못했다. 그런데 간혹 스튜디오 도구만으로는 해결이 어렵거나 애매한 케이스들을 맞이할 상황이 생겼고, 깊게 파보다 보니 adb 를 이용해 디버깅 할 수 있다는 사실을 알게 되었다.</p>
<p>사실 같은 작업을 수행한다면 커맨드 라인보다 GUI 를 선호해서 그런지 adb 와 그리 친숙하지 않았는데, 공부하다보니 제법 유용한 기능이 많아서 이번 기회에 간단히 정리를 했다.</p>
<h1 id="시작하기-전에"><a href="#시작하기-전에" class="headerlink" title="시작하기 전에"></a>시작하기 전에</h1><p>adb 를 이용하기 전에 2가지 작업이 선행되어야 한다.</p>
<p><strong>1. 환경변수 설정</strong></p>
<p>adb 명령을 편하게 사용하기 위해서는 환경변수 설정이 필수다. MAC/window 별 설정 방법은 이미 자세히 설명되어있는 글들이 많으므로 생략한다.</p>
<p><strong>2. USB 디버깅 허용</strong></p>
<p>개발자 옵션 - USB 디버깅 항목에 대해 on 을 해줘야 adb - 기기간 통신이 가능해진다.</p>
<h1 id="기본"><a href="#기본" class="headerlink" title="기본"></a>기본</h1><p>가장 많이 사용했던 명령어 및 상황을 정리해봤다.</p>
<h2 id="디바이스-조회"><a href="#디바이스-조회" class="headerlink" title="디바이스 조회"></a>디바이스 조회</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb devices [-l]</span><br></pre></td></tr></table></figure>

<p>위 명령은 adb 서버에 연결된 디바이스의 시리얼 넘버와 상태를 차례로 출력한다.</p>
<p>상태는 아래와 같은 케이스가 있다.</p>
<ul>
<li><strong>device</strong> : 정상적으로 연결되어 있다. 하지만 시스템이 부팅되는동안 adb 에 연결이 되기 때문에 시스템 부팅이 완료되었다고 보장하는 상태는 아니다.</li>
<li><strong>no device</strong> : 연결되어있는 디바이스가 없다.</li>
<li><strong>offline</strong> : 기기가 adb 에 연결되어 있지 않다. usb 선에 문제가 있는지 살펴보자.</li>
<li><strong>unauthorized</strong> : USB 디버깅이 허용되지 않은 기기이다.</li>
</ul>
<h3 id="특정-디바이스에-명령을-해야할-때"><a href="#특정-디바이스에-명령을-해야할-때" class="headerlink" title="특정 디바이스에 명령을 해야할 때"></a>특정 디바이스에 명령을 해야할 때</h3><p>연결되어있는 디바이스가 1개라면 별도 옵션 추가 없이 adb 명령어를 사용할 수 있다. 그러나 연결된 디바이스가 2개이상일 경우, 이전에 사용한 명령어를 입력하면 어느 기기를 기준으로 adb 명령이 수행되어야 하는 알 수 없기 때문에 아래와 같은 에러가 발생한다.</p>
<blockquote>
<p>“more than one device/emulator”</p>
</blockquote>
<p>옵션과 시리얼 넘버를 이용하여 해결이 가능하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 연결된 디바이스 정보 확인</span><br><span class="line">&gt; adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">SM1234            device</span><br><span class="line">emulator-1234     device</span><br><span class="line"></span><br><span class="line">// -s 옵션, 특정 디바이스 를 지정한 후 명령어 수행</span><br><span class="line">&gt; adb -s SM1234 shell <span class="variable">$command</span></span><br><span class="line"></span><br><span class="line">// -d 옵션, 연결된 하드웨어 디바이스가 1개라면 자동 지정 후 명령어 수행</span><br><span class="line">&gt; adb -d shell <span class="variable">$command</span></span><br><span class="line"></span><br><span class="line">// -e 옵션, 연결된 에뮬레이터 디바이스가 1개라면 자동 지정 후 명령어 수행</span><br><span class="line">&gt; adb -e shell <span class="variable">$command</span></span><br></pre></td></tr></table></figure>

<h2 id="adb-초기화"><a href="#adb-초기화" class="headerlink" title="adb 초기화"></a>adb 초기화</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb <span class="built_in">kill</span>-server</span><br></pre></td></tr></table></figure>

<p>adb 서버 프로세를 kill 한다. adb 가 먹통일 때 주로 사용한다. 어떤 adb 명령어든 다시 입력하면 서버가 재시작한다.</p>
<h2 id="기기에-기기에서-파일-복사"><a href="#기기에-기기에서-파일-복사" class="headerlink" title="기기에/기기에서 파일 복사"></a>기기에/기기에서 파일 복사</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 디바이스에서 개발 머신으로 파일 복사</span><br><span class="line">&gt; adb pull <span class="variable">$devicePath</span> <span class="variable">$macihnePath</span></span><br><span class="line"></span><br><span class="line">// 개발 머신에서 디바이스로 파일 복사</span><br><span class="line">&gt; adb push <span class="variable">$machinePath</span> <span class="variable">$devicePath</span></span><br></pre></td></tr></table></figure>

<p>디바이스의 host 파일을 변경할 때 유용하게 활용했다.</p>
<h1 id="dumpsys"><a href="#dumpsys" class="headerlink" title="dumpsys"></a>dumpsys</h1><p>adb 는 shell 명령어로 직접 기기를 제어하거나 기기정보를 가져올 수 있다. dumpsys 명령은 연결된 기기의 시스템 서비스 정보를 가져올 수 있다. 가장 기본적인 명령어를 입력하면 너무 방대한 정보가 한꺼번에 출력되기 때문에 다양한 옵션과 grep 을 적절히 활용하여 필요한 정보만 꺼내보는 지혜가 필요하다. 직접 활용하고 있는 몇가지 케이스에 대해서만 다룰예정이다.</p>
<h2 id="Acitivty-stack-출력하기"><a href="#Acitivty-stack-출력하기" class="headerlink" title="Acitivty stack 출력하기"></a>Acitivty stack 출력하기</h2><p>Activity stack 이 깊고 복잡할수록 디버깅이 힘들어진다. adb 의 존재를 알기 전에는 스택의 구성을 알아내기 위해 하나하나 백버튼을 눌러봤던 기억이 있다. </p>
<p>activity stack 을 볼 수 있는 기본 명령은 다음과 같다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell dumpsys activity activities</span><br></pre></td></tr></table></figure>

<p>그런데 위 명령은 현재 디바이스에서 활성화되어있는 모든 앱에대한 Acitivty 정보를 가져오기 때문에 필요한 정보를 금방 파악하기 어렵다. </p>
<p>우리가 알고 싶은 것은 특정 앱에 대한 Activity stack 이므로 필터링이 필요하다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell dumpsys activity activities | grep -i <span class="variable">$packageName</span> | grep -i Hist</span><br></pre></td></tr></table></figure>

<p>명령어의 결과는 다음과 같다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Hist <span class="comment">#1: ActivityRecord&#123;692b031 u0 com.android.settings/.SubSettings t630&#125;</span></span><br><span class="line">* Hist <span class="comment">#0: ActivityRecord&#123;8e296f3 u0 com.android.settings/.homepage.SettingsHomepageActivity t630&#125;</span></span><br></pre></td></tr></table></figure>

<p>Hist (History) 의 숫자가 낮을수록 stack 에 먼저 추가된 Activity 이다. Hist 숫자가 가장 큰 Activity 가 현재 화면상에 나타나는 Activity 이므로, 현재 화면의 Activity 이름을 찾을때도 유용하게 활용할 수 있다.</p>
<h2 id="Doze-앱-대기-모드-테스트"><a href="#Doze-앱-대기-모드-테스트" class="headerlink" title="Doze, 앱 대기 모드 테스트"></a>Doze, 앱 대기 모드 테스트</h2><p>간혹 Doze 모드, 앱 대기 모드로 인한 이슈를 확인해야할 상황이 생긴다. 문제는 각 조건을 충족하여 모드를 재현하는 것이 꽤나 수고스러운 일이라는 점이다. 이를 대비하여 adb 에서는 각 모드로 진입할 수 있는 명령어를 제공한다.</p>
<h3 id="Doze-모드-테스트"><a href="#Doze-모드-테스트" class="headerlink" title="Doze 모드 테스트"></a>Doze 모드 테스트</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell dumpsys deviceidle force-idle // Doze 모드 돌입</span><br><span class="line"></span><br><span class="line">// Doze 모드 테스트...</span><br><span class="line"></span><br><span class="line">&gt; adb shell dumpsys deviceidle unforce // Doze 모드 해제</span><br><span class="line">&gt; adb shell dumpsys battery reset // 배터리 상태 리셋</span><br></pre></td></tr></table></figure>

<h3 id="앱-대기-모드-테스트"><a href="#앱-대기-모드-테스트" class="headerlink" title="앱 대기 모드 테스트"></a>앱 대기 모드 테스트</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 앱 대기모드 활성화</span><br><span class="line">&gt; adb shell dumpsys battery unplug</span><br><span class="line">&gt; adb shell am <span class="built_in">set</span>-inactive <span class="variable">$packageName</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">// 앱 대기모드 해제</span><br><span class="line">&gt; adb shell am <span class="built_in">set</span>-inactive <span class="variable">$packageName</span> <span class="literal">false</span></span><br><span class="line">&gt; adb shell am get-inactive <span class="variable">$packageName</span></span><br></pre></td></tr></table></figure>

<h1 id="am-activity-manager"><a href="#am-activity-manager" class="headerlink" title="am (activity manager)"></a>am (activity manager)</h1><p>am 은 각종 컴포넌트 수행, 화면 속성 수정 등 다양한 시스템 작업을 수행하는 명령어이다.</p>
<h2 id="Activity-시작"><a href="#Activity-시작" class="headerlink" title="Activity 시작"></a>Activity 시작</h2><p>am start 명령은 지정된 intent 정보를 기반으로 activity 를 실행한다. 옵션을 이용하여 인텐트 구성에 필요한 정보를 추가할 수 있다. <a href="https://developer.android.com/studio/command-line/adb?hl=ko#IntentSpec" target="_blank" rel="noopener">IntentSpec</a></p>
<h3 id="앱-내-Activity-로드"><a href="#앱-내-Activity-로드" class="headerlink" title="앱 내 Activity 로드"></a>앱 내 Activity 로드</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell am start -n <span class="variable">$packageName</span>/<span class="variable">$activityName</span></span><br></pre></td></tr></table></figure>

<p><strong>-n</strong> 옵션은 패키지 정보를 기반으로 명시적 인텐트를 생성한다. 이때 activityName 은 클래스 이름이 아닌 manifest 에 등록된 <strong>android:name</strong> 값 이다. 또한 위 명령어로 실행할 수 있는 Activity 는 <strong>android:exported</strong> 옵션이 true 인 Activity 만 가능하다.<br>아마 보안상 대부분의 Activity 는 exported 가 false 일 것 이므로 유용한 상황은 많이 없다. Intent filter 가 걸려있는 Activity 는 exported 를 true 로 유지해야 하므로 실행이 가능하나 intent filter 특성상 추가로 데이터를 넘기지 않으면 원하는 동작을 확인하기는 어려울 것이다.</p>
<h3 id="커스텀-스킴-테스트"><a href="#커스텀-스킴-테스트" class="headerlink" title="커스텀 스킴 테스트"></a>커스텀 스킴 테스트</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell am start -a android.intent.action.VIEW <span class="variable">$customScheme</span>://<span class="variable">$path</span></span><br></pre></td></tr></table></figure>

<p><strong>-a</strong> 옵션은 Intent 의 Action 을 지정한다. 커스텀 스킴을 지정한 인텐트 필터를 설정 후 테스트 할때 유용하다. </p>
<h1 id="그외"><a href="#그외" class="headerlink" title="그외.."></a>그외..</h1><p>자주 활용하는 명령어를 위주로 정리 해봤다. 이 외에도 adb 로 할 수 있는 일은 무궁무진하다. 다만 모든 명령어를 다 외우는 것은 큰 의미가 없고, 어떠한 제어가 가능한지 인지하고 있다가 필요할 때 찾아서 쓰고 정리하면 충분하다고 생각된다.</p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/generic_guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/generic_guide/" class="post-title-link" itemprop="url">[Java] Generic 도장깨기</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-31 18:04:19" itemprop="dateCreated datePublished" datetime="2020-07-31T18:04:19+09:00">2020-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-16 17:06:41" itemprop="dateModified" datetime="2020-08-16T17:06:41+09:00">2020-08-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cover/generic_guide.jpg" alt><br>제네릭을 활용할 일이 많은데 겉핥기 식으로만 알고 있다는 생각이 들어 이번 기회에 관련 내용들을 정리했다.</p>
<h1 id="무엇인가"><a href="#무엇인가" class="headerlink" title="무엇인가?"></a>무엇인가?</h1><p>제네릭은 클래스, 인터페이스 및 메서드를 정의할 때 내부에서 사용될 type 을 parameter 로 전달할 수 있는 개념이다.</p>
<p>간단히 아래와 같이 표현이 가능하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsClass</span> &lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericsInterface</span> &lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiGenericsClass</span> &lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123; &#125; <span class="comment">// 여러개도 가능하다!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">getResult</span><span class="params">(T parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something with parameter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예시에서 GenericsClass, GenericsInterface 처럼 type parameter 를 전달받는 클래스 / 인터페이스를 <strong>Parameterized Types</strong> 라고 칭하기도 한다.</p>
<h1 id="왜-사용하는가"><a href="#왜-사용하는가" class="headerlink" title="왜 사용하는가?"></a>왜 사용하는가?</h1><h2 id="사용-시-장점"><a href="#사용-시-장점" class="headerlink" title="사용 시 장점"></a>사용 시 장점</h2><ul>
<li>컴파일 타임에 타입 체크 가능</li>
<li>캐스팅 불필요</li>
<li>특정 타입에 종속되지 않은 유연한 로직</li>
</ul>
<h2 id="사용-시-단점"><a href="#사용-시-단점" class="headerlink" title="사용 시 단점"></a>사용 시 단점</h2><p>단점이 있다면 <strong>코드의 가독성이 떨어지게 된다.</strong> 사실 이건 제네릭만의 단점이라기보다 보통 유연하고 느슨한 코드일 수록 가독성이 떨어지게 되는데 일종의 트레이드 오프라고 볼 수 있다.</p>
<h1 id="Subtyping"><a href="#Subtyping" class="headerlink" title="Subtyping"></a>Subtyping</h1><p>자바는 is - a 관계일 경우 아래 코드가 문제없이 작동한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object newData = <span class="keyword">new</span> Object();</span><br><span class="line">Integer newNumber = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">newData = newNumber;</span><br></pre></td></tr></table></figure>

<p>제네릭 콜렉션에 값을 추가할 때도 마찬가지이다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">object.add(<span class="number">1</span>);</span><br><span class="line">object.add(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure>

<p>그러나 아래 코드는 에러가 발생한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">objects = numbers; <span class="comment">// compile time error</span></span><br></pre></td></tr></table></figure>

<p>List&lt;Integer&gt; 는 List&lt;Object&gt; 의 <strong>서브타입이 아니기 때문이다.</strong> 이를 Invariant (무공변성, 불변성) 하다고 이야기 한다. 이에 대해서는 Type Bound 파트에서 좀 더 자세히 다뤄보자.</p>
<p>Parameterized Type 이 기본적으로 불변성을 가지는 이유는 타입 안정성을 컴파일 타임에 보장하기 위해서이다. 만약 Parameterized Type 에 subtyping 이 허용된다고 가정해보자. 그렇게 되면 어떤 타입의 파라미터가 넘어올지 컴파일 타임에 미리 아는 것이 불가능하고, 예외 발생을 막기위해 지속적으로 타입 체크가 필요하다.  즉, 제네릭의 장점을 전혀 취할 수 없게 된다. 따라서 타입 안정성을 보장하기 위해서 Parameterized Type 은 기본적으로 Invariant 하다.</p>
<h1 id="Type-Bound-와-Variance"><a href="#Type-Bound-와-Variance" class="headerlink" title="Type Bound 와 Variance"></a>Type Bound 와 Variance</h1><p>Computer Science 에는 Variance 라는 개념이 있다.</p>
<blockquote>
<p>Variance refers to how subtyping between more complex types relates to subtyping between their components.</p>
</blockquote>
<p>쉽게 얘기하면 element 와 element 를 포함하고 있는 컴포넌트가 있을 때 element 간의 sub type 관계가 컴포넌트간의 sub type 관계에 영향을 주는 정도를 의미한다.</p>
<p>영향도에 따라 다음과 같이 나눌 수 있다. </p>
<ul>
<li>Invariant (무공변성) : T → T’ 일 때 &lt;T&gt;, &lt;T’&gt; 는 서로 별개의 타입이면 &lt;T&gt; 는 Invariant 하다.</li>
<li>Covariant (공변성) : T→ T’ 일 때 &lt;T&gt; → &lt;T’&gt; 가 성립하면 &lt;T&gt; 는 covariant 하다.</li>
<li>Contravariant (반공변성) : T → T’ 일 때 &lt;T&gt; ← &lt;T’&gt; 가 성립하면 &lt;T&gt; 는 contravariant 하다.</li>
</ul>
<p>T 는 element, &lt;T&gt; 는 element를 포함하는 컴포넌트를 의미하며 A → B 이면 <strong>A 는 B 의 서브 타입이다.</strong> 이때 서브 타입은 자바의 상속만이 아니라 더 넓은 개념인 <a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener">Subtyping</a> 을 의미한다.  </p>
<p>제네릭은 Type bound 를 적용하여 parameterized type 의 Variance 를 결정할 수 있다. 화살표 방향에 유의하며 하나씩 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 예시 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KoreanShortHair</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-Unbounded-type"><a href="#1-Unbounded-type" class="headerlink" title="1. Unbounded type"></a>1. Unbounded type</h2><blockquote>
<p>&lt;T&gt;, &lt;?&gt;</p>
</blockquote>
<ul>
<li>제네릭 타입 선언 후 아무런 키워드도 붙히지 않으면 unbounded type 이다.</li>
<li>Unbounded type 타입 파라미터로 선언된 Parameterized type 은 모든 타입 파라미터에 대해 <strong>Invariant</strong> 하다.</li>
<li>Cat → Animal 일때 &lt;Cat&gt; 와 &lt;? extends Animal&gt; 는 서로 아무런 연관관계를 가지지 않는 각각 별개의 타입이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// unbounded type parameter</span></span><br><span class="line">List&lt;Cat&gt; cats = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">animals = cats <span class="comment">// Fail, 서로 다른 타입으로 판단한다.</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Upper-bounded-type"><a href="#2-Upper-bounded-type" class="headerlink" title="2. Upper bounded type"></a>2. Upper bounded type</h2><blockquote>
<p>&lt;T <strong>extends</strong> Animal&gt;, &lt;? <strong>extends</strong> Animal&gt;</p>
</blockquote>
<ul>
<li>Upper bounded type 은 제네릭 타입 선언 후 extends 키워드를 이용하여 구현가능하다.</li>
<li>Upper bounded type 타입 파라미터로 선언된 Parameterized type 는 자기 자신 혹은 하위 클래스의 타입 파라미터에 대해 <strong>Covariant</strong> 하다. </li>
<li>예를 들어 Cat → Animal 이면 &lt;Cat&gt; → &lt;? extends Animal&gt; 이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// upper bounded parameterized type</span></span><br><span class="line">List&lt;Cat&gt; cats = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;KoreanShortHair&gt; koreanShortHairs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">animals = cats; <span class="comment">// Ok, cats 는 animals 의 서브타입이다.</span></span><br><span class="line">animals = koreanShortHairs; <span class="comment">// Ok, koreanShortHairs 는 animals 의 서브타입이다.</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Lower-bounded-type"><a href="#3-Lower-bounded-type" class="headerlink" title="3. Lower bounded type"></a>3. Lower bounded type</h2><blockquote>
<p>&lt;T <strong>super</strong> Cat&gt;, &lt;? <strong>super</strong> Cat&gt;</p>
</blockquote>
<ul>
<li>Lower bounded type 은 제네릭 타입 선언 후 super 키워드를 붙히고 원하는 타입을 적으면된다.</li>
<li>Lower bounded type 타입 파라미터로 선언된 Parameterized type 는 자기 자신 혹은 상위 클래스의 타입 파라미터에 대해 <strong>Contravariant</strong> 하다.</li>
<li>예를 들어 Cat → Animal 이면 &lt;Animal&gt; → &lt;? super Cat&gt; 이다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;? <span class="keyword">super</span> Cat&gt; superCats = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// lower bounded parameterized type</span></span><br><span class="line">List&lt;KoreanShortHair&gt; koreanShortHairs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">cats = animals; <span class="comment">// Ok, animals 는 superCats 의 서브 타입이다.</span></span><br><span class="line">cats = koreanShortHairs; <span class="comment">// Fail, KoreanShortHair 는 Cat 의 상위클래스가 아니다.</span></span><br></pre></td></tr></table></figure>

<h2 id="Multi-bound"><a href="#Multi-bound" class="headerlink" title="Multi bound"></a>Multi bound</h2><p>Upper bounded type 에 한하여 N 개의 bound 적용이 가능하다. 이때 사용되는 연산자는 <strong>&amp;</strong> 이다. 특징은 다음과 같다.</p>
<ul>
<li>자바는 다중 상속이 허용되지 않는다. 따라서 부모 클래스가 2개 이상일 수 없으므로 Multi bound 에서 bound 할 수 있는 클래스 타입은 0 ~ 1개 이다.</li>
<li>위와 같은 맥락으로 인터페이스 타입은 bound 개수 제한이 없다.</li>
<li>클래스 타입과 인터페이스 타입을 같이 사용할 경우 클래스 타입이 제일 앞에 선언되어야 한다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">B</span> &amp; <span class="title">C</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span> &amp; <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; <span class="title">int</span> <span class="title">compareNumbers</span>(<span class="title">T</span> <span class="title">t1</span>, <span class="title">T</span> <span class="title">t2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.compareTo(t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Test 클래스의 타입 파라미터 T 는 A 의 서브타입이고, B 와 C 를 구현해야한다. </p>
<p>compareNumbers 메소드의 타입 파라미터 T 는 Number 의 서브타입이고, Comparable 를 구현해야한다. </p>
<h2 id="어디에-활용할-수-있을까-PECS"><a href="#어디에-활용할-수-있을까-PECS" class="headerlink" title="어디에 활용할 수 있을까? (PECS)"></a>어디에 활용할 수 있을까? (PECS)</h2><p>Type bound 를 활용하면 기본 제네릭에서 한번 더 확장이 가능하므로 좀 더 유연한 코드가 될 수 있다. 하지만 어떤 케이스에서 활용해야할지 감이 잘 오지 않는다. 이를 위하여 PECS 라는 규칙이 나오게 되었다.</p>
<p>PECS 란 Producer - extends, Consumer - super 의 약자이다. 생산자는 extends 를 소비자는 super 키워드를 활용하라는 의미이다.</p>
<p>생산자, 소비자라는 표현이 직관적으로 와닿지 않으므로 다음과 같이 이해해도 좋다.</p>
<blockquote>
<p>Read - extends, Write - super</p>
</blockquote>
<p>왜 그런지 한번 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(List&lt;? extends Animal&gt; animals)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (Animal animal : animals) &#123;</span><br><span class="line">        print(animal.toString()); <span class="comment">// OK</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(List&lt;? extends Animal&gt; animals)</span> </span>&#123; </span><br><span class="line">    animals.add(<span class="keyword">new</span> Animal()); <span class="comment">// compile time error</span></span><br><span class="line">    animals.add(<span class="keyword">new</span> Cat()); <span class="comment">// compile time error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// super</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(List&lt;? <span class="keyword">super</span> Cat&gt; cats)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (Cat cat : cats) &#123;</span><br><span class="line">        print(cat.toString()); <span class="comment">// compile time error</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(List&lt;? <span class="keyword">super</span> Cat&gt; cats)</span> </span>&#123; </span><br><span class="line">    cat.add(<span class="keyword">new</span> Animal()); <span class="comment">// compile time error</span></span><br><span class="line">    cat.add(<span class="keyword">new</span> KoreanShortHair()); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Read - extends</strong></p>
<ul>
<li>read 메소드를 살펴보면 animals 의 각 element 를 Animal 타입으로 읽는 것은 문제 되지 않는다. 왜냐하면 어떠한 List 가 들어오더라도 내부 element 는 최소한 Animal 을 상속받았을 것이 보장되기 때문이다.</li>
<li>한편 write 메소드를 살펴보면 add 를 시도할 경우 자신을 포함한 Animal 의 하위 타입을 전달했을 때 오류가 발생한다. 이유는 전달된 animals 의 element 는 animal 을 상속받은 것만 보장할뿐 구체적으로 어떤 타입인지는 알 수 없기 때문이다. 이를 허용할 경우 런타임에 타입 불일치로 오류가 발생할 수 있는 가능성이 생길 수 있다. (ex / List&lt;Cat&gt; 을 전달받았는데 Animal 객체를 추가하는 경우)</li>
</ul>
<p>따라서 상방으로 닫혀있는 extends 는 read 에 적합하다.</p>
<p><strong>Write - super</strong></p>
<ul>
<li>write 메소드를 먼저 살펴보면 cats 는 cat 의 <strong>하위타입에 한하여</strong> 어떠한 객체든 추가가 가능하다. cats 의 element 는 Cat 의 상위 타입인 것이 보장되기 때문이다.  ( ? → Cat → ? super Cat )</li>
<li>read 메소드를 살펴보면 이제 슬슬 감이 온다. cats 의 element 는 Cat 의 상위 타입이므로 항상 Cat 자신이라고 보장할 수 없기 때문에 Cat 이라는 타입으로 확정지어 사용할 수 없다.</li>
</ul>
<p>만약, read &amp; write 를 모두 하는 케이스의 경우 type bound 를 사용할 수 없다!</p>
<h1 id="Wildcard"><a href="#Wildcard" class="headerlink" title="Wildcard"></a>Wildcard</h1><p>Type bound 파트에서 먼저 언급이 되었는데, <strong>&lt;?&gt;</strong> 와 같이 물음표를 이용하여 제네릭 타입을 표현하는 것을 와일드 카드라고 부른다. 와일드 카드는 다음과 같은 특징이 있다.</p>
<ul>
<li><p>어떤 타입이든 가리지 않고 전달이 가능하다.</p>
</li>
<li><p>제네릭 클래스의 파라미터, 제네릭 메소드의 인자 자체로는 사용이 불가능하다.</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &lt;?&gt; </span>&#123; &#125; <span class="comment">// 불가능</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeTest</span><span class="params">(&lt;?&gt; parameter)</span> </span>&#123; &#125; <span class="comment">// 불가능</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Type bound 에 따라 불리는 명칭이 다르다.</p>
<ul>
<li>&lt;?&gt; : unbounded wildcard</li>
<li>&lt;? extends Animal&gt; : upper bounded wildcard</li>
<li>&lt;? super Animal&gt; : lower bounded wildcard</li>
</ul>
<p>upper bounded wildcard, lower bounded wildcard 에 대한 얘기는 Type bound 파트에서 이미 대부분 다뤘으므로 unbounded wildcard 에 대해서만 잠깐 정리해보자.</p>
<h2 id="lt-gt-unbounded-wildcard"><a href="#lt-gt-unbounded-wildcard" class="headerlink" title="&lt;?&gt; : unbounded wildcard"></a>&lt;?&gt; : unbounded wildcard</h2><p>unbounded wildcards 는 제네릭 계의 Object 클래스 이다.  따라서 실제 특징도 Object 와 비슷하다.</p>
<ul>
<li><p><strong>? 를 Object 로 바꿔서 사용하는 것이 가능하다.</strong></p>
<p>  → unbounded wildcard type 은 컴파일 과정에서 Object 타입으로 판단하기 때문에 코드상에서 Object 로 취급하여도 오류가 발생하지 않는다. (후술할 reifiable type 이기도 하다.)</p>
</li>
<li><p><strong>&lt;?&gt; 는 Covariant 하다.</strong></p>
<p>  → 모든 T에 대하여 T → ?, &lt;T&gt; → &lt;?&gt; 가 성립한다.  </p>
<p>  &lt;사진&gt;</p>
</li>
</ul>
<p>이러한 특징을 고려하여 활용할 수 있는 케이스는 크게 2가지가 있다.</p>
<h3 id="1-Object-클래스가-제공하는-기능을-사용하여-구현-해야할-때"><a href="#1-Object-클래스가-제공하는-기능을-사용하여-구현-해야할-때" class="headerlink" title="1. Object 클래스가 제공하는 기능을 사용하여 구현 해야할 때"></a>1. Object 클래스가 제공하는 기능을 사용하여 구현 해야할 때</h3><p>Object 타입 기반의 메소드가 있다고 가정하자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseString</span><span class="params">(List&lt;Object&gt; objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object object : objects) &#123;</span><br><span class="line">        print(object.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 메소드는 Object 타입 List 를 전달받으므로 범용성이 클 것 같지만 위에서 다룬 Variance 룰에 의하여 List&lt;Integer&gt;, List&lt;String&gt; 과 같은 Object 하위 타입 리스트를 전달할 수 없다. 이때 unbounded wildcard 를 이용하면 해결할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseString</span><span class="params">(List&lt;?&gt; objects)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object object : objects) &#123;</span><br><span class="line">        print(object.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-타입에-의존하지-않는-로직을-수행할-때"><a href="#2-타입에-의존하지-않는-로직을-수행할-때" class="headerlink" title="2. 타입에 의존하지 않는 로직을 수행할 때"></a>2. 타입에 의존하지 않는 로직을 수행할 때</h3><p>List 의 size(), clear() 와 같이 타입이 무엇이든 상관없이 수행이 가능한 메소드들이 있다. 이럴 때 unbounded wildcard 가 사용된 parameterized type 을 사용하면 유연한 코드 작성이 가능하다.</p>
<h1 id="Type-erasure"><a href="#Type-erasure" class="headerlink" title="Type erasure"></a>Type erasure</h1><p>자바 컴파일러는 컴파일 과정에서 제네릭에 대해 타입 소거(Type erasure)를 진행한다. 타입 소거란 타입정보를 컴파일 타임에만 유지하고, 런타임에는 삭제시켜 버리는 것인데 과거 제네릭이 없던 버전과의 하위 호환성을 위해서이다.</p>
<p>타입소거가 이루어진 클래스는 다음과 같다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 타입소거 전</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(T paramenter)</span> </span>&#123;</span><br><span class="line">        paramenter.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 타입소거 후</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(Object paramenter)</span> </span>&#123;</span><br><span class="line">        paramenter.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>컴파일러는 Unbound type 에 대하여 Object 로 바꿔버렸다. 따라서 런타임에는 해당 타입이 본래 어떤 타입이었는지 알 수 없다. 타입 소거에 대한 동작은 다음과 같다.</p>
<ul>
<li>Unbound type 의 경우 Object, bound type 의 경우 bound 값을 기준으로 타입을 바꾼다.</li>
<li>필요에 따라 캐스팅 및 bridge 메소드가 추가될 수 도 있다.</li>
</ul>
<h2 id="Non-Reifiable-Type"><a href="#Non-Reifiable-Type" class="headerlink" title="Non-Reifiable Type"></a>Non-Reifiable Type</h2><p>런타임에 타입 정보의 유무에 따라 Reifialbe type, Non - Reifialbe type 으로 구분한다.</p>
<ul>
<li>Refiable type : 런타임에 타입에 대한 정보를 가지고 있다. 대표적으로 primitive, non - generic, unbounded wildcards (&lt;?&gt;) 등 이 있다.</li>
<li>Non - Reifiable type : 런타임에 타입에 대한 정보가 없다. 대표적으로 type erasure 가 진행되는 대부분의 generic parameterized type 이 있다.</li>
</ul>
<p>제네릭이 가지는 한계점은 대부분 이 타입 소거라는 특징 때문에 발생할 만큼 기억해둬야할 원리다. 타입 소거로 인한 이슈를 피하기 위한 기법 <a href="https://www.baeldung.com/java-super-type-tokens" target="_blank" rel="noopener">super type token</a> 이 나오기도 했다.</p>
<h1 id="제네릭의-한계점"><a href="#제네릭의-한계점" class="headerlink" title="제네릭의 한계점"></a>제네릭의 한계점</h1><h2 id="원시값을-제네릭-타입으로-사용할-수-없다"><a href="#원시값을-제네릭-타입으로-사용할-수-없다" class="headerlink" title="원시값을 제네릭 타입으로 사용할 수 없다"></a>원시값을 제네릭 타입으로 사용할 수 없다</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// compile time error</span></span><br><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// Ok</span></span><br></pre></td></tr></table></figure>

<p>원시값을 사용하기 위해서는 Wrapper class 를 사용해야한다. 허용되지 않는 이유가 타입소거 때문인줄 알았는데 컴파일러 구현 이슈 때문이라는 의견이 있었다. 이 부분은 좀 더 정확한 정보를 찾게 되면 다시 업데이트가 필요하다.</p>
<h2 id="제네릭-타입의-인스턴스를-생성할-수-없다"><a href="#제네릭-타입의-인스턴스를-생성할-수-없다" class="headerlink" title="제네릭 타입의 인스턴스를 생성할 수 없다"></a>제네릭 타입의 인스턴스를 생성할 수 없다</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E instnace = <span class="keyword">new</span> E(); <span class="comment">// compile time error</span></span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이유는 타입소거로 인하여 생성해야할 타입이 무엇인지 알 수 없기 때문이다. 꼭 생성이 필요할 경우 리플렉션을 이용하면 가능하다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">createInstance</span><span class="params">(Class&lt;E&gt; clazz)</span> </span>&#123;</span><br><span class="line">    E instnace = clazz.newInstance(); <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">return</span> E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Parameterized-type-을-instanceOf-로-비교할-수-없다"><a href="#Parameterized-type-을-instanceOf-로-비교할-수-없다" class="headerlink" title="Parameterized type 을 instanceOf 로 비교할 수 없다"></a>Parameterized type 을 instanceOf 로 비교할 수 없다</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numberes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (numberes <span class="keyword">instanceof</span> ArrayList&lt;Integer&gt;) &#123; <span class="comment">// compile time error</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>타입소거의 특징으로 인해 위 코드는 컴파일 되지 않는다. 본래의 List 가 어떤 타입을 담고 있었는지 알 수 없으므로 위와 같은 코드가 무의미해지는 것이다. 예를들어 JVM 은 런타임에 ArrayList&lt;String&gt;, ArrayList&lt;Integer&gt; 를 구분하지 못한다. 하지만 방법이 아주 없는 것은 아니다. 제네릭 타입 중에 유일하게 타입소거가 되지않는 unbounded wildcard <strong>&lt;?&gt;</strong> 를 이용하면 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numberes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (numberes <span class="keyword">instanceof</span> ArrayList&lt;?&gt;) &#123; <span class="comment">// Ok</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Parameterized-type-array-를-만들-수-없다"><a href="#Parameterized-type-array-를-만들-수-없다" class="headerlink" title="Parameterized type array 를 만들 수 없다"></a>Parameterized type array 를 만들 수 없다</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] arrayOfTexts = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// compile time error</span></span><br></pre></td></tr></table></figure>

<p>위 코드는 컴파일되지 않는다. 만약 Array 를 만드는 것이 허용된다고 가정했을 때 어떤 문제가 있을지 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt;[] numbers = <span class="keyword">new</span> List&lt;Integer&gt;[<span class="number">10</span>]; </span><br><span class="line">Object[] objects = numbers;</span><br><span class="line"></span><br><span class="line">objects[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">// OK</span></span><br><span class="line">objects[<span class="number">1</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// Exception 을 던져야하지만, 런타임에 인지할 수 없음.</span></span><br></pre></td></tr></table></figure>

<p>배열 초기화 과정부터 이상함을 느꼈을 수 있다. <strong>Array 는 Collection 과 다르게 기본적으로 Convariant 하다</strong>. 즉, A → B 이면 A[ ] → B[ ] 가 성립하기에 objects 를 numbers 로 초기화 하는 것이 가능하다!</p>
<p>그 후에 순차적으로 List&lt;Integer&gt;, List&lt;String&gt; 를 각 배열원소에 초기화하는데, Array 는 런타임에 일치하지 않는 타입이 들어오면 ArrayStoreException 이 발생하므로 List&lt;Integer&gt; 로 초기화 할 때 예외가 발생해야한다. 하지만 타입소거에 의해 각 List 는 런타임에 구별되지 않으므로 예외가 발생하지 않고 초기화가 진행될 것이다. 즉, 타입이 구별되지 않아 배열의 기본동작 규칙이 깨지게 되는 것이다.<br>이러한 이유로 인해 Parameterized type array 생성은 허용되지 않는다.</p>
<h2 id="type-parameter-의-구분으로-메소드를-overload-할-수-없다"><a href="#type-parameter-의-구분으로-메소드를-overload-할-수-없다" class="headerlink" title="type parameter 의 구분으로 메소드를 overload 할 수 없다"></a>type parameter 의 구분으로 메소드를 overload 할 수 없다</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;Integer&gt; numbers)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(List&lt;String&gt; texts)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>자바로 처음 개발을 하면 제법 많이 겪어봤을 케이스이다. 위 코드에서 execute 메소드는 오버로딩 될 수 없다. 타입 소거 과정이 끝나면 모두 List 타입으로 변경되어 똑같은 메소드 시그니쳐를 가지게 되기 때문이다.</p>
<h1 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h1><p>제네릭이 선언된 대부분의 클래스들이 특정 알파벳만 사용되기 때문에 이것이 문법적으로 강제되는 부분이라고 착각할 수 있지만 실제로는 어떠한 이름을 지어도 상관이 없다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &lt;<span class="title">SUPERGENERIC</span>&gt; </span>&#123; &#125; <span class="comment">// 이렇게 지어도 잘돌아간다.</span></span><br></pre></td></tr></table></figure>

<p>다만 표준으로 사용을 권장하는 알파벳들이 있을 뿐이다. 협업의 관점에서 중요한 포인트 이므로 특별한 이유가 없다면 표준을 따르는 것이 좋다. <a href="https://docs.oracle.com/javase/tutorial/java/generics/types.html" target="_blank" rel="noopener">가이드</a></p>
<ul>
<li>안드로이드의 Adapater 클래스의 시그니쳐를 보면 제네릭의 의미를 강조하기 위해 표준 표기가 아닌 이름을 사용하기도 했다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span>&lt;<span class="title">VH</span> <span class="keyword">extends</span> <span class="title">ViewHolder</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://docs.oracle.com/javase/tutorial/java/generics/" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/generics/</a><br><a href="https://dzone.com/articles/5-things-you-should-know-about-java-generics" target="_blank" rel="noopener">https://dzone.com/articles/5-things-you-should-know-about-java-generics</a></p>
<p><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></p>
<p><a href="https://en.wikipedia.org/wiki/Subtyping" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Subtyping</a></p>
<p><a href="https://jojoldu.tistory.com/25" target="_blank" rel="noopener">https://jojoldu.tistory.com/25</a></p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/about_ioc_dip_di/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/about_ioc_dip_di/" class="post-title-link" itemprop="url">IoC, DI, DIP 개념 잡기</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-03 02:08:49" itemprop="dateCreated datePublished" datetime="2020-07-03T02:08:49+09:00">2020-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-27 13:58:16" itemprop="dateModified" datetime="2020-09-27T13:58:16+09:00">2020-09-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>IoC, DIP, DI 는 항상 혼동되는 개념이다. 각 개념을 서로 같다고 표현하는 글들도 제법 있고, 각 개념의 정의를 살펴보니 직관적으로 이해가 되지 않았다. 요즘 특히 DI 에 대한 내용이 많이 언급되고 있다고 느끼는데 정작 주장하는 문맥이 조금씩 다르다보니 스스로 답답함을 느꼈다. 제대로된 논의를 하기 위해서는 올바른 개념 정리가 필요하다고 생각되어 각 개념에 대한 정보를 모으고 정리했다. </p>
<h1 id="무엇이-다를까"><a href="#무엇이-다를까" class="headerlink" title="무엇이 다를까?"></a>무엇이 다를까?</h1><blockquote>
<p>To be sure, using DI or IoC with DIP tends to be more expressive, powerful and domain-aligned, but they are about different dimensions, or forces, in an overall problem. DI is about wiring, IoC is about direction, and DIP is about shape.</p>
</blockquote>
<p>결론부터 얘기하면 IoC, DIP, DI 는 모두 다른 개념이다. 각자 목적과 요구하는 바가 다르다. 하지만 서로를 배척하는 개념은 아니다. 오히려 함께 했을 때 강한 시너지가 생긴다.</p>
<h1 id="Inversion-of-Control-IoC-제어의-역전"><a href="#Inversion-of-Control-IoC-제어의-역전" class="headerlink" title="Inversion of Control (IoC, 제어의 역전)"></a>Inversion of Control (IoC, 제어의 역전)</h1><blockquote>
<p>don’t call me, I’ll call you. - <a href="https://en.wiktionary.org/wiki/Hollywood_principle" target="_blank" rel="noopener">Hollywood principle</a></p>
</blockquote>
<p>개인적으로 IoC 를 가장 직관적으로 잘 설명한 문장이라고 생각한다.</p>
<p>좀 더 개발 친화적인 용어로 풀어서 설명하면 다음과 같이 표현할 수 있다. </p>
<blockquote>
<p>IoC 란 코드의 흐름을 제어하는 주체가 바뀌는 것이다.</p>
</blockquote>
<p>코드의 흐름을 제어한다는 것은 여러 행위를 포함한다. 오브젝트를 생성하는 것, 오브젝트의 생명주기를 관리하는 것, 메소드를 수행하는 것 등. 그리고 일반적인 프로그램은 이러한 행위를 하나부터 열까지 모두 스스로 수행한다. (우리가 처음 만들었던 프로그램을 잘 생각해보자.) IoC 를 적용한다는 것은 이러한 흐름 제어를 또다른 제 3자가 수행한다는 것을 의미한다.</p>
<p>안드로이드에서도 IoC 가 적용된 케이스를 볼 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>우리가 Activity 코드를 작성할 때 생명주기 메소드가 호출되었을 때의 동작만 정의하고, <strong>언제 생명주기 메소드를 호출 할지는 신경쓰지 않는다</strong>. 즉, Activity 의 메인 흐름 제어권은 나의 코드가 아니라 안드로이드 플랫폼에서 쥐고 있다.</p>
<p>누가 물어봤을 때 명확한 답변을 못했던 ‘프레임 워크와 라이브러리의 차이는 무엇인가?’ 에 대해 IoC 관점으로 설명이 가능하다. 라이브러리는 내 코드가 라이브러리를 이용한다. 즉, 제어권이 내 코드에 있다. 반면 프레임 워크는 프레임 워크가 나의 코드를 실행한다. 즉, 제어권은 프레임워크에게 있다.</p>
<blockquote>
<p>Software frameworks, callbacks, schedulers, event loops, dependency injection, and the template method are examples of design patterns that follow the inversion of control principle</p>
</blockquote>
<p>IoC 를 따르는 개념이 생각보다 많았다.</p>
<h1 id="Dependency-Inversion-principle-DIP-의존관계-역전-법칙"><a href="#Dependency-Inversion-principle-DIP-의존관계-역전-법칙" class="headerlink" title="Dependency Inversion principle (DIP, 의존관계 역전 법칙)"></a>Dependency Inversion principle (DIP, 의존관계 역전 법칙)</h1><blockquote>
<p>a.  High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g. interfaces).<br>b. Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</p>
</blockquote>
<p>SOLID 원칙 중 하나이다. 의존관계에 대해 다루고 있는데 한번에 바로 이해될 수 있는 설명이 아니었다. 관련된 내용을 찾아보다가 좀 더 직관적으로 표현된 문장을 발견했다.</p>
<blockquote>
<p>DIP is about the level of the abstraction in the messages sent from your code to the thing it is calling</p>
</blockquote>
<p>DIP 가 주장하는 바의 핵심은 추상화에 의존하라는 것이다. </p>
<p>추상화가 아닌 구체클래스에 의존한 경우를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> TextFileParser textFileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TextFile 이 아닌 csv 파일을 파싱해야할 경우 필연적으로 코드의 변경이 발생</span></span><br><span class="line">        <span class="keyword">this</span>.textFileParser = <span class="keyword">new</span> TextFileParser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parseFile</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> textFileParser.parse(serializedFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 TextFileParser 에 변경이 발생했을 때 이를 의존하는 FileLoader 역시 변경이 발생하게 된다. 또한 FileLoader 는 TextFile 외에 다른 File 을 파싱하기 위해서는 아예 Parser 클래스를 변경해야한다. 변경에 유연하지 않은 구조이다.</p>
<p>추상화에 의존할 경우를 살펴보자</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileParser</span> </span>&#123;</span><br><span class="line">    <span class="function">File <span class="title">parse</span><span class="params">(String serializedFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFileParser</span> <span class="keyword">implements</span> <span class="title">FileParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parse</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">        <span class="keyword">return</span> File();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileParser fileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLoader</span><span class="params">(FileParser fileParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileParser = fileParser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parseFile</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileParser.parse(serializedFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FileLoader 는 FileParser 인터페이스에 의존하기에 FileParser 의 구현체인 TextFileParser 변경이 발생하더라도 영향을 받지 않는다. 또한 FileParser 인터페이스를 구현한 구현체라면 무엇이든 FileLoader 에서 이용이 가능하다. 즉, 다형성을 활용하여 변경에 유연한 구조가 된다. </p>
<h1 id="Dependency-Injection-DI-의존성-주입"><a href="#Dependency-Injection-DI-의존성-주입" class="headerlink" title="Dependency Injection (DI, 의존성 주입)"></a>Dependency Injection (DI, 의존성 주입)</h1><blockquote>
<p>DI is about how one object acquires a dependency</p>
</blockquote>
<p>DI 는 필요로 하는 오브젝트를 스스로 생성하는 것이 아닌 외부로 부터 주입받는 기법을 의미한다. 마틴 파울러의 글에 따르면 3가지 타입으로 정의할 수 있다.</p>
<h2 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h2><p>생성자를 통해 주입하는 방식이다. 인스턴스가 생성되었을 때 의존성이 존재하는 것이 보장되기 때문에 의존성의 존재여부가 보장되고 의존성을 immutable 하게 정의할 수 있다. <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-setter-injection" target="_blank" rel="noopener">스프링</a>에서도 해당 방식을 권장하는 것으로 알고 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileParser fileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIilLoader</span><span class="params">(FileParser fileParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileParser = fileParser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection"></a>Setter Injection</h2><p>Setter 메소드를 이용하여 주입하는 방식이다. 해당 방식은 Construcor Injection 보다 좀 더 주의를 요한다. 주입 받는 의존성의 기본값을 정의할 수 있지 않다면 null 값이 존재할 수 있는 이슈가 있기 때문이다. 의존성이 다시 주입되어야할 경우 유용하게 사용된다고 하나 나는 아직 그러한 상황을 겪지 못했고 모두 Construcor Injection 으로 해결할 수 있었다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileParser fileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFIilLoader</span><span class="params">(FileParser fileParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileParser = fileParser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interface-Injection"><a href="#Interface-Injection" class="headerlink" title="Interface Injection"></a>Interface Injection</h2><p>Interface 로 주입받는 메소드를 정의한다. 이 방식은 이번에 조사하면서 처음 알게 되었고 실제로 사용해본 적이 없어 자세히 적기는 조심스럽다. 예시를 봐도 이점이 명확하게 보이지 않아 좀 더 공부를 하고 내용을 채워보려 한다.</p>
<h1 id="각-개념-간의-관계"><a href="#각-개념-간의-관계" class="headerlink" title="각 개념 간의 관계"></a>각 개념 간의 관계</h1><h2 id="IoC-와-DI"><a href="#IoC-와-DI" class="headerlink" title="IoC 와 DI"></a>IoC 와 DI</h2><p>종종 IoC 와 Dependency Injection 은 서로 interchangeably 한 것, 더 나아가 아예 같은 것처럼 표현하는 글이 보이곤 하는데 이는 잘못된 해석이라고 생각한다. Dependency Injection 은 IoC 개념이 적용된 결과물 중 하나일 뿐이다. 의존성을 주입한다는 것을 IoC 적인 행위로 바라볼 수 는 있지만 IoC 가 곧 의존성 주입이라고 보기 는 어렵기 때문이다.</p>
<h2 id="DIP-와-DI"><a href="#DIP-와-DI" class="headerlink" title="DIP 와 DI"></a>DIP 와 DI</h2><p>단어가 비슷해보이는 DIP 와 DI 역시 같은 개념으로 오해하기 쉽다. 하지만 마찬가지로 DI 는 DIP 를 구현하는 기법중 하나일 뿐 서로 같은 개념이 아니다. 위 DIP 예제 코드에서도 DI 가 이용되었다.</p>
<p>DIP 에 대한 이해가 부족했을 때, 아래와 같은 코드도 DIP 를 만족하는 것이라고 생각했었다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileParser</span> </span>&#123;</span><br><span class="line">    <span class="function">File <span class="title">parse</span><span class="params">(String serializedFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFileParser</span> <span class="keyword">implements</span> <span class="title">FileParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parse</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something</span></span><br><span class="line">        <span class="keyword">return</span> File();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileParser fileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileParser = <span class="keyword">new</span> TextFileParser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parseFile</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fileParser.parse(serializedFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>하지만 해당 코드에서는 FileParser 를 다른 구현체로 바꿀 수 없다. 사실상 타입만 인터페이스로 했을 뿐 다형성의 이점을 전혀 살리지 못하는 코드이며 DIP 를 만족한다고 보기 어렵다.</p>
<p>또 다른 예시를 살펴보자. 이 코드도 조금 아쉬운 점이 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextFileParser textFileParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLoader</span><span class="params">(TextFileParser textFileParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.textFileParser = textFileParser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">parseFile</span><span class="params">(String serializedFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> textFileParser.parse(serializedFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>해당 코드는 TextFileParser 를 주입 받으므로 DI 가 이루어졌다고 볼 수 있다. 따라서 TextFileParser 의 생성자에 변경이 생기더라도 FileLoader 에 전파되지 않는 것은 긍정적인 부분이다. 하지만 DIP 는 지켜지지 않았다. 구체 클래스에 의존하고 있으므로 다른 FileParser 로 교체하는 것은 불가능하며 TextFileParser 의 변경에 FileLoader 가 영향을 받게 된다.</p>
<p>위 예시들이 시사하는 바는 <strong>DIP 와 DI 는 서로 조합되었을 때 시너지를 발휘한다는 것</strong>이다. 그래서 보통 한쪽 개념의 예시를 들 때 다른 쪽 개념이 같이 적용되어 있기 때문에 두 개념을 같다고 이해 할 법도 하다.</p>
<h1 id="개념의-본질을-이해-착각하지-말기"><a href="#개념의-본질을-이해-착각하지-말기" class="headerlink" title="개념의 본질을 이해, 착각하지 말기"></a>개념의 본질을 이해, 착각하지 말기</h1><p>이러한 개념들을 정리하고 나면 내가 좀 더 개발을 잘하게 되었다는 착각에 종종 빠지곤 한다. 개념은 개념일 뿐이다. 커뮤니케이션 과정에서 리소스를 줄여주고 코드 그것이 곧 개발력과는 연결되지 않는 다고 본다. 중요한 것은 각 개념 속에서 추구하는 본질이 무엇인지 깨닫는 것이다. </p>
<p>한편으로는 이러한 개념들에 대해 정확히 정리하고 이해하는 과정은 꼭 필요하다. 내가 당장 이러한 것들을 지키지 못하더라도 어떤것이 충족되지 않는지 인식하고, 고쳐나갈 수 있는 기준을 세울 수 있기 때문이다. 무엇을 모르는지 모르는 것과 무엇을 모르는지 아는 것의 차이는 매우 크다.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://justhackem.wordpress.com/2016/05/14/inversion-of-control/" target="_blank" rel="noopener">https://justhackem.wordpress.com/2016/05/14/inversion-of-control/</a><br><a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">https://www.martinfowler.com/articles/injection.html</a></p>
<p><a href="https://martinfowler.com/articles/dipInTheWild.html" target="_blank" rel="noopener">https://martinfowler.com/articles/dipInTheWild.html</a><br><a href="https://dzone.com/articles/ioc-vs-di" target="_blank" rel="noopener">https://dzone.com/articles/ioc-vs-di</a></p>
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans</a><br><a href="https://www.codeproject.com/Articles/592372/Dependency-Injection-DI-vs-Inversion-of-Control-IO" target="_blank" rel="noopener">https://www.codeproject.com/Articles/592372/Dependency-Injection-DI-vs-Inversion-of-Control-IO</a></p>
<p><a href="https://medium.com/@ivorobioff/dependency-injection-vs-service-locator-2bb8484c2e20" target="_blank" rel="noopener">https://medium.com/@ivorobioff/dependency-injection-vs-service-locator-2bb8484c2e20</a></p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/viewmodel_public_method/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/viewmodel_public_method/" class="post-title-link" itemprop="url">[안드로이드] ViewModel 에 대한 고찰 : public 메소드</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-07 19:27:42 / Modified: 19:37:19" itemprop="dateCreated datePublished" datetime="2020-06-07T19:27:42+09:00">2020-06-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>MVVM 기반으로 프로젝트를 진행할 때 팀 내에서 가장 많은 논의가 오고 갔던 부분은 역시 ViewModel 이었다. 이번 글은 그 중 ViewModel 의 public 메소드에 대하여  적어보려 한다.</p>
<h1 id="종류-및-구현-방식"><a href="#종류-및-구현-방식" class="headerlink" title="종류 및 구현 방식"></a>종류 및 구현 방식</h1><p>ViewModel 은 보통 세 종류의 public 메소드를 제공한다.</p>
<ol>
<li>View 가 원하는 명령을 수행하기 위한 트리거형 메소드</li>
<li>LiveData 등의 이벤트 옵저버 Getter</li>
<li>특정 값 Getter (되도록 지양!)</li>
</ol>
<p>2개는 Getter 이므로 크게 논의할만한 부분이 없고, 첫 번째인 트리거형 메소드에 대해 다룰 것이다.</p>
<h1 id="초기-구현-방식과-문제점"><a href="#초기-구현-방식과-문제점" class="headerlink" title="초기 구현 방식과 문제점"></a>초기 구현 방식과 문제점</h1><p>초기 MVVM 패턴을 적용하여 화면을 만들 때 다음과 같이 구현하였다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">				...        </span><br><span class="line">        mUserCategoryViewModel.loadUserCategory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeClickListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDeleteAllButton.setOnClickListener(view -&gt; mUserCategoryViewModel.deleteAllCategory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadUserCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// Call API</span></span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAllCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Delete all</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h2 id="문제점"><a href="#문제점" class="headerlink" title="문제점"></a>문제점</h2><p>위 구현은 ViewModel 이 비즈니스 로직을 수행할 수 있는 메소드를 public 하게 제공하고 있고, 이를 View 가 직접 호출하고 있는 형태이다. 이는 곧 다음과 같은 문제점에 직면하게 된다.</p>
<ul>
<li><p>View 가 비즈니스 로직 진행 과정을 알고 있어야 함을 의미한다.</p>
<p>  → 예를 들어 위 예제 코드에서 전체 삭제 버튼을 눌렀을 때, 전체 삭제 외에 추가적인 과정이 수행되야 하는 스펙이 추가 되는 것을 가정 해보자. 이는 곧 View 에서 신규 스펙과 관련된 viewModel 의 메소드를 추가로 호출해줘야 함을 의미한다. 즉, ViewModel 레벨의 변경사항이 View 에 영향을 끼친다. (기존의 deleteAllCategory 메소드에 신규 스펙의 내용을 구현하는 것은 SRP 규칙에 위배된다.)</p>
</li>
<li><p>해당 화면의 컨텍스트를 모르는 개발자는 전체적인 흐름을 파악하기 위해 View, ViewModel 모두를 확인해야만 한다.</p>
</li>
</ul>
<h1 id="개선안"><a href="#개선안" class="headerlink" title="개선안"></a>개선안</h1><p>코드를 먼저 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">				...        </span><br><span class="line">        mUserCategoryViewModel.onEnterView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeClickListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDeleteAllButton.setOnClickListener(view -&gt; mUserCategoryViewModel.deleteAllCategory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEnterView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				loadUserCategory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickDeleteAllButton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				deleteAllCategory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUserCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// Call API</span></span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteAllCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Delete all</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>초기 구현 대비 바뀐 것은 2가지이다.</p>
<p><strong>1. ViewModel 은 내부 비즈니스 로직을 직접 수행할 수 있는 메소드를 public 하게 제공하지 않는다.</strong></p>
<p>기존 메소드의 접근제한자를 private 로 변경하였다. 이제 View 는 더이상 비즈니스 로직을 수행하는 메소드를 직접 호출할 수 없다. </p>
<p><strong>2. ViewModel 의 public 메소드는 View 레벨의 특정한 이벤트를 지칭하는 네이밍을 가진다.</strong></p>
<p>View 가 ViewModel 에게 명령할 트리거 메소드는 여전히 필요하기에 새로운 트리거 메소드를 생성하였다. 해당 메소드는 View 의 특정 이벤트가 발생 했음을 나타내는 네이밍을 가진다. 또한 기존의 비즈니스 로직 메소드를 내부에서 수행한다. 이러한 변경사항은 다음과 같은 이점을 가진다.</p>
<ul>
<li>View 는 더이상 내부 비즈니스 로직의 수행 과정을 알 필요가 없다. 단지 View 이벤트가 발생했다고 ViewModel 에 전달 해주면 된다.</li>
<li>ViewModel 의 비즈니스 로직에 추가 스펙이 들어오더라도 View 에 전파되지 않는다.</li>
<li>해당 화면의 컨텍스트를 모르는 개발자가 코드를 보더라도 비즈니스 로직이 한곳에 모여있으므로 파악이 용이하다.<br>ex) 전체 삭제 버튼이 눌렸을 때 수행 되는 일이 궁금하다면 onClickDeleteAllButton 메소드의 구현 내용만 확인하면 된다!</li>
</ul>
<p>위 변경사항을 통해 ViewModel 을 한단계 더 캡슐화하는 효과를 얻게 되었다.</p>
<h1 id="효과"><a href="#효과" class="headerlink" title="효과"></a>효과</h1><p>유저로 부터 리포트되는 이슈의 상당수는 ‘XXX 를 클릭했을 때 안돼요.’ 와 같이 특정 View 이벤트와 관련된 내용이 많다. 개선된 내용을 적용하고 난 후에는 해당 화면에 속한 ViewModel 의 트리거 메소드만 확인하면 바로 관련된 비즈니스 로직을 파악할 수 있기 때문에 개발 능률이 향상되는 효과를 얻었다.</p>
<p>더 변경하기 쉽고, 이해하기 쉬운 코드를 위한 여정은 계속된다.  🤟</p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/android_repository_pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/android_repository_pattern/" class="post-title-link" itemprop="url">[안드로이드] Repository 패턴에 대한 고찰</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-24 15:22:30" itemprop="dateCreated datePublished" datetime="2020-05-24T15:22:30+09:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-04 23:57:04" itemprop="dateModified" datetime="2020-06-04T23:57:04+09:00">2020-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://developer.android.com/jetpack/docs/guide?hl=ko#overview" target="_blank" rel="noopener">공식 문서</a>에서도 가이드 하는 것 처럼 이제 Android 아키텍처를 구성할 때 Repository 패턴은 기본적으로 사용 되고있다. 오늘은 Repository 패턴에 대한 간단한 정리와 사용하면서 내가 놓치고 있었던 점에 대하여 정리 해보려한다.</p>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul>
<li>Repository 패턴의 궁극적인 목적은 결국 관심사의 분리다.</li>
<li>DataSource 외에 data 에 대한 분리도 필요하다.</li>
</ul>
<h1 id="Repository-패턴을-사용하는-이유"><a href="#Repository-패턴을-사용하는-이유" class="headerlink" title="Repository 패턴을 사용하는 이유"></a>Repository 패턴을 사용하는 이유</h1><blockquote>
<p>Repositories are classes or components that encapsulate the logic required to access data sources.</p>
</blockquote>
<p>Repository 는 DataSource 를 캡슐화 한다. 이점은 다음과 같다.</p>
<ul>
<li>하나의 도메인을 표현하는데 필요한 DataSource 가 몇 개든 client 쪽에서는 이를 알 필요가 없다.<ul>
<li>따라서 DataSource 를 새롭게 추가하는 것도 부담이 없다.</li>
</ul>
</li>
<li>DataSource 의 변경이 발생하더라도 repository 외부 layer 로 전파되지 않는다.</li>
<li>client 는 repository 인터페이스에 의존하기 때문에 테스트 하기 용이하다.</li>
</ul>
<p>결국 repository 는 presentation layer 와 data layer 의 coupling 을 느슨하게 만들어준다.</p>
<h1 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h1><p>Andorid 진영에서는 아래 구조를 크게 벗어나지 않는다.</p>
<p>View → Presenter / ViewModel → <strong>Repository</strong> → DataSource (API, Local DB)</p>
<p><strong>ViewModel</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInformationViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickUserInfoButton</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        mUserRepository.getUser(userId)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(</span><br><span class="line">                        user -&gt; &#123;</span><br><span class="line">                            <span class="comment">///</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        error -&gt; &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Repository</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Single&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userApi.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="놓치고-있었던-점"><a href="#놓치고-있었던-점" class="headerlink" title="놓치고 있었던 점"></a>놓치고 있었던 점</h1><p>Repository 패턴 자체는 적용이 어렵지 않다. 하지만 많은 사람들이 놓치고 있는 부분이 있는데, 위 예시에서도 찾을 수 있다.</p>
<p>바로 <strong>Repository 가 DataSource 의 데이터를 그대로 전달</strong>해준다는 점이다.</p>
<p>위 예시를 다시한번 살펴보자. UserRepository 는 UserApi 로 부터 전달받은 User 를 별다른 처리없이 그대로 리턴하고 이를 presentation layer 에서 사용하고 있다.</p>
<p>이것은 다음과 같은 문제점을 가지고 있다.</p>
<ul>
<li>back 단의 구현 이슈가 presentation layer 에 영향을 끼칠 수 있다.</li>
<li>User 는 서버 (혹은 로컬 DB) 의 데이터베이스 테이블을 표현하는 역할을 수행하는 객체일 뿐이다.</li>
</ul>
<h2 id="Data-스펙이-바뀌면-presentation-layer-전반에-영향-끼치게-된다"><a href="#Data-스펙이-바뀌면-presentation-layer-전반에-영향-끼치게-된다" class="headerlink" title="Data 스펙이 바뀌면 presentation layer 전반에 영향 끼치게 된다."></a>Data 스펙이 바뀌면 presentation layer 전반에 영향 끼치게 된다.</h2><p>필드 삭제, 필드 이름 변경 등 서버가 데이터 구조를 변경하게 되면 이를 바로 참조하고 있는 다른 layer 에서도 필연적으로 변경이 발생하게 된다. </p>
<p>예를 들어 클라쪽에서는 User 정보를 표기해야 하는데 서버에서 각기 다른 데이터의 요청을 N 번 거쳐야 한다고 생각해보자. 그럼 N 개의 데이터에 대한 변경 사항은 모두 온전히 클라에 영향을 줄 것이다. 더 중요한 점은 이렇게 복잡한 데이터 모델을 혼재하여 사용하게 되면 다른 개발자가 컨텍스트를 이해하기 매우 어려워지기 시작한다.</p>
<h2 id="서버-혹은-로컬-DB-의-데이터베이스-테이블을-표현하는-역할을-수행하는-객체일-뿐이다"><a href="#서버-혹은-로컬-DB-의-데이터베이스-테이블을-표현하는-역할을-수행하는-객체일-뿐이다" class="headerlink" title="서버 (혹은 로컬 DB) 의 데이터베이스 테이블을 표현하는 역할을 수행하는 객체일 뿐이다."></a>서버 (혹은 로컬 DB) 의 데이터베이스 테이블을 표현하는 역할을 수행하는 객체일 뿐이다.</h2><p>같은 도메인에 대하여 클라와 서버의 용어가 통일이 되는 것이 가장 이상적이겠지만 현실세계에서는 서로 다른 용어를 사용하는 경우가 허다하다. 그럴 경우 보통은 클라이언트 코드 베이스에서 라도 서로 통일이 이루어져야 한다. 그런데 서버 데이터 구조를 그대로 가져와 사용할 경우, 팀내 도메인 용어와 실제 코드 베이스의 용어가 달라지게 되고 커뮤니케이션 리소스가 급증하게 되는 상황이 발생한다.</p>
<p>또한 도메인의 비즈니스 로직 처리에 필요한 메소드를 생성할 시점이 왔을 때, (서버 테이블을 반영한) 객체에 추가하게 되면 해당 객체는 테이블도 표현하고, 도메인 로직도 처리하는 <a href="https://en.wikipedia.org/wiki/God_object" target="_blank" rel="noopener">God object</a> 가 될 확률이 높다.</p>
<h3 id="한번쯤-만들어-봤을-법한-클래스"><a href="#한번쯤-만들어-봤을-법한-클래스" class="headerlink" title="한번쯤 만들어 봤을 법한 클래스.."></a>한번쯤 만들어 봤을 법한 클래스..</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"id"</span>)               </span><br><span class="line">    <span class="keyword">private</span> String id;                </span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"nickname"</span>)               </span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="meta">@SerializedName</span>(<span class="string">"grade"</span>)               </span><br><span class="line">    <span class="keyword">private</span> String grade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Grade.MANAGER == Grade.find(grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Repository 패턴을 사용하는 목적은 data layer 와의 coupling 을 느슨하게 하는 것인데, 다시 강한 결합이 되어버린 꼴이 되었다.</p>
<h2 id="Mapper-를-활용하자"><a href="#Mapper-를-활용하자" class="headerlink" title="Mapper 를 활용하자"></a>Mapper 를 활용하자</h2><p>이러한 문제점을 해결하기 위하여 Mapper 를 사용할 수 있다. Mapper 란 말 그대로 테이블 객체 ↔ 도메인 모델 객체간의 mapping 을 시켜주는 유틸성 클래스를 의미한다. repository 내에서 mapper 를 활용하여 테이블 객체가 아닌 도메인 모델로 전달을 해주면 presentation layer 는 data layer 로 부터 진정한 자유를 찾을 수 있게 된다.<br><strong>Repository</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Single&lt;UserDomain&gt; <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userApi.getUser(userId).map(UserMapper::fromTable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Mapper</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDomain <span class="title">fromTable</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDomain(user.id, user.name, user.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>만약 모든 모델에 대하여 보일러 플레이트 코드 처럼 Mapper 클래스를 만드는 것이 싫다면 <a href="https://github.com/modelmapper/modelmapper" target="_blank" rel="noopener">라이브러리</a> 를 활용해보는 것도 좋은 대안이다.</p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>다양한 아키텍처, 패턴을 공부하다 보면 결국 변경하기 쉬운 구조를 만들기 위한 여러 시도들이라고 생각된다. 단순히 패턴의 단면만을 보고 큰 고민없이 사용하는 것이 아니라 그속에 담겨있는 핵심을 잘 이해하고 사용하는 것이 중요하다는 것을 다시금 깨닫게 된다.</p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref :"></a>Ref :</h2><ul>
<li><p><a href="https://academy.realm.io/kr/posts/clean-architecture-in-android" target="_blank" rel="noopener">https://academy.realm.io/kr/posts/clean-architecture-in-android</a></p>
</li>
<li><p><a href="https://proandroiddev.com/the-real-repository-pattern-in-android-efba8662b754" target="_blank" rel="noopener">https://proandroiddev.com/the-real-repository-pattern-in-android-efba8662b754</a></p>
</li>
<li><p><a href="https://medium.com/corebuild-software/android-repository-pattern-using-rx-room-bac6c65d7385" target="_blank" rel="noopener">https://medium.com/corebuild-software/android-repository-pattern-using-rx-room-bac6c65d7385</a></p>
</li>
<li><p><a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design</a></p>
</li>
<li><p><a href="https://medium.com/@soleilstudio/object-mapping-in-android-f56935917c61" target="_blank" rel="noopener">https://medium.com/@soleilstudio/object-mapping-in-android-f56935917c61</a></p>
</li>
</ul>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/nextstep_reviewer_review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/nextstep_reviewer_review/" class="post-title-link" itemprop="url">NextStep 리뷰어 활동을 마무리 하며</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-25 12:14:09 / Modified: 21:37:15" itemprop="dateCreated datePublished" datetime="2020-04-25T12:14:09+09:00">2020-04-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>작년 하반기에 Nextstep 의 <a href="https://vagabond95.me/2019/11/23/nextstep-class-review/">클린코드 교육과정을 참여</a>하며 배웠던 내용을 바탕으로 많은 성장을 할 수 있었다. 좋은 수업이라며 주위에 열심히 홍보를 하던 찰나, 과정을 직접 운영하고 계시는 박재성님으로부터 코드 리뷰어 활동을 제안 받게 되었다. </p>
<p>코드 리뷰어로 활동할 수 있는 실력이 안될 것 같아 고민이 되었지만, 재성님의 격려와 좋은 경험을 쌓을 수 있는 기회라고 생각이 되어 제안을 수락하였다. </p>
<p>리뷰어 활동은 약 한달간 진행되었고 그 과정속에서 깨달은 것이 많아 개인적인 정리 및 기록 차원에서 글을 남긴다.</p>
<h1 id="코드-리뷰를-진행하며"><a href="#코드-리뷰를-진행하며" class="headerlink" title="코드 리뷰를 진행하며"></a>코드 리뷰를 진행하며</h1><p>처음 리뷰를 진행할 때는 생각 이상으로 많은 시간과 에너지가 소모되었다. 회사 업무를 마치고 또 코드를 봐야하는 압박감도 있었고, 각자 다른 스타일의 코드를 꼼꼼히 확인 하고 적절한 피드백이 무엇일지 고민하고 공부해야했기 때문이다. 또한 리뷰를 마쳐야 리뷰이가 다음 단계를 진행하기 수월하기 때문에 코드가 올라오는데로 최대한 빠르게 피드백을 줄 수 있도록 신경을 써야했다. 따라서 초반에는 시간적 여유가 별로 없다보니 특별한 체계없이 정해진 리뷰의 양을 채워나갔던 것 같다.<br>점점 시간이 흐를 수록 나름의 체계가 생기고 속도가 붙어 초반보단 여유가 생겼다. 이때 나 스스로의 리뷰 방식/관점에 대해 점검해보며 아래과 같은 기준을 세우고 리뷰를 진행했다. </p>
<h2 id="1-모호한-지식은-모호한-답변을-남긴다"><a href="#1-모호한-지식은-모호한-답변을-남긴다" class="headerlink" title="1. 모호한 지식은 모호한 답변을 남긴다."></a>1. 모호한 지식은 모호한 답변을 남긴다.</h2><p>특정 내용에 대하여 피드백을 할 때마다 굉장히 모호하게 답변을 남기고 있는 것을 깨달았다. 해당 내용에 대한 정확한 지식이 없다는 신호라고 느꼈다. 이런 수준에서는 좋은 피드백을 줄 수 없을 것 같아 잠시 리뷰를 중단했다. 이후 책과 검색을 통해 좀 더 깊게 공부하고 부족해 보이는 부분을 채워나갔다. 내가 어떤 주제에 대하여 막연히만 알고 있었는지 깨닫는 좋은 순간이었다. 어느정도 정리 및 공부가 끝났다고 생각되면 다시 리뷰를 진행했고 이후에도 비슷한 주제가 나올 경우 위와 같은 과정을 반복하였다.</p>
<h2 id="2-모든-코드에는-근거가-있어야한다"><a href="#2-모든-코드에는-근거가-있어야한다" class="headerlink" title="2. 모든 코드에는 근거가 있어야한다."></a>2. 모든 코드에는 근거가 있어야한다.</h2><p>리뷰를 진행하다보면 특정 상황에서 관습적으로 굳어진듯한 구현을 발견할때가 있다. 이러한 코드를 발견하면 피드백을 남길 때 집요하게😈어떤 구현 의도를 가지고 작성했는지 물어보곤 했다.<br>관습적인 구현은 대게 큰 고민 없이 이루어지는 경우가 많다. 하지만 모든 코드는 명확한 근거가 있어야한다고 생각한다. 만약 스스로 세운 근거가 틀리더라도 큰 상관이 없다. 나중에 잘못된 방향임을 깨닫더라도 어떤 부분을 놓쳤는지 비교가 가능하기 때문이다. 특히 나같은 경우 스스로 세운 근거가 틀렸음을 깨달았을 때 더 많이 성장하는 것을 경험했기 때문에 이 부분을 특히 집중했다. </p>
<h2 id="3-나의-피드백보다-더-좋은-방향은-항상-있을-수-있다"><a href="#3-나의-피드백보다-더-좋은-방향은-항상-있을-수-있다" class="headerlink" title="3. 나의 피드백보다 더 좋은 방향은 항상 있을 수 있다."></a>3. 나의 피드백보다 더 좋은 방향은 항상 있을 수 있다.</h2><p>미션의 요구사항이 간단할 때는 리뷰이의 구현 방향이 대부분 비슷하게 수렴하고 이에 대한 베스트 케이스도 어느정도 정해져있다. 그래서 피드백으로 가이드를 남기는 것도 비교적 수월하다. 그러나 점점 미션의 요구사항이 복잡하고 어려워질 수록 다양한 접근 방식이 나타나기 시작한다. 이때 나 또한 결국 가지고 있는 지식과 경험 내에서 답변할 수 밖에 없는 한계점이 있기 때문에 항상 내가 남긴 피드백보다 더 좋은 방향이 있을 수 있다는 마음가짐으로 리뷰에 임했다.<br>실제로 다양한 방식으로 풀 수 있는 부분에 대하여 피드백을 남기면 리뷰이에게 종종 문의가 들어왔다. 이때 나는 피드백을 남긴 의도를 최대한 자세히 남겼다. 그리고 리뷰이의 의도 역시 물어본 후 각각 비교하여 장/단점을 생각해보고, 목표를 이루기 위해서 무엇을 취할 수 있을지/버려야할 지 논의했다. 이러한 과정 또한 나의 생각을 정리하고 공부하는 계기가 되어 오히려 내가 스스로 많이 배울 수 있는 좋은 거름이 되었다. 👏</p>
<p><img src="/images/next_step_reviewer.png" alt><br>(기억에 남았던 논의 과정, 지금 다시 보니 답변 내용 중 아쉬운 부분이 보인다. 😭)</p>
<h1 id="코드리뷰도-결국은"><a href="#코드리뷰도-결국은" class="headerlink" title="코드리뷰도 결국은.."></a>코드리뷰도 결국은..</h1><p>코드 리뷰도 결국은 <strong>사람과의 커뮤니케이션</strong>이다. 또한 사람은 각기 다른 커뮤니케이션 스타일을 가지고 있다. 그래서 소프트 스킬이 어렵다고 생각한다. 논의를 주고 받다보면 각 리뷰이분의 스타일을 대략적으로 파악하고, 이에 맞게 커뮤니케이션 방식을 조금씩 바꿔가며 진행해보려 노력했다.<br>소프트 스킬을 연습할 수 있는 기회는 흔치 않다고 생각되어 이부분에 대해 적지 않게 신경썼던 기억이 난다.</p>
<h1 id="가장-많이-드렸던-피드백들"><a href="#가장-많이-드렸던-피드백들" class="headerlink" title="가장 많이 드렸던 피드백들"></a>가장 많이 드렸던 피드백들</h1><p>리뷰를 하다보면 공통으로 피드백을 많이 남기는 내용이 있었다. 정리를 해보니 다음과 같다.</p>
<h2 id="이-객체가-알아야할-정보가-맞을까요"><a href="#이-객체가-알아야할-정보가-맞을까요" class="headerlink" title="이 객체가 알아야할 정보가 맞을까요?"></a>이 객체가 알아야할 정보가 맞을까요?</h2><p> → 클래스가 존재해야할 이유는 하나이다. <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="noopener">SRP</a>를 잘 지켰는지  확인했다.</p>
<h2 id="이-코드는-다른-객체에서-스스로-수행할-수-있지-않을까요"><a href="#이-코드는-다른-객체에서-스스로-수행할-수-있지-않을까요" class="headerlink" title="이 코드는 다른 객체에서 스스로 수행할 수 있지 않을까요?"></a>이 코드는 다른 객체에서 스스로 수행할 수 있지 않을까요?</h2><p>→ 객체 상태를 꺼내와서 연산을 수행하지 말고 상태를 알고 있는 객체에 명령할 것, 객체의 응집도 측면에서 확인했다.</p>
<h2 id="이-메소드의-네이밍을-좀-더-구체적으로-지어볼-수-있을까요-좀-더-구현-내용을-숨겨볼-수-있을까요"><a href="#이-메소드의-네이밍을-좀-더-구체적으로-지어볼-수-있을까요-좀-더-구현-내용을-숨겨볼-수-있을까요" class="headerlink" title="이 메소드의 네이밍을 좀 더 구체적으로 지어볼 수 있을까요? / 좀 더 구현 내용을 숨겨볼 수 있을까요?"></a>이 메소드의 네이밍을 좀 더 구체적으로 지어볼 수 있을까요? / 좀 더 구현 내용을 숨겨볼 수 있을까요?</h2><p>→ 아마 리뷰이분들 입장에서는 가장 짜증나는(?) 피드백이지 않았을까.ㅎㅎ 어떤 메소드는 이름을 자세히 짓고, 어떤 메소드는 좀 더 추상적으로 지으라니..🤬🤬</p>
<p>나는 <strong>SRP</strong> 와 <strong>캡슐화</strong>의 관점에서 피드백을 진행했다.</p>
<h3 id="1-좀-더-구체적으로-지어볼-수-있을까요"><a href="#1-좀-더-구체적으로-지어볼-수-있을까요" class="headerlink" title="(1) 좀 더 구체적으로 지어볼 수 있을까요?"></a>(1) 좀 더 구체적으로 지어볼 수 있을까요?</h3><blockquote>
<p>메소드는 하나의 일만을 수행해야 한다. 그리고 수행하는 일을 드러낼 수 있다.</p>
</blockquote>
<p>위 규칙을 지킨다면 이름이 모호한 메소드는 수행하는 일이 명확히 드러나도록 표현할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.get() <span class="comment">// (X) 수행하는 일이 명확히 나타나지 않는다. </span></span><br><span class="line">user.getName() <span class="comment">// (O) 무슨일을 수행하는지 알 수 있다.</span></span><br></pre></td></tr></table></figure>

<h3 id="2-좀-더-구현-내용을-숨겨볼-수-있을까요"><a href="#2-좀-더-구현-내용을-숨겨볼-수-있을까요" class="headerlink" title="(2) 좀 더 구현 내용을 숨겨볼 수 있을까요?"></a>(2) 좀 더 구현 내용을 숨겨볼 수 있을까요?</h3><blockquote>
<p>캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.</p>
</blockquote>
<p><a href="http://www.yes24.com/Product/Goods/74219491" target="_blank" rel="noopener">오브젝트</a>에서는 변경할 수 있는 모든 것을 캡슐화하라고 이야기 한다.<br>(관련 내용에 대하여 과거에 <a href="https://vagabond95.me/2019/10/20/object-book-4/">정리했던 글</a>이 있다.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winnerNumber.getRankWithAnotherNumber(number) <span class="comment">// (X) 전달되는 파라미터에 대한 정보가 드러난다.</span></span><br></pre></td></tr></table></figure>
<p>위와 같은 메소드의 네이밍은 전달되는 인자에 대한 정보가 메소드에 그대로 드러나 있다. 파라미터가 드러나면 어느정도 가독성은 확보할 수 있을지도 모른다. 그러나 파라미터에 대한 <strong>변경</strong>은 꽤나 빈번하게 발생하는 일이며, 그때마다 해당 메소드의 이름은 변경되어야 할 것이다. 즉, 변경에 취약하다.</p>
<p>그렇다면 어디까지 추상화해야 할까? 메소드에서 변경되지 않는 것이 딱 하나 있다. 바로 메소드가 수행하는 일이다. 따라서 메소드가 수행하는 일만 드러내는 것이 변경에 좀 더 유연한 네이밍이라고 생각되어 피드백을 남겼었다. (1) 번 내용과도 같이 생각해볼만한 부분이다. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winnerNumber.getRank(number) <span class="comment">// (O) 수행하는 일만을 명시한다.</span></span><br></pre></td></tr></table></figure>

<p>요 내용은 개인적으로 고민이 있는 부분이라 다른 의견도 들어보고 싶다. 🤔</p>
<h1 id="동시에-성장하는-경험"><a href="#동시에-성장하는-경험" class="headerlink" title="동시에 성장하는 경험"></a>동시에 성장하는 경험</h1><p>내가 알고 있는 지식을 누군가에게 설명해줄 때 가장 공부가 많이 되는 경험을 해본적이 있을 것이다. 코드 리뷰를 진행하면서 비슷한 경험을 했다. 내가 피드백을 제시하기 위해선 근거가 있어야하고 이를 위해서는 탄탄한 지식과 좋은 레퍼런스가 있어야 하기에 엄청나게 공부를 할 수 밖에 없다. 특히 날카로운 질문이 들어올 때, 질문의 주제가 내가 막연하게 알고 있는 내용일 경우 바로 바닥이 나타났기에 더욱 열심히 찾아보고 공부했다. 그래서 과정이 점점 진행될 수록 리뷰이와 내가 동시에 성장을 하는 것을 경험을 했다.</p>
<h1 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h1><p>엄청난 열정으로 구현을 진행하고 논의를 나눈 리뷰이분들, 자신의 리뷰과정을 공유하여 다양한 관점으로 볼 수 있게 해준 리뷰어분들, 중간중간 어려움이 있을 때마다 아낌없는 조언을 주신 재성님에게 다시 한번 감사드린다. 🙏<br>NextStep 에서는 클린코드 과정외에도 다양한 주제의 강의가 진행되고 있으니 관심이 있다면 <a href="https://edu.nextstep.camp/" target="_blank" rel="noopener">클릭</a>!</p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/android_not_working_ellipsize_with_autolink_or_movementmethod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/android_not_working_ellipsize_with_autolink_or_movementmethod/" class="post-title-link" itemprop="url">[안드로이드] TextView 에서 ellipsize 가 적용되지 않는 이슈 with autoLink & movementMethod</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-12 16:32:12" itemprop="dateCreated datePublished" datetime="2020-04-12T16:32:12+09:00">2020-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-25 19:40:21" itemprop="dateModified" datetime="2020-04-25T19:40:21+09:00">2020-04-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cover/ellipsis_not_working_cover.jpeg" alt></p>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul>
<li>TextView 에서 autoLink 혹은 movemnetMethod 옵션을 사용할 경우 ellipsize 가 제대로 동작하지 않는다.</li>
<li>autoLink &amp; movementMethod 혹은 ellipsize 를 커스텀하게 구현해줄 필요가 있다.</li>
<li>API 27 기준의 TextView 로 조사를 진행하였다.</li>
</ul>
<h1 id="간단해-보이는-요구-사항-삽질의-시작"><a href="#간단해-보이는-요구-사항-삽질의-시작" class="headerlink" title="간단해 보이는 요구 사항, 삽질의 시작"></a>간단해 보이는 요구 사항, 삽질의 시작</h1><p>텍스트 박스의 요구사항은 다음과 같았다.</p>
<ol>
<li>내용은 최대 N 라인 까지만 노출 가능하다. 이후 내용은 말줄임 표시로 대체</li>
<li>내용 중 web url 이 있을 경우 클릭 및 스타일링이 되어야하고 클릭 시, 인앱 브라우저로 이동해야한다.</li>
</ol>
<p>1번 사항은 <a href="https://developer.android.com/reference/android/widget/TextView#attr_android:maxLines" target="_blank" rel="noopener">maxLine</a> 과 <a href="https://developer.android.com/reference/android/widget/TextView#attr_android:ellipsize" target="_blank" rel="noopener">ellipsize</a> 를 이용하면 된다.</p>
<p>2번 사항은 <a href="https://developer.android.com/reference/android/widget/TextView#attr_android:autoLink" target="_blank" rel="noopener">autoLink</a>, <a href="https://developer.android.com/reference/android/widget/TextView#attr_android:textColorLink" target="_blank" rel="noopener">textColorLink</a>, 커스텀한 MovemetMethod 를 이용하면 된다.</p>
<p>커스텀한 MoveMentmethod 가 필요한 이유는 TextView 에서 기본으로 사용되는 <a href="https://developer.android.com/reference/android/text/method/LinkMovementMethod" target="_blank" rel="noopener">LinkMovementMethod</a> 의 경우 특정한 link 텍스트 클릭 시, 이를 감지할 수 있는 콜백을 제공하지 않고 내부에서 ACTION_VIEW intent 로 처리하기 때문이다.<br>직접 구현하기가 부담스럽다면 이런 <a href="https://github.com/saket/Better-Link-Movement-Method" target="_blank" rel="noopener">라이브러리</a> 를 이용해도 좋다.</p>
<p>어쨌든 안드로이드에서 기본적으로 제공하고 있는 속성을 활용하면 금방 완료가 가능할 것으로 보고 구현을 시작했다.<br>그런데… 아무리 빌드를 돌려봐도 ellipsis 가 표현되지 않는다.</p>
<p>구글이 그럴리 없다며 내가 잘못한 부분이 없나 몇 시간째 삽질을 하다가, 결국 하나하나 옵션을 제거하면서 결과를 비교해봤고 다음과 같은 결론을 얻었다.</p>
<ul>
<li>autoLink 혹은 setAutoMask() 를 이용하여 autoMask 플래그를 set 해줬을 경우 ellipsize 가 제대로 동작하지 않는다.</li>
<li>movementMethod 를 set 해줬을 경우 ellipsize 가 제대로 동작하지 않는다.</li>
<li></li>
</ul>
<p>전혀 연관이 없을 것 같은 각 속성이 왜 충돌하는 것일까?</p>
<h1 id="setText-와-autoLink-movementMethod"><a href="#setText-와-autoLink-movementMethod" class="headerlink" title="setText() 와 autoLink / movementMethod"></a>setText() 와 autoLink / movementMethod</h1><p>TextView 에 내용을 전달하기 위해서는 반드시 setText() 를 거쳐야한다. setText() 메소드 내부에서 autoLink 값과 movementMethod 가 영향을 주고 있는 부분은 없을까하여  setText() 내부 구현을 조사해봤다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextView.class</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == BufferType.SPANNABLE || mMovement != <span class="keyword">null</span>) &#123;</span><br><span class="line">                text = mSpannableFactory.newSpannable(text);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    mText = text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAutoLinkMask != <span class="number">0</span>) &#123;</span><br><span class="line">                Spannable s2;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">if</span> (type == BufferType.EDITABLE || text <span class="keyword">instanceof</span> Spannable) &#123;</span><br><span class="line">                    s2 = (Spannable) text;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s2 = mSpannableFactory.newSpannable(text);</span><br><span class="line">                &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    mText = s2;</span><br></pre></td></tr></table></figure>
<p>각 코드는 모두 text 를 Spannable 로 포장 해주고 있다. 이 부분을 잘 기억해 두자.</p>
<p>autolink 는 Link 에 해당하는 내용을 스타일링 해주고, movementMethod 는 link 를 클릭 했을 때 특별한 상호작용이 이루어져야 하므로 plain text 가 아닌 spannable 로 포장 해주는 것은 어느정도 납득이 간다. 그럼 이러한 특징이 ellipsize 에 어떤 영향을 줄까?</p>
<h1 id="ellipsize-적용-과정"><a href="#ellipsize-적용-과정" class="headerlink" title="ellipsize 적용 과정"></a>ellipsize 적용 과정</h1><p>TextView 에서 Ellipsize 과 관련된 몇가지 내용을 조사해봤다.</p>
<ol>
<li>TextView 의 설정이 같더라도 디스플레이 환경에 따라 실제 보이는 결과는 다를 수 있다. 그리고 실제 화면 상에 보이고 있는 TextView 에 대한 정보는 <a href="[https://developer.android.com/reference/android/text/Layout](https://developer.android.com/reference/android/text/Layout)">Layout</a> 에서 가져올 수 있다. (LinearLayout 과 같은 ViewGroup Layout 이 아니다!)</li>
</ol>
<p>따라서 ellisize 가 적용된 결과도 layout 을 통하여 가져와야 한다.</p>
<ol start="2">
<li>TextVeiw 내부에서 Layout 을 생성하는 과정에서 ellipsize 가 적용되며, 이때 mMaximumVisibleLineCount 값을 기준값으로 사용한다.</li>
</ol>
<p>여기까지만 봤을 때는 아직 특별한 연관성을 찾기 어렵다. Layout 을 생성하는 과정을 좀 더 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TextView.class</span></span><br><span class="line">    <span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spannable) &#123;</span><br><span class="line">                result = <span class="keyword">new</span> DynamicLayout(mText, mTransformed, mTextPaint, wantWidth,</span><br><span class="line">                        alignment, mTextDir, mSpacingMult, mSpacingAdd, mIncludePad,</span><br><span class="line">                        mBreakStrategy, mHyphenationFrequency, mJustificationMode,</span><br><span class="line">                        getKeyListener() == <span class="keyword">null</span> ? effectiveEllipsize : <span class="keyword">null</span>, ellipsisWidth);</span><br></pre></td></tr></table></figure>

<p>이전 단락에서 autoLink 혹은 movementMethod 를 사용했을 경우 mText 는 spannable 로 포장된다고 한 것을 떠올려 보자. 그런데 mText 가 spannable 일 경우 Layout 은 DynamicLayout 으로 생성된다. DynamincLayout 은 내부적으로 StaticLayout 을 이용하여 Text 를 렌더링하는데, <strong>이때 StaticLayout 에 mMaximumVisibleLineCount 값을 따로 설정 해주지 않는 특징이 있다</strong>. mMaximumVisibleLineCount 는 디폴트 값인 Integer.MAX_VALUE 으로 초기화 된다. 따라서 보여줄 수 있는 line 의 수가 의미상 무한대에 가까우므로 ellipsis 는 표현되지 않는다. </p>
<h1 id="원인-정리"><a href="#원인-정리" class="headerlink" title="원인 정리"></a>원인 정리</h1><p>내용이 길었는데 원인을 정리하면 다음과 같다.</p>
<ol>
<li>ellipsize 는 mMaximumVisibleLineCount 값을 기준으로 노출여부가 결정된다. 이 값은 보통 maxLines 값으로 초기화 된다.</li>
<li>autoLink or movementMethod 는 text 를 spannable 로 포장한다.</li>
<li>text 가 spannable 하면 mMaximumVisibleLineCount 이 MAX_VALUE 인 Layout 을 생성한다. 따라서 ellipsize 가 노출되지 않는다.</li>
</ol>
<h1 id="해결책"><a href="#해결책" class="headerlink" title="해결책"></a>해결책</h1><p>결국 위 상황을 해결하기 위해서는 2가지 옵션이 있다.</p>
<ol>
<li>ellipsize 를 커스텀하게 구현한다.</li>
<li>autoLink / movementMethod 를 커스텀하게 구현한다.</li>
</ol>
<p>간단해보이는 View 라도 막상 구현하다보면 생각치도 못한 엣지 케이스, 예외들이 너무 많이 발생하는 것을 경험했고 나는 이것을 유지보수 할 자신이 없었다. 그래서 최대한 기존에 구현된 내용을 이용하고자 했다.</p>
<p>각각 ellipsize 는 실제로 영향을 받는 부분이 많았고 구현이 너무 깊숙히 숨겨져있어 외부에서 컨트롤 할 수 있는 타이밍이 없을 것 같아 보류하였고<br>autoLink / movementMethod 는 구현 내용을 살펴보니 TextView 외부에서도 처리가 가능할 것 같았다.<br>따라서 autoLink / movementMethod 를 기존 구현을 최대한 참고하여 구현해보기로 하였다.</p>
<h2 id="autoLink-적용하기"><a href="#autoLink-적용하기" class="headerlink" title="autoLink 적용하기"></a>autoLink 적용하기</h2><p>TextView 내부에서 autoLink 가 적용되는 과정은 크게 2가지로 나눌 수 있다.</p>
<ol>
<li>Linkify 를 이용하여 text 에 link 스타일링</li>
<li>조건이 충족되면 디폴트 movementMethod 를 set</li>
</ol>
<p>1 번 과정은 똑같이 Linkify 를 이용하여 적용하면된다.<br>2번 과정은 오히려 막아야 하므로 조건을 충족시키지 않도록 해야한다. setLinksClickable() 를 이용하여 조건 값을 설정할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mTextView.setLinksClickable(<span class="keyword">false</span>); <span class="comment">// 디폴트 movementMethod 를 사용하지 않겠다.</span></span><br><span class="line"></span><br><span class="line">mTextView.setText(<span class="string">"Hello https://google.com !"</span>);</span><br><span class="line">Linkify.addLinks(mTextView, Linkify.WEB_URLS);</span><br></pre></td></tr></table></figure>

<h2 id="movementMethod-적용하기"><a href="#movementMethod-적용하기" class="headerlink" title="movementMethod 적용하기"></a>movementMethod 적용하기</h2><p>MovementMethod 인터페이스의 역할은 link 텍스트 클릭 이벤트를 감지하여 미리 정의된 동작을 수행하는 것이다.</p>
<p>디폴트로 사용되는 LinkMovementMethod 의 내부 구현을 살펴보면, 텍스트 터치 시 텍스트에 Clickable 한 span 이 있는지 감지하여 onClick 콜백을 호출해준다. ClickableSpan 은 곧 link 텍스트라고 봐도 좋다.</p>
<p>나는 link 텍스트를 감지하는 부분에 대한 구현만 그대로 가져와, 감지 했을 시 내가 넣어둔 콜백이 수행되는 커스텀 TouchListener 를 생성하여 사용하였다.<br>(LinkMovementMethod - onTouchEvent  내부 구현을 보면 어렵지 않게 힌트를 얻을 수 있을 것이다.)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTextView.setOnTouchListener(mCustomUrlTouchHandler);</span><br></pre></td></tr></table></figure>

<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>약간의 우회를 통하여 결과적으로는 ellipsize 도 적용되고, autoLink / movementMethod 도 이용할 수 있는 구현을 완성하였다. 하지만 말 그대로 우회일뿐 언제 이슈 케이스가 발견될지 모르기에 아직은 걱정되는 부분이 많다.<br>해당 이슈가 리포트된지 꽤 오랜 시간이 지났음에도 해결되지 않아 많은 사람들이 고통을 겪고 있는 듯 하다. 일해라 구글! 😡</p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://vagabond95.me/live_data_with_event_issue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jihoon Kim">
      <meta itemprop="description" content="내일 잊기전에 오늘 적어두는 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="기록은 기억을 지배한다">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/live_data_with_event_issue/" class="post-title-link" itemprop="url">[안드로이드] MVVM 과 LiveData 조합 시 겪을 수 있는 이슈와 해결책</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-13 22:08:20" itemprop="dateCreated datePublished" datetime="2020-03-13T22:08:20+09:00">2020-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-17 16:29:56" itemprop="dateModified" datetime="2020-03-17T16:29:56+09:00">2020-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/cover/live_data_with_event_cover.jpg" alt><br>이번 포스트에서는 MVVM 아키텍처에서 LiveData 를 사용하면서 겪었던 어려움과 여러 해결방법에 대해 적어보려한다. MVVM 에 대한 좋은 글은 이미 많이 있으므로 해당 포스트에서는 생략하고 넘어간다! </p>
<h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><ul>
<li>LiveData 는 이벤트 전달에 적합하지 않다. 약간의 변형이 필요하다.</li>
</ul>
<h1 id="데이터와-이벤트-흐름"><a href="#데이터와-이벤트-흐름" class="headerlink" title="데이터와 이벤트 흐름"></a>데이터와 이벤트 흐름</h1><p>MVVM 구조내에서 개발을 할 때, ViewModel → View 의 흐름을 다음과 같이 2가지로 나누어 다루고 있다. 일반적인 정의는 아닐 수 있으나, 해당 글에서 전개될 내용의 핵심이므로 잘 이해하고 가는 것이 중요하다.</p>
<h2 id="데이터"><a href="#데이터" class="headerlink" title="데이터"></a>데이터</h2><p>데이터는 보통 모델로부터 가공되거나 유저의 액션에 의해 얻어진 특정한 값으로 이루어진다. ObservableField 나 LiveData 형태로 래핑되어 제공되며 <strong>데이터 바인딩</strong>을 이용하여 View (XML) 에게 변경 사항이 전달된다. 대표적으로 다음과 같은 케이스가 있다.</p>
<ul>
<li>model 로 부터 가공된 list</li>
<li>visibility</li>
<li>도메인과 관련된 flag 값</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/recyclerView"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:visibility</span>=<span class="string">"@&#123;viewModel.temporaryArticles.size() &gt; 0 ? View.VISIBLE : View.GONE&#125;"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">bind:bindData</span>=<span class="string">"@&#123;viewModel.temporaryArticles&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="이벤트"><a href="#이벤트" class="headerlink" title="이벤트"></a>이벤트</h2><p>이벤트는 databinding 을 통해 수행할 수 없는 작업 즉, Activity/Fragment 레벨에서만 처리할 수 작업들로 구성된다. 이 부분은 자유도가 높지만 보통 RxJava/LiveData 를 이용하여 제공하며 Activity/Fragment 에서 이를 소비한다.  대표적으로 다음과 같은 케이스가 있다.</p>
<ul>
<li>Activity action - startActivity(), finish()</li>
<li>Dialog</li>
<li>Permission</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mViewModel.finishEvent.observe(<span class="keyword">this</span>, aVoid -&gt; finish())</span><br></pre></td></tr></table></figure>

<h1 id="LiveData-의-한계와-대안점"><a href="#LiveData-의-한계와-대안점" class="headerlink" title="LiveData 의 한계와 대안점"></a>LiveData 의 한계와 대안점</h1><p>앞서 언급했듯이 이벤트를 전달하는 것은 구현 자유도가 높은 편이다. </p>
<p>RxJava 를 이용해도 되고, LiveData 혹은 Custom 하게 Obeserver 패턴 구현체를 써도 상관 없다.  하지만 RxJava 나 Custom Observer 를 구현하면 라이프사이클을 계속 신경써줄수 밖에 없기 때문에 보통은 LiveData 를 선택한다. </p>
<p>그래도 애매할 때는 여러 레퍼런스를 참고해보며 힌트를 얻어보자. 구글에서 운영하고 있는 공식 repo 인 <a href="https://github.com/google/iosched" target="_blank" rel="noopener">Goolge IO app</a> 과 <a href="https://github.com/android/architecture-samples" target="_blank" rel="noopener">Architecture Sample</a> 를 살펴보자.</p>
<h2 id="변형된-형태의-LiveData"><a href="#변형된-형태의-LiveData" class="headerlink" title="변형된 형태의 LiveData"></a>변형된 형태의 LiveData</h2><p>각 repo 는 LiveData 를 이용하여 아래와 같이 이벤트 흐름을 처리하고 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Google IO repo</span></span><br><span class="line"><span class="keyword">private</span> val _navigateToSignInDialogAction = MutableLiveData&lt;Event&lt;Unit&gt;&gt;()</span><br><span class="line">val navigateToSignInDialogAction: LiveData&lt;Event&lt;Unit&gt;&gt;</span><br><span class="line">    get() = _navigateToSignInDialogAction</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> val _navigateToSignOutDialogAction = MutableLiveData&lt;Event&lt;Unit&gt;&gt;()</span><br><span class="line">val navigateToSignOutDialogAction: LiveData&lt;Event&lt;Unit&gt;&gt;</span><br><span class="line">    get() = _navigateToSignOutDialogAction</span><br><span class="line"></span><br><span class="line"><span class="comment">// Artictecture sample repo</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SingleLiveEvent&lt;Void&gt; mEditTaskCommand = <span class="keyword">new</span> SingleLiveEvent&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>그런데 자세히 보니 LiveData 를 그대로 쓰지 않고 변형된 형태로 쓰고 있다. IO 의 경우 데이터를 Event 로 한번 더 래핑하였고, sample 에서는 아예 새로운 구현체를 만들어 사용하고 있었다.</p>
<p>각 구현체의 내부를 좀 더 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleLiveEvent.java</span></span><br><span class="line"><span class="keyword">super</span>.observe(owner, <span class="keyword">new</span> Observer&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable T t)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mPending.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    observer.onChanged(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Event.kt</span></span><br><span class="line"><span class="function">override fun <span class="title">onChanged</span><span class="params">(event: Event&lt;T&gt;?)</span> </span>&#123;</span><br><span class="line">        event?.getContentIfNotHandled()?.let &#123; value -&gt;</span><br><span class="line">            onEventUnhandledContent(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>각 구현체의 구조는 거의 유사한데 다음과 같은 특징을 가지고 있다.</p>
<ol>
<li>LiveData 에 등록되는 Observer 를 한번 더 래핑한다.</li>
<li>래핑된 Observer 는 <strong>onChanged 콜백이 여러번 호출되는 것을 막는다.</strong></li>
</ol>
<p>구글은 왜 이러한 처리를 거쳐서 LiveData 를 사용했을까? 이유는 LiveData 내부 구조에 있다.</p>
<h2 id="LiveData-는-데이터를-위해-만들어-졌다"><a href="#LiveData-는-데이터를-위해-만들어-졌다" class="headerlink" title="LiveData 는 데이터를 위해 만들어 졌다."></a>LiveData 는 데이터를 위해 만들어 졌다.</h2><p><a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=en" target="_blank" rel="noopener">docs</a> 에서는 LiveData 를 다음과 같이 정의하고 있다.</p>
<blockquote>
<p>LiveData is an observable data holder class</p>
</blockquote>
<p>즉, <strong>LiveData 는 애초에 데이터의 전달을 위해 설계됐다는 얘기다.</strong> 다만, 리엑티브한 개념에서 데이터를 좀 더 추상적으로 생각한다면 이벤트 소스도 하나의 데이터로 생각할 수 있기에 이벤트 전달에 활용을 해도 어색하지는 않다. 다만 구조상 그대로 이벤트를 위해 사용하기에는 한계가 있어 위와 같은 변형 구조로 사용하게 되는 것이다.</p>
<p>여기서 LiveData 의 모든 코드를 다 확인하고 가기는 어려우므로 핵심적인 부분만 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        removeObserver(mObserver);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    activeStateChanged(shouldBeActive());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LiveData 는 N 개의 옵저버가 등록될 수 있고,  각 옵저버는 메모리 관리를 위해 active 라는 상태를 가지고 있다. 해당 코드를 잘보면 생명주기가 바뀔 때마다 옵저버의 active 상태를 체크하며, 생명주기가 onStart 이후이면 옵저버가 active 될 수 있다고 판단한다.</p>
<p>그리고 <strong>옵저버는 inactive → active 로 상태가 바뀌면, LiveData 데이터를 소유하고 있을 경우 이를 콜백으로 전달받는다.</strong></p>
<p>이러한 구조가 이벤트를 전달할 때 왜 문제가 될 수 있을까? 예시 상황을 가정해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MainViewModel.java</span></span><br><span class="line">LiveData&lt;String&gt; mShowLoginEvent = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// MainActivity.java</span></span><br><span class="line">mViewModel.getShowLoginEvent.observe(<span class="keyword">this</span>, <span class="keyword">this</span>::showLoginDialog)</span><br></pre></td></tr></table></figure>

<p>ViewModel 은 AAC ViewModel 을 상속 받은 것으로 가정한다.</p>
<ol>
<li>ViewModel 은 로그인 API 를 수행하고, 성공 시 다이얼로그를 띄우는 이벤트를 정의</li>
<li>MainActivity 가 onCreate 에서 이벤트를 구독</li>
<li>유저 액션으로 로그인 요청 → 로그인 수행 → 성공 → 다이얼로그 노출까지 문제 없음</li>
<li>화면이 회전됨</li>
<li>ViewModel 은 그대로 살아아있음.</li>
<li>Activity 가 다시 onCreate 에서 이벤트를 구독</li>
<li>onStart 가 됐을 때, <strong>구독한 옵저버는 inactive → active 가 되었고 이전에 발행한 로그인 이벤트 데이터가 남아있으므로 콜백이 호출되어 로그인 다이얼로그가 다시 노출 됨</strong></li>
</ol>
<p>이런 케이스도 있을 수 있다. 동일한 AAC ViewModel 을 이용하여 Activity ↔ Fragment 통신을 수행하며 Activity 에 N 개의 Fragment 가 있다면 한번 발행된 이벤트는 이후에 명시적으로 post(=setValue) 를 하지 않아도, 각 Fragment 가 구독할 때 마다 전달받을 것이다.</p>
<p><strong>즉, 이벤트를 구독하는 입장에서는 명시적으로 발행된 이벤트만 소비하고 싶은데 자꾸 이전에 발행됐던 이벤트가 전달되는 현상이 발생한다. 중요도가 높은 이벤트일수록 이러한 현상은 치명적으로 다가올 수 있다.</strong></p>
<p>*구글에 LiveData twice 만 검색해도 고통을 겪은 많은 사람들을 볼 수 있다.</p>
<p><img src="/images/google_search_live_twice.png" alt></p>
<h1 id="그럼-무엇을-선택해야할까"><a href="#그럼-무엇을-선택해야할까" class="headerlink" title="그럼 무엇을 선택해야할까?"></a>그럼 무엇을 선택해야할까?</h1><p>위와 같은 이유로 인해 LiveData 를 이벤트 전달로 사용하기 위해서, onChanged 콜백이 여러번 호출되는 것을 막는 변형구조가 탄생하게 되었다. </p>
<p>그럼 이벤트 전달을 할때는 무엇을 선택하는 것이 좋을까? 진행하고 있는 프로젝트 상황이 각자 다르기에 꼭 하나를 추천하기는 어려울 것 같다. 다만, 현재 진행하고 있는 프로젝트에서 SingleLiveData 와 커스텀 LiveEvent 를 섞어서 사용하고 있으므로 사용해보면서 느낀점을 정리해보면서 마무리하고자 한다.</p>
<h2 id="SingleLiveEvent"><a href="#SingleLiveEvent" class="headerlink" title="SingleLiveEvent"></a>SingleLiveEvent</h2><p><a href="https://github.com/android/architecture-samples/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java" target="_blank" rel="noopener">코드</a> 및 <a href="https://proandroiddev.com/singleliveevent-to-help-you-work-with-livedata-and-events-5ac519989c70" target="_blank" rel="noopener">관련 포스트</a>를 참고하면 금방 이해할 수 있을거라 생각한다.</p>
<p>구조는 단순하다. MutableLiveData 를 상속받아, 명시적으로 setValue 를 호출했을 때만 데이터가 전달되도록 flag 를 걸어주었다.</p>
<ul>
<li>장점은 MutableLiveData 를 상속받았기 때문에 기본적으로 메모리 관리나 LifeCycle 변경에 따른 처리를 따로 해줄필요가 없다. 사용방법도 기존의 LiveData 사용하듯이 쓰면 된다.</li>
<li>단점은 옵저버를 여러개 등록할 수 없다. 제일 처음 구독한 옵저버가 데이터를 소비하면 그 뒤에 등록된 옵저버는 데이터를 전달받을 수 없다. 따라서 글로벌 이벤트나 Activity 나 Fragment 가 동시에 이벤트를 구독하는 케이스 등에서 활용할 수 없다.</li>
</ul>
<h2 id="커스텀-LiveEvent"><a href="#커스텀-LiveEvent" class="headerlink" title="커스텀 LiveEvent"></a>커스텀 LiveEvent</h2><p>이 부분은 커스텀을 어떻게 하느냐에 따라 달라지기 때문에 짧게만 적겠다. 기본적인 구현 아이디어는 LifeCycleOwner 를 전달받아 생명주기에 따른 처리를 해주고, 그외에는 Observer 패턴을 그대로 따른다.</p>
<ul>
<li>장점은 옵저버를 여러개 등록할 수 있으며, LiveData 구조를 따르지 않으므로 이전 이벤트가 다시 전달되지 않는다.</li>
<li>단점은 구조를 바닥부터 새로 짜기 때문에, 초기에 LiveData 보다 안정성이 많이 떨어지는 리스크가 있다.</li>
</ul>
<h1 id="마무리하며"><a href="#마무리하며" class="headerlink" title="마무리하며"></a>마무리하며</h1><p>LiveData 가 나오면서 생명주기 관리에 대한 리소스가 줄어들고 좀 더 리엑티브한 구조로 가기 쉬워진 것은 너무나 환영할 일이다. 하지만 마구잡이로 사용했다가는 새로운 고통을 안겨줄 수 있으므로 잘 이해하고 사용하는 것이 중요하다. (리엑티브한 구조는 디버깅이 너무 괴롭다..) </p>
<p>LiveData 코드는 그리 양이 많지 않아 시간이 될 때 훑어보는 것도 큰 공부가 될 것이라고 생각한다.   👍</p>

      
    </div>

  
    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jihoon Kim</p>
  <div class="site-description" itemprop="description">내일 잊기전에 오늘 적어두는 블로그</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jihoon Kim</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

  <!-- Google AdSense end -->
  <script data-ad-client="ca-pub-5033331279793069" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <!-- Google AdSense start -->
</body>
</html>
