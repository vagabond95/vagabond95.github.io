<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>기록은 기억을 지배한다</title>
    <link>https://vagabond95.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>내일 잊기전에 오늘 적어두는 블로그</description>
    <pubDate>Sun, 13 Oct 2019 09:58:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>오브젝트 정리 Chapter 1 - 3</title>
      <link>https://vagabond95.github.io/2019/10/13/object-book-1-3/</link>
      <guid>https://vagabond95.github.io/2019/10/13/object-book-1-3/</guid>
      <pubDate>Sun, 13 Oct 2019 08:45:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;변경은 언제든 찾아올 수 있다. 변경은 피할 수 없다. 이러한 사실을 깨달은 사람들은 변경에 유연하게 대응할 수 있는 방법을 고민해왔고 이에 다영한 해결법이 제시되었다. 이번에 다루게 될 객체지향 프로그래밍도 그 중 하나라고 할 수 있다. &lt;/p
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>변경은 언제든 찾아올 수 있다. 변경은 피할 수 없다. 이러한 사실을 깨달은 사람들은 변경에 유연하게 대응할 수 있는 방법을 고민해왔고 이에 다영한 해결법이 제시되었다. 이번에 다루게 될 객체지향 프로그래밍도 그 중 하나라고 할 수 있다. </p><p>객체지향 프로그래밍. 익숙하지만 제대로 이해하고 활용하고 있다고 얘기하기는 어려운 그런 녀석이었다. Java 를 사용하면 객체지향일까? 클래스 개념을 활용하면 객체지향일까? 안타깝게도 Java 내에서 class 를 사용해도 얼마든지 절차지향적인 코드가 나올 수 있고, 실제로도 그런 코드를 많이 양산해왔다. 객체지향적인 설계에 대한 고민이 깊어질때 즘 ‘객체지향의 사실과 오해’ 책으로 알게된 조영호님의 신간이 나왔음을 들었고 ‘오브젝트’ 책을 읽기 시작했다. 이번 포스팅은 챕터 1 ~ 3 을 읽고 정리하는 내용으로 채웠다.</p><h1 id="객체간의-협력과-책임-설계-레벨"><a href="#객체간의-협력과-책임-설계-레벨" class="headerlink" title="객체간의 협력과 책임 (설계 레벨)"></a>객체간의 협력과 책임 (설계 레벨)</h1><blockquote><p>OOP 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.</p></blockquote><h2 id="잘못된-방식"><a href="#잘못된-방식" class="headerlink" title="잘못된 방식"></a>잘못된 방식</h2><p>OOP 를 막 입문하면 가장 흔하게 하는 실수가 객체의 행동이 아닌 상태에 초점을 맞추는 것이다. 객체의 상태를 먼저 결정하고, 상태에 필요한 행동을 결정한다. 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다. 또한 객체의 내부 구현은 언제든 바뀔 수 있기 때문에 결국 외부에 변화가 전파된다.</p><h2 id="객체지향-관점에서-객체의-구성-방식"><a href="#객체지향-관점에서-객체의-구성-방식" class="headerlink" title="객체지향 관점에서 객체의 구성 방식"></a>객체지향 관점에서 객체의 구성 방식</h2><p>→ 객체는 어떤 협력을 참여하는가</p><p>→ 협력을 위해서 어떤 행동을 해야하는가</p><p>→ 행동하기 위해서 어떤 상태를 가져야하는가</p><h3 id="1-객체간의-협력과-수행해야할-책임을-파악할-것"><a href="#1-객체간의-협력과-수행해야할-책임을-파악할-것" class="headerlink" title="1. 객체간의 협력과 수행해야할 책임을 파악할 것"></a>1. 객체간의 협력과 수행해야할 책임을 파악할 것</h3><blockquote><p>어플리케이션안에 어떤 객체가 필요하다면 그 이유는 단 하나여야 한다. 객체가 어떤 협력에 참여하고 있기 때문이다. 그리고 객체가 협력에 참여할 수 있는 이유는 협력에 필요한 적절한 행동을 보유하고 있기 때문이다.</p></blockquote><p>객체가 책임을 할당하는 데 필요한 메세지를 먼저 식별하고, 메세지를 처리할 객체를 나중에 선택하는 것이 중요하다. 이런 방식으로 객체를 구성할 경우 다음과 같은 이점이 있다.</p><ol><li>객체가 최소한의 퍼블릭 인터페이스를 가질 수 있게 된다.</li><li>객체의 퍼블릭 인터페이스는 무엇을 하는지만 나타낼 뿐, 어떻게 수행하는지가 노출되지 않는다.</li></ol><h3 id="2-책임을-수행하기-위해-필요한-상태-및-내부-구현-정의"><a href="#2-책임을-수행하기-위해-필요한-상태-및-내부-구현-정의" class="headerlink" title="2. 책임을 수행하기 위해 필요한 상태 및 내부 구현 정의"></a>2. 책임을 수행하기 위해 필요한 상태 및 내부 구현 정의</h3><p>객체의 퍼블릭 인터페이스가 정해졌다면, 다음으로는 퍼블릭 인터페이스로 들어온 요청을 객체 스스로 처리할 수 있도록 구성해야한다. 즉, 내부 구현 및 내부 구현에 필요한 상태의 정의가 필요하다. 객체의 상태는 그 객체가 행동을 수행하는 데 필요한 정보가 무엇인지로 결정된다. 객체는 자신의 상태를 스스로 결정하고 관리하는 자율적인 존재이기 때문이다.</p><p>협력관계속에서 다른 객체에게 무엇을 제공해야 하고 다른 객체로부터 무엇을 얻어야 하는지를 고민해야만 훌륭한 책임을 수확할 수 있다.</p><h3 id="3-책임을-조합하여-역할을-정의"><a href="#3-책임을-조합하여-역할을-정의" class="headerlink" title="3. 책임을 조합하여 역할을 정의"></a>3. 책임을 조합하여 역할을 정의</h3><p>어느정도 객체의 책임이 정의되었다면 객체의 역할을 정의할 수 있다. 코드레벨에서는 Java 기준으로 ‘interface, abstract class 를 구현한다.’ 라고도 얘기할 수 있다. 객체의 역할을 정의해주는 것이 중요한 이유는 동일한 협력을 수행하는 객체들을 추상화할 수 있기 때문이다. 협력관계가 역할이라는 추상화된 형태로 묶일 경우 당연히 변화에도 대응하기 쉬워진다. 책에서는 객체의 역할에 대해 다음과 같이 비유했다.</p><ul><li>서로 다른 배우들(객체)이 동일한 배역(역할)을 연기할 수 있다.</li><li>하나의 배우(객체)가 서로 다른 배역(역할)을 연기할 수 있다.</li></ul><p>협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부다. 역할은 객체의 구조나 상태에 의해 정의될 수 없으며, 시스템의 문맥 안에서 무엇을 하는지에 의해서만 정의될 수 있음을 주의해야한다. </p><p>번외로, 오직 한 종류의 객체만 협력에 참여하는 상황에서 역할이라는 개념을 고려하는 것이 유용할까? 역할이라는 개념을 생략하고 직접 객체를 이용해 협력을 설계하는 것이 더 좋지 않을까? 라는 궁금증이 생길 수 있다. 책에서 내린 결론은 다음과 같다.</p><p>“협력에 적합한 책임을 수행하는 대상이 한 종류라면, 간단하게 객체를 이용하면 된다. 만약 여러 종류의 객체가 협력에 이용될 수 있다면 협력의 대상은 역할이 될 것이다.</p><p><strong>하지만 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야 하고 역할과 객체를 명확하게 구분하는 것은 그렇게 중요하지는 않다는 것이다.</strong>“</p><p>즉, 상황에 맞게 역할(추상화된 형태) 혹은 객체 (구체적인 형태)를 잘 선택해서 사용하되, 어차피 바뀔 수 있는 내용이므로 설계 초기에는 크게 신경쓰지 않아도 된다고 이야기 하고 있다.</p><h1 id="객체-지향-구현-기법-구현-레벨"><a href="#객체-지향-구현-기법-구현-레벨" class="headerlink" title="객체 지향 구현 기법 (구현 레벨)"></a>객체 지향 구현 기법 (구현 레벨)</h1><h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><p>클래스를 구현하거나 개발된 클래스를 사용할 때 가장 중요한 것은 클래스의 경계를 구분 짓는 것이다. 데이터와 기능을 객체 내부로 함께 묶는 것을 <strong>캡슐화</strong>라고 한다.캡슐화 된 객체는 상태는 숨기고 행동만 public 인터페이스로 공개한다.</p><p>객체의 외부와 내부를 구분하면 클래스를 사용하는 입장에서 알아야할 지식의 양이 줄어들고, 클래스 구현자는 내부 구현을 변경할 수 있는 폭이 넓어진다.</p><h2 id="다형성"><a href="#다형성" class="headerlink" title="다형성"></a>다형성</h2><p>객체를 추상화된 형태로 제공할 수 있다. 추상화가 유연한 설계를 가능하게 하는 이유는 설계가 구체적인 상황에 결합되는 것을 방지하기 때문이다. (구체적인 상황은 항상 변경된다.) </p><p>주의할 점은 다형성을 이용하여 설계를 유연하게 가져갈수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다. 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.</p><h2 id="상속"><a href="#상속" class="headerlink" title="상속"></a>상속</h2><p>상속이 가치있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문이다. (다형성 - 업캐스팅의 활용)</p><p>주의할 점으로 상속은 객체지향 프로그래밍에서 코드를 재사용하기 위해 널리 사용되는 되지만 두가지 관점에서 설계에 안좋은 영향을 미친다. (이펙티브 자바에서도 동일한 내용의 챕터가 존재한다.) ****</p><p>구현의 재사용성으로 이용된 상속은 변경에 취약하고, 부모클래스의 캡슐화를 깨기때문에 지양해야한다. 따라서 상속의 사용 목적은 구현의 재사용보다 인터페이스를 재사용하는 것에 초점을 맞춰야 한다. </p><p>하지만 실제 개발시에는 상속을 통해 내부 구현을 재사용해야할 일이 생기기 마련이다. 따라서 상황에 맞게 적절히 활용하는 지혜가 요구된다.</p><p>상황별로 권장되는 방법은 다음과 같다.</p><ul><li>구현내용 재사용 X, 다형성 활용 O : interface (Java)</li><li>구현내용 재사용 O, 다형성 활용 O : abstract class (Java)</li><li>구현내용 재사용 O, 다형성 활용 X : composition (디자인 패턴)</li></ul><h1 id="설계의-트레이드-오프"><a href="#설계의-트레이드-오프" class="headerlink" title="설계의 트레이드 오프"></a>설계의 트레이드 오프</h1><ul><li>어떤 기능을 설계하는 방법은 한가지 이상일 수 있다.</li><li>동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이트 오프의 산물이다. 어떤 경우에도 모든 상황을 만족시킬 수 있는 설계를 만들 수는 없다.</li></ul><p>구현과 관련된 모든 것들이 트레이드 오프의 대상이 될 수 있다. 작성하는 모든 코드에는 합당한 이유가 있어야 한다. 비록 아주 사소한 결정이더라도 트레이드 오프를 통해 얻어진 결론과 그렇지 않은 결론 사이의 차이는 크다.</p>]]></content:encoded>
      
      <comments>https://vagabond95.github.io/2019/10/13/object-book-1-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2019년 상반기 회고</title>
      <link>https://vagabond95.github.io/2019/07/07/2019-harf-review/</link>
      <guid>https://vagabond95.github.io/2019/07/07/2019-harf-review/</guid>
      <pubDate>Sun, 07 Jul 2019 08:42:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;상반기에 많은 일들이 있었던 것 같은데 막상 적으려니까 잘 떠오르지 않아 당황스러웠다. 이래서 평소에 기록을 해두는 습관을 형성 해두는 것이 중요한 것 같다.&lt;/p&gt;
&lt;h1 id=&quot;이직&quot;&gt;&lt;a href=&quot;#이직&quot; class=&quot;headerlink&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>상반기에 많은 일들이 있었던 것 같은데 막상 적으려니까 잘 떠오르지 않아 당황스러웠다. 이래서 평소에 기록을 해두는 습관을 형성 해두는 것이 중요한 것 같다.</p><h1 id="이직"><a href="#이직" class="headerlink" title="이직"></a>이직</h1><p>1년 4개월 동안 다니던 회사를 뒤로하고 첫 이직을 했다. <span class="exturl" data-url="aHR0cHM6Ly96b3lpLmNv" title="https://zoyi.co">조이<i class="fa fa-external-link"></i></span>에서 개발자를 시작한 것은 정말 현명한 선택이었다. 입사 전과는 비교할 수 없을 만큼 많이 배우고 성장하는 시간을 보냈다. 그렇게 좋은 환경이었음에도 불구하고 이직을 하게 된 계기는 단순했다. 내 사고가 어느 한 방향으로 굳기 전에 새로운 변화를 맞이하여 자극을 주고 싶었고, 구체적인 자극으로서 좀 더 많은 유저가 사용하는 큰 스케일의 프로젝트를 개발 해보고 싶었다. 목표가 생기자 퇴근 후 새벽까지 이직 공부를 하며 여러 곳에 지원을 했고 결과적으로 <strong>NAVER</strong>에 입사를 하게 되었다.</p><p>사실 업무와 이직 준비를 동시에 하는 기간은 정신적으로나 육체적으로나 정말 힘들었고 포기하고 싶었던 순간이 많았다. 하지만 결과적으로 그 시간을 겪으면서 현재 내 수준을 정확히 점검할 수 있었고 당시에 정리했던 공부 내용들이 지금까지도 개발하면서 아주 큰 도움이 되고 있다. 이직할 생각이 없더라도 정기적으로 면접을 보는 경험이 좋다는 얘기가 이런 맥락에서 였나 싶었다.</p><p>네이버 내에서 맡게 된 서비스는 ‘네이버 카페’ 다. 사실 입사 전에 네이버 카페를 자주 쓰는 편이 아니었어서(…) 실 사용자수가 어느정도 인지 감이 없었는데, 생각했던 수치보다 10배나 높았다! 아주 많은 자극을 받게 될 것 같다. 👏  또한 개인적으로 인복이 정말 많다고 생각되는 것이, 전 회사 그리고 현재에도 정말 좋은 팀과 동료 들을 만나게 되었다. 특히 시니어분들이 보여주시는 모습은 나중에 내가 그 위치로 올라갔을 때 꼭 닮고 싶은 부분이었다. 현재는 입사 프로젝트를 마치고 작은 테스크부터 점차 수행 해나가고 있으며, 빨리 새로운 환경에 적응을 마치고 깃헙에 많은 잔디를 심고 싶다.</p><h1 id="개발"><a href="#개발" class="headerlink" title="개발"></a>개발</h1><p>작년 한해는 RxJava, Dagger, Clean Architecture, 함수형 프로그래밍 등 특정 기술 영역을 익히는데 관심과 시간을 투자 했다면 올해 초부터는 기본기를 좀 더 다지는 한 해를 보내고 있다. 개발을 막 시작하던 때에는 기술만 도입하면 모든 문제가 해결될 것 처럼 보였지만 역시 은탄환은 없었다. 좀 더 복잡하고 어려운 스펙, 난해한 이슈들을 맞이할수록 결국에는 기본 영역 레벨로 내려가 고민을 하게 된다. 그리고 그러한 상황들을 맞이할 때마다 내 부실한 지식과 한계를 명확히 느꼈다. 동료 개발자와 기초적인 지식과 관련하여 커뮤니케이션을 할 때, 잘 모르는 내용 이었지만 일단 아는 척을 하고 집에 가서 그 내용을 찾아볼 때는 부끄러움과 약간의 분함(?)도 찾아왔다. 위와 같은 경험을 한 뒤로는 각 분야의 기초 서적들을 구입해 퇴근 후 틈틈히 공부하고 그 내용을 노션에 정리하기 시작했다.</p><img src="https://user-images.githubusercontent.com/27072782/60766066-f7145700-a0de-11e9-9bc8-18b3ad08ce4d.png" class="study" width="500" height="600" title="study"><p> 공부를 하면 할 수록 내가 겉핥기 수준으로 알고 있는 부분이 많았고, 기존의 코드들도 좀 더 깊이 이해가 되는 부분들이 생기기 시작했다. 실제로 라이브러리나 프레임워크 내부 소스코드를 분석하다 보니 곳곳에 객체지향 원칙, 자료구조 등 기본적인 지식들이  녹아져있음을 깨닫게 되었다. 아직도 부족한 수준이지만, 꾸준히 채워 나가는데 의의를 두려한다.</p><h1 id="개발-외적인-것들"><a href="#개발-외적인-것들" class="headerlink" title="개발 외적인 것들"></a>개발 외적인 것들</h1><p><strong>주짓수</strong></p><img src="https://user-images.githubusercontent.com/27072782/60766085-3e024c80-a0df-11e9-9b1e-369b9680c2fd.jpeg" class="bbj" width="500" height="500" title="bbj"><p>친구의 지속적인 권유로 마지못해 <strong>주짓수</strong>를 시작했다. 무술류 운동은 평생 해볼일이 없을 줄 알았는데 이게 하다 보니 생각보다 재미있다..? 요즘은 입사 적응 기간이라 좀 꺾였지만 한동안은 모든 여가 시간을 주짓수로 보낼 만큼 열성을 다해서 했다. 꾸준히 운동을하면서 느낀 것이 꼭 주짓수가 아니더라도 규칙적으로 땀을 흘리는 활동은 일상생활에 많은 플러스를 가져다 준다는 것이었다. 하지만 역시나 스스로 운동을 시작한다는 것은 참으로 어려운 의지의 영역 이기에 글또 처럼 운또(?)와 같은 모임을 만들어서 운동을 꾸준히 할 수 있는 환경을 구축하는 것도 좋은 시도가 될 수 있을 것 같다.</p><p><strong>집밖으로!</strong><br>주말이든 휴가든 집에서 거의 나가지 않는 생활을 했었는데, 요즘은 의도적으로 집을 떠나려고 노력하고 있다. 집에서는 한없이 나태해지기 쉽기 때문에 이것을 경계 하려는 목적도 있고 다양한 환경, 다양한 사람들을 접하며 보고 느끼는 것이 삶에 긍정적인 영향을 주고 있음을 느끼고 있기 때문이다. 최근 목표로는 몽골 여행을 생각하고 있다. 일반적인 여행보다는 많이 힘들다는 얘기들이 많지만, 그렇기에 더더욱 체력이 점점 떨어지기 전에 도전 해보고싶다.</p><h1 id="2019년-하반기-목표"><a href="#2019년-하반기-목표" class="headerlink" title="2019년 하반기 목표"></a>2019년 하반기 목표</h1><p><strong>개발적인 측면에서는 다음과 같은 목표를 이루고 싶다.</strong></p><ul><li>네트워크 기초지식 다지기</li><li>서버 프레임워크를 통해 기본적인 서버구조 익히기</li><li>AAC 라이브러리를 활용하여 스펙 구현하기</li></ul><p><strong>개발 외적인 측면에서는 다음과 같은 목표를 이루고 싶다.</strong></p><ul><li>주짓수 블루벨트 달성</li><li>계족산 황톳길 등산하기</li><li>스노클링</li><li>다른 직군의 사람들과 네트워킹 2회 이상</li></ul><h1 id="글또-3기-다짐"><a href="#글또-3기-다짐" class="headerlink" title="글또 3기 다짐"></a>글또 3기 다짐</h1><p>꾸준히 무엇 인가를 하는 습관을 형성하기 위해서는 어느 정도의 강제성과 보상이 주어지는 환경이 중요하다고 생각한다. 그런 측면에서 글또라는 모임은 정말 좋은 취지로 그러한 환경을 잘 조성 해주는 것 같아서 운영하시는 분들과 성실히 참여해주시는 분들이 대단하다고 생각했었다. 1기 때부터 지원을 고민했지만 언젠간 하겠지라는 생각으로 미뤘었고, 그 언젠가는 오지 않는걸 알기에 이번에는 공고가 나오자마자 신청을 하게 됐다. 이번 회고 글을 쓰면서 평소에 글을 써본 경험이 적어서 작은 분량임에도 불구하고 작성하는 데에도 많은 시간이 소요됐지만 신기하게도 시간가는 줄 모르고 재밌게 적게되는 경험을 하게 됐다. 남은 기간 동안 서로의 글들을 통해 많은 배움과 성장이 있음을 기대하며 나도 열심히 달려 나가야겠다.</p>]]></content:encoded>
      
      <comments>https://vagabond95.github.io/2019/07/07/2019-harf-review/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
